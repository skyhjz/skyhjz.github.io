<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简单了解Java反射</title>
      <link href="/2025/05/12/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2025/05/12/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="简单了解Java反射"><a href="#简单了解Java反射" class="headerlink" title="简单了解Java反射"></a>简单了解Java反射</h3><h4 id="1-什么是-Java-反射？"><a href="#1-什么是-Java-反射？" class="headerlink" title="1. 什么是 Java 反射？"></a>1. 什么是 Java 反射？</h4><ul><li><strong>核心概念：</strong> 反射是指在 <strong>运行时</strong> 检查、访问和修改类、接口、字段和方法的能力。  简单来说，就是你可以在程序运行的时候，动态地获取一个类的各种信息，并操作这个类。</li><li><strong>为什么要用反射？</strong><ul><li><strong>动态性：</strong>  可以在运行时创建对象、调用方法，而不需要在编译时知道类的具体信息。 这使得程序更加灵活和可扩展。</li><li><strong>通用性：</strong>  可以编写通用的代码来处理不同类型的对象，而不需要为每种类型编写特定的代码。</li><li><strong>框架和工具的基础：</strong>  许多 Java 框架和工具（如 Spring、Hibernate、JUnit）都大量使用了反射。</li></ul></li></ul><h4 id="2-反射能做什么？"><a href="#2-反射能做什么？" class="headerlink" title="2. 反射能做什么？"></a>2. 反射能做什么？</h4><p>通过反射，我们可以：</p><ul><li><strong>获取类的 Class 对象：</strong> <code>Class</code> 对象是 Java 反射的入口点，通过 <code>Class</code> 对象可以获取类的各种信息。</li><li><strong>创建类的实例：</strong> 可以通过 <code>Class</code> 对象创建类的实例。</li><li><strong>获取类的构造方法：</strong> 可以获取类的所有构造方法，包括公有、私有和受保护的。</li><li><strong>调用类的构造方法：</strong> 可以通过构造方法创建类的实例。</li><li><strong>获取类的字段：</strong> 可以获取类的所有字段，包括公有、私有和受保护的。</li><li><strong>访问和修改字段的值：</strong> 可以读取和修改字段的值，即使是私有字段。</li><li><strong>获取类的方法：</strong> 可以获取类的所有方法，包括公有、私有和受保护的。</li><li><strong>调用类的方法：</strong> 可以调用类的方法，即使是私有方法。</li><li><strong>获取类的注解：</strong> 可以获取类、字段和方法上的注解。</li></ul><h4 id="3-反射的核心类和接口"><a href="#3-反射的核心类和接口" class="headerlink" title="3. 反射的核心类和接口"></a>3. 反射的核心类和接口</h4><p>Java 反射主要涉及以下几个核心类和接口：</p><ul><li><strong><code>java.lang.Class</code>：</strong>  代表一个类或接口。  这是反射的入口点。</li><li><strong><code>java.lang.reflect.Constructor</code>：</strong>  代表一个类的构造方法。</li><li><strong><code>java.lang.reflect.Field</code>：</strong>  代表一个类的字段。</li><li><strong><code>java.lang.reflect.Method</code>：</strong>  代表一个类的方法。</li><li><strong><code>java.lang.reflect.Modifier</code>：</strong>  提供关于类和成员访问修饰符的信息。</li><li><strong><code>java.lang.reflect.InvocationTargetException</code>：</strong>  当反射调用的方法抛出异常时，会抛出此异常。</li></ul><h4 id="4-获取-Class-对象"><a href="#4-获取-Class-对象" class="headerlink" title="4. 获取 Class 对象"></a>4. 获取 Class 对象</h4><p>要使用反射，首先需要获取 <code>Class</code> 对象。 有以下几种方式可以获取 <code>Class</code> 对象：</p><ul><li><strong><code>Class.forName(String className)</code>：</strong>  通过类的完全限定名获取 <code>Class</code> 对象。 这是最常用的方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Class name: &quot;</span> + myClass.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>类名.class</code>：</strong>  如果已经知道类的名称，可以使用这种方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; myClass = MyClass.class;</span><br><span class="line">System.out.println(<span class="string">&quot;Class name: &quot;</span> + myClass.getName());</span><br></pre></td></tr></table></figure><ul><li><strong><code>对象.getClass()</code>：</strong>  如果已经有类的实例，可以使用这种方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">Class&lt;?&gt; myClass = obj.getClass();</span><br><span class="line">System.out.println(<span class="string">&quot;Class name: &quot;</span> + myClass.getName());</span><br></pre></td></tr></table></figure><h4 id="5-创建类的实例"><a href="#5-创建类的实例" class="headerlink" title="5. 创建类的实例"></a>5. 创建类的实例</h4><p>可以通过 <code>Class</code> 对象的 <code>newInstance()</code> 方法创建类的实例（要求类必须有无参构造方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myClass.newInstance();</span><br><span class="line">    System.out.println(<span class="string">&quot;Object created: &quot;</span> + obj);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类没有无参构造方法，或者想使用带参数的构造方法，需要先获取 <code>Constructor</code> 对象，然后调用 <code>newInstance()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = myClass.getConstructor(String.class, <span class="type">int</span>.class); <span class="comment">// 获取带 String 和 int 参数的构造方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Hello&quot;</span>, <span class="number">123</span>); <span class="comment">// 调用带参数的构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Object created: &quot;</span> + obj);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-获取和访问字段"><a href="#6-获取和访问字段" class="headerlink" title="6. 获取和访问字段"></a>6. 获取和访问字段</h4><p>可以通过 <code>Class</code> 对象的 <code>getField()</code> 或 <code>getDeclaredField()</code> 方法获取字段。</p><ul><li><strong><code>getField(String name)</code>：</strong>  获取公有字段。</li><li><strong><code>getDeclaredField(String name)</code>：</strong>  获取所有字段，包括公有、私有和受保护的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">myField</span> <span class="operator">=</span> myClass.getDeclaredField(<span class="string">&quot;myPrivateField&quot;</span>); <span class="comment">// 获取名为 myPrivateField 的字段</span></span><br><span class="line">    myField.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置为可访问，即使是私有字段</span></span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    myField.set(obj, <span class="string">&quot;New value&quot;</span>); <span class="comment">// 设置字段的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) myField.get(obj); <span class="comment">// 获取字段的值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Field value: &quot;</span> + value);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-获取和调用方法"><a href="#7-获取和调用方法" class="headerlink" title="7. 获取和调用方法"></a>7. 获取和调用方法</h4><p>可以通过 <code>Class</code> 对象的 <code>getMethod()</code> 或 <code>getDeclaredMethod()</code> 方法获取方法。</p><ul><li><strong><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</strong>  获取公有方法。</li><li><strong><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：</strong>  获取所有方法，包括公有、私有和受保护的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">myMethod</span> <span class="operator">=</span> myClass.getDeclaredMethod(<span class="string">&quot;myPrivateMethod&quot;</span>, String.class); <span class="comment">// 获取名为 myPrivateMethod 的方法，参数类型为 String</span></span><br><span class="line">    myMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置为可访问，即使是私有方法</span></span><br><span class="line">    <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) myMethod.invoke(obj, <span class="string">&quot;World&quot;</span>); <span class="comment">// 调用方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Method result: &quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-代码示例：完整的反射示例"><a href="#8-代码示例：完整的反射示例" class="headerlink" title="8. 代码示例：完整的反射示例"></a>8. 代码示例：完整的反射示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取 Class 对象</span></span><br><span class="line">            Class&lt;?&gt; myClass = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Class name: &quot;</span> + myClass.getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 创建实例</span></span><br><span class="line">            Constructor&lt;?&gt; constructor = myClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Hello&quot;</span>, <span class="number">123</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Object created: &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 获取和访问字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">myField</span> <span class="operator">=</span> myClass.getDeclaredField(<span class="string">&quot;myPrivateField&quot;</span>);</span><br><span class="line">            myField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            myField.set(obj, <span class="string">&quot;New value&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) myField.get(obj);</span><br><span class="line">            System.out.println(<span class="string">&quot;Field value: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 获取和调用方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">myMethod</span> <span class="operator">=</span> myClass.getDeclaredMethod(<span class="string">&quot;myPrivateMethod&quot;</span>, String.class);</span><br><span class="line">            myMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) myMethod.invoke(obj, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Method result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">myPrivateField</span> <span class="operator">=</span> <span class="string">&quot;Original value&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">myPublicField</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(String str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClass constructor with parameters called: &quot;</span> + str + <span class="string">&quot;, &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">myPrivateMethod</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + arg + <span class="string">&quot;, myPrivateField = &quot;</span> + myPrivateField;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPublicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;myPublicMethod called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-反射的优缺点"><a href="#9-反射的优缺点" class="headerlink" title="9. 反射的优缺点"></a>9. 反射的优缺点</h4><ul><li><p><strong>优点：</strong></p><ul><li><strong>动态性：</strong>  允许在运行时动态地加载类、创建对象、调用方法。</li><li><strong>通用性：</strong>  可以编写通用的代码来处理不同类型的对象。</li><li><strong>可扩展性：</strong>  方便扩展应用程序，而不需要修改现有的代码。</li></ul></li><li><p><strong>缺点：</strong></p><ul><li><strong>性能开销：</strong>  反射操作通常比直接代码执行慢，因为它涉及到运行时的类型检查和方法调用。</li><li><strong>安全问题：</strong>  反射可以访问和修改私有成员，这可能会破坏类的封装性，导致安全问题。</li><li><strong>可读性差：</strong>  反射代码通常比较复杂，难以阅读和维护。</li><li><strong>异常处理：</strong>  反射操作需要处理很多异常，例如 <code>ClassNotFoundException</code>、<code>NoSuchMethodException</code>、<code>IllegalAccessException</code> 等。</li></ul></li></ul><h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h4><p>Java 反射是一种强大的机制，它允许在运行时检查、访问和修改类、接口、字段和方法。 虽然反射提供了很大的灵活性，但也需要注意其性能开销、安全问题和可读性问题。 在使用反射时，需要权衡其优缺点，并根据实际情况进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-中介者模式</title>
      <link href="/2025/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之中介者模式"><a href="#设计模式之中介者模式" class="headerlink" title="设计模式之中介者模式"></a>设计模式之中介者模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>中介者模式</strong>是一种行为型设计模式，它用一个中介对象来封装一系列的对象交互。 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。  中介者模式的核心思想是将对象间的复杂网状关系转换为星型关系，由中介者负责协调对象间的交互。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ul><li><strong>一组对象以复杂的方式相互关联，导致关系难以理解和维护时</strong>。 中介者模式可以将这些对象之间的交互逻辑集中管理。</li><li><strong>对象之间的交互行为可以被抽象和集中化时</strong>。 如果对象之间的交互行为是多变的，那么使用中介者模式可以方便地修改和扩展这些交互行为。</li><li><strong>需要对一组对象之间的交互进行统一控制时</strong>。 例如，在图形界面中，多个控件之间的联动关系可以使用中介者模式来管理。</li><li><strong>当一个对象修改需要通知其他对象，但是不希望直接依赖其他对象时</strong>。 例如，在一个团队协作工具中，当一个成员修改了任务状态，需要通知其他成员，可以使用中介者模式来实现。</li></ul><h4 id="3-模式作用"><a href="#3-模式作用" class="headerlink" title="3. 模式作用"></a>3. 模式作用</h4><ul><li><strong>降低耦合度：</strong> 中介者模式通过将对象之间的直接引用改为通过中介者进行间接引用，降低了对象之间的耦合度。 这使得系统更容易修改和扩展。</li><li><strong>集中控制交互：</strong> 中介者模式将对象之间的交互集中到一个中介者对象中进行管理，使得系统更加易于维护和扩展。 可以方便地对交互逻辑进行修改和扩展。</li><li><strong>符合单一职责原则：</strong> 每个对象只需要关注自己的职责，而不需要关心与其他对象的交互。 对象之间的交互逻辑由中介者负责。</li><li><strong>简化系统结构：</strong>  将多对多的复杂关系简化为一对多的关系，降低了系统的复杂性。</li><li><strong>提高可复用性：</strong>  将对象之间的交互逻辑提取到中介者中，使得对象可以更容易地在其他场景中复用。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>场景</strong></p><p>以一个简单的聊天室为例。 聊天室中有多个用户，用户之间可以通过聊天室进行消息传递. 我们可以使用中介者模式来管理用户之间的交互，用户不需要直接与其他用户通信，而是通过聊天室中介者来发送和接收消息。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 中介者 (Mediator) 接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ChatRoomMediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体中介者 (Concrete Mediator) 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatRoom</span> <span class="keyword">implements</span> <span class="title class_">ChatRoomMediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatRoom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, User user)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (User u : <span class="built_in">this</span>.users) &#123;</span><br><span class="line">            <span class="comment">// 消息不发给自己</span></span><br><span class="line">            <span class="keyword">if</span> (u != user) &#123;</span><br><span class="line">                u.receive(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 抽象同事类 (Abstract Colleague)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> ChatRoomMediator mediator;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(ChatRoomMediator mediator, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 具体同事类 (Concrete Colleague)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatUser</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatUser</span><span class="params">(ChatRoomMediator mediator, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 发送消息: &quot;</span> + message);</span><br><span class="line">        mediator.sendMessage(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; 接收消息: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 客户端代码 (演示)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChatRoomMediator</span> <span class="variable">chatRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatRoom</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatUser</span>(chatRoom, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        chatRoom.addUser(user1);</span><br><span class="line">        chatRoom.addUser(user2);</span><br><span class="line">        chatRoom.addUser(user3);</span><br><span class="line"></span><br><span class="line">        user1.send(<span class="string">&quot;大家好！&quot;</span>);</span><br><span class="line">        user2.send(<span class="string">&quot;你好，张三！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">张三 发送消息: 大家好！</span><br><span class="line">李四 接收消息: 大家好！</span><br><span class="line">王五 接收消息: 大家好！</span><br><span class="line">李四 发送消息: 你好，张三！</span><br><span class="line">张三 接收消息: 你好，张三！</span><br><span class="line">王五 接收消息: 你好，张三！</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ol><li><p><strong><code>ChatRoomMediator</code> (中介者接口):</strong></p><ul><li>定义了中介者需要实现的方法：<code>sendMessage()</code> 用于发送消息，<code>addUser()</code> 用于添加用户。  中介者接口定义了同事对象之间交互的接口。</li></ul></li><li><p><strong><code>ChatRoom</code> (具体中介者类):</strong></p><ul><li><code>ChatRoom</code> 实现了 <code>ChatRoomMediator</code> 接口。 具体中介者类实现了中介者接口，并负责协调同事对象之间的交互。</li><li><code>sendMessage()</code> 方法负责将消息发送给聊天室中的其他用户。  该方法遍历所有用户，并将消息发送给除了发送者之外的所有用户。</li><li><code>addUser()</code> 方法用于将用户添加到聊天室中。  该方法将用户添加到内部维护的用户列表中。</li><li>维护了一个 <code>List&lt;User&gt;</code> 来管理聊天室中的用户。  该列表用于存储所有参与聊天的用户对象。</li></ul></li><li><p><strong><code>User</code> (抽象同事类):</strong></p><ul><li><code>User</code> 是一个抽象类，定义了用户的基本属性和方法。  抽象同事类定义了所有具体同事类的通用接口。</li><li><code>send()</code> 方法用于发送消息。  该方法由具体同事类实现，用于发送消息。</li><li><code>receive()</code> 方法用于接收消息。 该方法由具体同事类实现，用于接收消息。</li><li>持有 <code>ChatRoomMediator</code> 的引用，以便与中介者进行交互。  通过中介者对象，同事对象可以与其他同事对象进行通信。</li></ul></li><li><p><strong><code>ChatUser</code> (具体同事类):</strong></p><ul><li><code>ChatUser</code> 继承自 <code>User</code> 类，实现了 <code>send()</code> 和 <code>receive()</code> 方法。  具体同事类实现了抽象同事类，并负责实现具体的业务逻辑。</li><li><code>send()</code> 方法调用中介者的 <code>sendMessage()</code> 方法来发送消息。 通过中介者发送消息，降低了同事对象之间的耦合度。</li><li><code>receive()</code> 方法用于接收消息并打印到控制台。  接收到消息后，将消息内容打印到控制台。</li></ul></li><li><p><strong><code>MediatorPatternDemo</code> (客户端):</strong></p><ul><li>客户端代码创建 <code>ChatRoom</code> 对象 (中介者)。  创建中介者对象，用于协调用户之间的交互。</li><li>客户端代码创建多个 <code>ChatUser</code> 对象，并将它们添加到聊天室中。  创建多个用户对象，并将它们添加到聊天室中。</li><li>客户端代码调用 <code>ChatUser</code> 的 <code>send()</code> 方法来发送消息，消息通过中介者传递给其他用户。  用户通过调用send方法发送消息，消息会通过中介者传递给其他用户。</li></ul></li></ol><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>中介者模式是一种行为型设计模式，它通过引入一个中介者对象，将对象之间的交互行为集中管理，从而降低对象之间的耦合度，简化系统结构。 中介者模式特别适用于对象之间存在复杂的交互关系，且这些交互关系可以被抽象和集中化的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-备忘录模式</title>
      <link href="/2025/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之备忘录模式"><a href="#设计模式之备忘录模式" class="headerlink" title="设计模式之备忘录模式"></a>设计模式之备忘录模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>备忘录模式</strong>是一种行为型设计模式，它允许在不暴露对象内部状态的情况下保存对象的内部状态，并在以后可以恢复到先前的状态。 它主要用于撤销操作、版本控制等场景。</p><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ul><li><strong>需要保存和恢复对象内部状态，且不希望暴露对象内部结构时</strong>。 这是备忘录模式的核心应用场景。</li><li><strong>需要实现撤销&#x2F;重做 (Undo&#x2F;Redo) 功能时</strong>。 例如，文本编辑器、图像编辑器等。</li><li><strong>需要进行事务回滚时</strong>。 在数据库操作中，可以使用备忘录模式来保存事务开始前的状态，以便在事务失败时回滚到初始状态。</li><li><strong>需要创建对象的快照 (Snapshot) 用于历史记录或审计时</strong>。 例如，游戏中的存档功能。</li><li><strong>工作流或者流程审批</strong>：在工作流系统中，一个流程实例可能需要经历多个状态，并且可能需要回退到之前的某个状态。备忘录模式可以用来保存流程实例的状态，以便在需要时进行回退。</li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p><strong>备忘录模式的优点：</strong></p><ul><li><strong>保存和恢复对象的状态：</strong> 备忘录模式允许在不破坏封装性的前提下，保存和恢复对象的状态。  发起人可以完全控制存储和恢复状态的细节。</li><li><strong>实现撤销&#x2F;重做功能：</strong> 备忘录模式可以用来实现撤销&#x2F;重做功能。 允许多个状态的保存和恢复，实现多级撤销。</li><li><strong>支持版本控制：</strong> 备忘录模式可以用来实现版本控制。</li><li><strong>符合单一职责原则：</strong>  将状态的保存和恢复的职责分离到备忘录类中，符合单一职责原则。</li></ul><p><strong>备忘录模式的缺点：</strong></p><ul><li><strong>存储成本：</strong> 如果需要保存的状态很多，或者状态对象很大，那么存储备忘录对象的成本可能会很高。 需要考虑备忘录对象的生命周期管理，避免内存泄漏。</li><li><strong>复杂性：</strong> 备忘录模式可能会增加代码的复杂性，特别是当状态对象比较复杂时。  需要仔细设计备忘录类的结构，以及发起人和负责人之间的交互。</li><li><strong>负责人职责不明确：</strong>  负责人只负责存储备忘录对象，不参与状态的修改，这可能导致负责人类的职责不够明确。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>示例：文本编辑器</strong></p><p>还是以一个简单的文本编辑器为例。 文本编辑器允许用户输入文本，并提供撤销功能。 我们可以使用备忘录模式来保存文本编辑器的状态（即文本内容），并在用户需要撤销时，恢复到之前的状态。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 备忘录 (Memento) 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditorMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EditorMemento</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发起人 (Originator) 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TextEditor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = <span class="string">&quot;&quot;</span>; <span class="comment">// 初始文本为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建备忘录，保存当前状态</span></span><br><span class="line">    <span class="keyword">public</span> EditorMemento <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存状态: &quot;</span> + text);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EditorMemento</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从备忘录恢复状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(EditorMemento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = memento.getText();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复状态: &quot;</span> + text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 负责人 (Caretaker) 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">History</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;EditorMemento&gt; mementos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(EditorMemento memento)</span> &#123;</span><br><span class="line">        mementos.add(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EditorMemento <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mementos.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 或者抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">EditorMemento</span> <span class="variable">lastState</span> <span class="operator">=</span> mementos.remove(mementos.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> lastState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端代码 (演示)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TextEditor</span> <span class="variable">editor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextEditor</span>();</span><br><span class="line">        <span class="type">History</span> <span class="variable">history</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">History</span>();</span><br><span class="line"></span><br><span class="line">        editor.setText(<span class="string">&quot;这是第一版内容&quot;</span>);</span><br><span class="line">        history.push(editor.save());</span><br><span class="line"></span><br><span class="line">        editor.setText(<span class="string">&quot;这是第二版内容&quot;</span>);</span><br><span class="line">        history.push(editor.save());</span><br><span class="line"></span><br><span class="line">        editor.setText(<span class="string">&quot;这是第三版内容&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前内容: &quot;</span> + editor.getText()); <span class="comment">// 当前内容: 这是第三版内容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销到第二版</span></span><br><span class="line">        <span class="type">EditorMemento</span> <span class="variable">memento</span> <span class="operator">=</span> history.pop();</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>) &#123;</span><br><span class="line">            editor.restore(memento);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前内容: &quot;</span> + editor.getText()); <span class="comment">// 当前内容: 这是第二版内容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销到第一版</span></span><br><span class="line">        memento = history.pop();</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>) &#123;</span><br><span class="line">            editor.restore(memento);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前内容: &quot;</span> + editor.getText()); <span class="comment">// 当前内容: 这是第一版内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">保存状态: 这是第一版内容</span><br><span class="line">保存状态: 这是第二版内容</span><br><span class="line">当前内容: 这是第三版内容</span><br><span class="line">恢复状态: 这是第二版内容</span><br><span class="line">当前内容: 这是第二版内容</span><br><span class="line">恢复状态: 这是第一版内容</span><br><span class="line">当前内容: 这是第一版内容</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ol><li><p><strong><code>EditorMemento</code> (备忘录类):</strong></p><ul><li>负责存储 <code>TextEditor</code> 的内部状态 (<code>text</code>)。</li><li><code>EditorMemento</code> 对象只包含状态信息，并且不提供修改状态的方法 (只读)。 这保证了 <code>TextEditor</code> 的状态只能通过 <code>TextEditor</code> 本身来修改，避免了外部直接修改状态导致的问题.</li></ul></li><li><p><strong><code>TextEditor</code> (发起人类):</strong></p><ul><li><code>TextEditor</code> 是我们要保存状态的对象。</li><li><code>setText()</code> 方法用于设置文本内容。</li><li><code>save()</code> 方法创建一个 <code>EditorMemento</code> 对象，保存当前 <code>TextEditor</code> 的状态 (创建一个快照)。</li><li><code>restore()</code> 方法从 <code>EditorMemento</code> 对象恢复 <code>TextEditor</code> 的状态。</li></ul></li><li><p><strong><code>History</code> (负责人):</strong></p><ul><li><code>History</code> 负责保存和管理备忘录对象。</li><li>它使用 <code>List</code> 来存储 <code>EditorMemento</code> 对象。</li><li><code>push()</code> 方法将 <code>EditorMemento</code> 对象添加到 <code>List</code> 中。</li><li><code>pop()</code> 方法从 <code>List</code> 中移除并返回最后一个 <code>EditorMemento</code> 对象 (实现撤销功能)。</li></ul></li><li><p><strong><code>MementoPatternDemo</code> (客户端):</strong></p><ul><li>客户端代码创建 <code>TextEditor</code> 和 <code>History</code> 对象。</li><li>客户端代码设置 <code>TextEditor</code> 的文本内容，并使用 <code>history.push(editor.save())</code> 保存状态。</li><li>客户端代码可以使用 <code>history.pop()</code> 获取之前的 <code>EditorMemento</code> 对象，并使用 <code>editor.restore()</code> 恢复到之前的状态。</li></ul></li></ol><h4 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h4><ul><li><strong>备忘录的不可变性：</strong> 备忘录对象一旦创建，就不应该被修改。这保证了状态的安全性。 可以将备忘录类设计为不可变类。</li><li><strong>负责人不修改备忘录：</strong> 负责人只负责存储和管理备忘录对象，不应该修改备忘录对象的内容。 负责人不应该持有备忘录对象的引用，只应该持有备忘录对象的副本。</li><li><strong>发起人创建和恢复备忘录：</strong> 只有发起人才能创建备忘录对象，并且只有发起人才能从备忘录对象恢复状态。  可以使用内部类来实现备忘录类，限制备忘录类的访问权限。</li></ul><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p>备忘录模式是一种行为型设计模式，它通过将对象的状态封装到独立的备忘录对象中，实现了在不破坏封装性的前提下保存和恢复对象状态的功能。 这种模式特别适用于需要实现撤销&#x2F;重做、版本控制、事务回滚等功能的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 备忘录模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-状态模式</title>
      <link href="/2025/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之状态模式"><a href="#设计模式之状态模式" class="headerlink" title="设计模式之状态模式"></a>设计模式之状态模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>状态模式</strong>允许一个对象在其内部状态改变时改变它的行为。 对象看起来好像修改了它的类。 它通过将状态封装到独立的类中来实现，并且在环境类中维护一个指向当前状态对象的引用。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ul><li><strong>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时</strong>。例如，一个TCP连接，它有”已建立”、”已监听”、”已关闭”等状态，不同的状态下，对数据的处理方式不同。</li><li><strong>当一个操作中含有庞大的多分支条件语句，且这些分支依赖于对象的状态时</strong>。状态模式可以将每一个分支都封装到独立的类中，消除冗长的条件判断。</li><li><strong>当需要在不同状态下执行不同的操作，并且状态的数量是可预见的，且可能需要增加新的状态时</strong>。</li><li><strong>当对象的状态转换规则复杂，并且希望将状态转换的逻辑与对象的核心业务逻辑分离时</strong>。</li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p><strong>状态模式的优点：</strong></p><ul><li><strong>将状态相关的行为局部化:</strong> 状态模式将状态相关的行为封装到单独的类中，使得代码更加清晰，易于维护。</li><li><strong>易于扩展:</strong> 增加新的状态很容易，只需要创建新的状态类即可，而不需要修改现有的代码。</li><li><strong>符合开闭原则:</strong> 对扩展开放，对修改关闭。</li><li><strong>避免大量的条件语句:</strong> 状态模式避免了在环境类中使用大量的 <code>if-else</code> 或 <code>switch</code> 语句来判断当前状态并执行相应的操作。</li><li><strong>更好的代码组织:</strong> 将状态的定义和状态相关的行为集中在一起，提高了代码的可读性和可维护性。</li></ul><p><strong>状态模式的缺点：</strong></p><ul><li><strong>类的数量增加:</strong> 每个状态都需要一个单独的类，这会增加类的数量。</li><li><strong>状态转换逻辑分散:</strong> 状态转换的逻辑可能分散在各个状态类中，这可能会使状态之间的关系变得复杂。 可以考虑使用状态转换表来集中管理状态转换逻辑，以降低复杂性。</li><li><strong>增加了系统的复杂性:</strong> 在简单的状态切换场景下，可能显得过于繁琐。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>示例：电梯</strong></p><p>我们以一个简单的电梯为例。 电梯可以有几种状态：</p><ul><li><strong>停止 (Stopped)</strong></li><li><strong>运行向上 (MovingUp)</strong></li><li><strong>运行向下 (MovingDown)</strong></li></ul><p>当用户按下向上&#x2F;向下按钮时，电梯的状态会改变，电梯的动作（例如开门，关门，上下移动）也会根据状态改变。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 状态接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">(Elevator elevator)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">(Elevator elevator)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">goUp</span><span class="params">(Elevator elevator)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">goDown</span><span class="params">(Elevator elevator)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Elevator elevator)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体状态类 (停止状态)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoppedState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门已打开.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="built_in">this</span>); <span class="comment">// 保持停止状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门已关闭.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goUp</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯开始向上运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">MovingUpState</span>()); <span class="comment">// 切换到向上运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goDown</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯开始向下运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">MovingDownState</span>()); <span class="comment">// 切换到向下运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯已经停止.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体状态类 (向上运行状态)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingUpState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行，不能打开门.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门已关闭.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goUp</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在向上运行.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goDown</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯改变方向，开始向下运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">MovingDownState</span>());  <span class="comment">// 切换到向下运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">StoppedState</span>()); <span class="comment">// 切换到停止状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 具体状态类 (向下运行状态)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingDownState</span> <span class="keyword">implements</span> <span class="title class_">ElevatorState</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行，不能打开门.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门已关闭.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goUp</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯改变方向，开始向上运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">MovingUpState</span>()); <span class="comment">// 切换到向上运行状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goDown</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在向下运行.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Elevator elevator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止运行.&quot;</span>);</span><br><span class="line">        elevator.setState(<span class="keyword">new</span> <span class="title class_">StoppedState</span>()); <span class="comment">// 切换到停止状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 环境类 (电梯)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ElevatorState state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Elevator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="keyword">new</span> <span class="title class_">StoppedState</span>(); <span class="comment">// 初始状态为停止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(ElevatorState state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        state.openDoor(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        state.closeDoor(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goUp</span><span class="params">()</span> &#123;</span><br><span class="line">        state.goUp(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goDown</span><span class="params">()</span> &#123;</span><br><span class="line">        state.goDown(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        state.stop(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 客户端代码 (演示)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Elevator</span> <span class="variable">elevator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elevator</span>();</span><br><span class="line"></span><br><span class="line">        elevator.openDoor();</span><br><span class="line">        elevator.closeDoor();</span><br><span class="line">        elevator.goUp();</span><br><span class="line">        elevator.goDown();</span><br><span class="line">        elevator.stop();</span><br><span class="line">        elevator.openDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ol><li><p><strong><code>ElevatorState</code> (状态接口):</strong> 定义了电梯所有状态都需要实现的方法（<code>openDoor</code>, <code>closeDoor</code>, <code>goUp</code>, <code>goDown</code>, <code>stop</code>）。</p></li><li><p><strong><code>StoppedState</code>, <code>MovingUpState</code>, <code>MovingDownState</code> (具体状态类):</strong> 这些类实现了 <code>ElevatorState</code> 接口，并根据电梯的不同状态，定义了各个方法的具体行为。 例如，在 <code>MovingUpState</code> 中，<code>openDoor</code> 方法会输出 “电梯正在运行，不能打开门.”，而在 <code>StoppedState</code> 中则会打开电梯门。 重要的是，状态类还可以负责状态的切换（例如，<code>goUp</code> 在 <code>StoppedState</code> 中会切换到 <code>MovingUpState</code>）。</p></li><li><p><strong><code>Elevator</code> (环境类):</strong> <code>Elevator</code> 类维护了一个 <code>ElevatorState</code> 类型的成员变量 <code>state</code>，用来表示电梯的当前状态。 它还提供了 <code>openDoor</code>, <code>closeDoor</code>, <code>goUp</code>, <code>goDown</code>, <code>stop</code> 等方法，这些方法实际上是委托给当前状态对象来执行的。 <code>setState</code> 方法用于改变电梯的状态。</p></li><li><p><strong><code>StatePatternDemo</code> (客户端):</strong> 演示了如何使用状态模式。 客户端代码只需要与 <code>Elevator</code> 对象交互，而不需要关心电梯的具体状态。</p></li></ol><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5. 运行结果"></a>5. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">电梯门已打开.</span><br><span class="line">电梯门已关闭.</span><br><span class="line">电梯开始向上运行.</span><br><span class="line">电梯改变方向，开始向下运行.</span><br><span class="line">电梯停止运行.</span><br><span class="line">电梯门已打开.</span><br></pre></td></tr></table></figure><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>总的来说，状态模式是一种强大的设计模式，它可以帮助我们更好地组织和管理对象的状态和行为，提高代码的可维护性和可扩展性。 但是，在使用状态模式时，需要权衡其优点和缺点，并根据实际情况选择最适合的设计方案。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 状态模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-命令模式</title>
      <link href="/2025/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之命令模式"><a href="#设计模式之命令模式" class="headerlink" title="设计模式之命令模式"></a>设计模式之命令模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>命令模式</strong> 是一种<strong>行为型设计模式</strong>，它将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ul><li><strong>需要参数化对象的操作：</strong> 命令模式可以将操作封装成对象，从而允许你将操作作为参数传递给其他对象。</li><li><strong>需要指定、排列和执行请求：</strong> 命令模式可以将请求排队，并在需要时执行。</li><li><strong>需要支持撤销操作：</strong> 命令模式可以保存命令的历史记录，从而允许你撤销之前的操作。</li><li><strong>需要在不同的时刻指定请求、将请求排队和执行请求。</strong></li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>降低耦合度：</strong> 命令模式将请求发送者和接收者解耦，使得它们可以独立变化。</li><li><strong>易于扩展：</strong> 可以很容易地添加新的命令类，而无需修改现有的代码。</li><li><strong>支持撤销操作：</strong> 可以通过保存命令的历史记录来实现撤销操作。</li><li><strong>可以实现请求的排队和日志记录。</strong></li><li><strong>可以将多个简单命令组合成一个“宏命令”。</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>可能会导致类数量增加：</strong> 对于每个操作都需要创建一个命令类，可能会导致系统中类的数量增加。</li><li><strong>增加了系统的复杂性：</strong> 需要维护命令接口、具体命令类、接收者和调用者之间的关系，增加了系统的复杂性。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>场景:</strong></p><p>假设你正在开发一个简单的文本编辑器。 你需要实现一些常见的操作，例如打开文件、保存文件和关闭文件。 使用命令模式，你可以将这些操作封装成命令对象，然后将这些命令对象传递给执行者来执行。</p><p><strong>1. 命令接口 (Command Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令接口，定义了 execute 方法，用于执行命令</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体命令 (Concrete Commands)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenFileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextFile textFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenFileCommand</span><span class="params">(TextFile textFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textFile = textFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        textFile.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存文件命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaveFileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextFile textFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SaveFileCommand</span><span class="params">(TextFile textFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textFile = textFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        textFile.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭文件命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloseFileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TextFile textFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CloseFileCommand</span><span class="params">(TextFile textFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.textFile = textFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        textFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 接收者 (Receiver)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文本文件类，是命令的接收者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextFile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TextFile</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开文件: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存文件: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭文件: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 调用者 (Invoker)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者类，负责调用命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileInvoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileInvoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommandPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文本文件对象</span></span><br><span class="line">        <span class="type">TextFile</span> <span class="variable">textFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextFile</span>(<span class="string">&quot;my_document.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建命令对象</span></span><br><span class="line">        <span class="type">OpenFileCommand</span> <span class="variable">openFileCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenFileCommand</span>(textFile);</span><br><span class="line">        <span class="type">SaveFileCommand</span> <span class="variable">saveFileCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaveFileCommand</span>(textFile);</span><br><span class="line">        <span class="type">CloseFileCommand</span> <span class="variable">closeFileCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloseFileCommand</span>(textFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建调用者对象，并设置命令</span></span><br><span class="line">        <span class="type">FileInvoker</span> <span class="variable">fileInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInvoker</span>(openFileCommand);</span><br><span class="line">        fileInvoker.executeCommand();</span><br><span class="line"></span><br><span class="line">        fileInvoker = <span class="keyword">new</span> <span class="title class_">FileInvoker</span>(saveFileCommand);</span><br><span class="line">        fileInvoker.executeCommand();</span><br><span class="line"></span><br><span class="line">        fileInvoker = <span class="keyword">new</span> <span class="title class_">FileInvoker</span>(closeFileCommand);</span><br><span class="line">        fileInvoker.executeCommand();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-关键点说明"><a href="#5-关键点说明" class="headerlink" title="5. 关键点说明"></a>5. 关键点说明</h4><ul><li><strong>封装请求：</strong> 命令模式的核心思想是将请求封装成对象。 这使得我们可以将请求作为参数传递给其他对象，或者将请求存储在队列中，并在稍后执行。</li><li><strong>解耦发送者和接收者：</strong> 命令模式将请求的发送者和接收者解耦。 发送者不需要知道接收者的具体实现，只需要知道命令接口即可。</li><li><strong>支持撤销：</strong> 通过在命令对象中保存执行前的状态，可以实现撤销操作。</li></ul><h4 id="6-运行结果："><a href="#6-运行结果：" class="headerlink" title="6. 运行结果："></a>6. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开文件: my_document.txt</span><br><span class="line">保存文件: my_document.txt</span><br><span class="line">关闭文件: my_document.txt</span><br></pre></td></tr></table></figure><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p><strong>命令模式</strong> 是一种强大的设计模式，可以用于解耦请求的发送者和接收者，支持撤销操作，以及实现请求的排队和日志记录。 然而，使用命令模式可能会导致类的数量增加，增加系统的复杂性。 因此，在选择使用命令模式时，需要仔细权衡其优缺点。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 命令模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-解释器模式</title>
      <link href="/2025/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之解释器模式"><a href="#设计模式之解释器模式" class="headerlink" title="设计模式之解释器模式"></a>设计模式之解释器模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>解释器模式</strong> 是一种<strong>行为型设计模式</strong>，它用于定义语言的文法，并建立一个解释器来解释该文法定义的句子。 本质上，解释器模式用于构建语言解释器。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ul><li>当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树时，可以使用解释器模式。</li><li>该文法简单。 对于复杂的文法，文法的类层次变得庞大，难以管理。</li><li>效率不是关键问题。 解释器模式由于使用了大量的循环和递归，效率通常不高。 可以考虑使用其他的技术，如语法分析器或编译器。</li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>易于改变和扩展文法：</strong> 由于解释器模式使用类来表示文法规则，因此可以通过增加新的类来扩展文法。</li><li><strong>易于实现文法：</strong>  解释器模式将文法规则转换为类，使得实现文法变得更加容易。</li><li><strong>可将语法分析过程封装在独立的类中：</strong> 避免了语法分析与应用逻辑的耦合，提高了代码的可维护性。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>对于复杂的文法，文法的类层次变得庞大，难以管理。</strong> 这会导致类的数量急剧增加，增加系统的复杂性。</li><li><strong>效率较低：</strong> 解释器模式通常使用递归调用，效率较低。 对于需要高性能的场景，不适合使用解释器模式。</li><li><strong>调试复杂：</strong>  由于存在递归调用，调试起来比较困难。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>场景:</strong></p><p>假设你正在构建一个简单的数学表达式计算器。 你需要能够解析和计算包含加法和减法的表达式，例如 “1 + 2 - 3”。 使用解释器模式，你可以定义表达式的语法规则，并为每个语法规则创建一个解释器类。</p><p><strong>1. 表达式接口 (Expression Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式接口，定义了 evaluate 方法，用于计算表达式的值</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 终结符表达式 (Terminal Expression)</strong></p><p>终结符表达式代表了表达式中的最小单元，不能再被分解。 在这个例子中，数字就是终结符表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字表达式，实现了 Expression 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumberExpression</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 非终结符表达式 (Non-terminal Expression)</strong></p><p>非终结符表达式代表了表达式中的复杂部分，可以由其他表达式组成。 在这个例子中，加法表达式和减法表达式就是非终结符表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法表达式，实现了 Expression 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression leftExpression;</span><br><span class="line">    <span class="keyword">private</span> Expression rightExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(Expression leftExpression, Expression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftExpression = leftExpression;</span><br><span class="line">        <span class="built_in">this</span>.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftExpression.evaluate(context) + rightExpression.evaluate(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减法表达式，实现了 Expression 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubtractExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression leftExpression;</span><br><span class="line">    <span class="keyword">private</span> Expression rightExpression;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubtractExpression</span><span class="params">(Expression leftExpression, Expression rightExpression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftExpression = leftExpression;</span><br><span class="line">        <span class="built_in">this</span>.rightExpression = rightExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftExpression.evaluate(context) - rightExpression.evaluate(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 上下文 (Context)</strong></p><p>上下文用于存储表达式的全局信息，例如变量的值。 在这个简单的例子中，我们不需要上下文，但通常在更复杂的表达式中，上下文是必不可少的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文类，用于存储表达式的全局信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">// 在这个例子中，我们不需要上下文，所以这里留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterpreterPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建表达式 &quot;1 + 2 - 3&quot;</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubtractExpression</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AddExpression</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">1</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">2</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(<span class="number">3</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算表达式的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> expression.evaluate(context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;结果: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-关键点说明："><a href="#5-关键点说明：" class="headerlink" title="5. 关键点说明："></a>5. 关键点说明：</h4><ul><li><strong>抽象语法树：</strong>  解释器模式的核心是构建一个抽象语法树来表示要解释的句子。 在上面的例子中，客户端代码创建了一棵树，表示 “1 + 2 - 3” 这个表达式。</li><li><strong>递归调用：</strong> 解释器模式通常使用递归调用来解释抽象语法树。 <code>evaluate()</code> 方法会递归地调用其子节点的 <code>evaluate()</code> 方法，直到达到终结符表达式。</li><li><strong>上下文：</strong> 上下文对象用于存储解释器的全局状态。 虽然在简单的例子中可能不需要上下文，但在更复杂的场景中，上下文对于存储变量的值、函数定义等信息至关重要。</li></ul><h4 id="6-运行结果："><a href="#6-运行结果：" class="headerlink" title="6. 运行结果："></a>6. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果: 0</span><br></pre></td></tr></table></figure><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p><strong>解释器模式</strong> 适用于需要定义语言文法并解释执行的场景。 它通过将文法规则表示为类，并构建抽象语法树来实现。 然而，对于复杂的文法，解释器模式可能会导致类的数量急剧增加，效率也相对较低。 因此，在选择使用解释器模式时，需要仔细权衡其优缺点。 对于更复杂的语言，通常会选择使用语法分析器生成器 (例如 ANTLR) 等工具。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 解释器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-迭代子模式</title>
      <link href="/2025/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%AD%90%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%AD%90%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之迭代子模式"><a href="#设计模式之迭代子模式" class="headerlink" title="设计模式之迭代子模式"></a>设计模式之迭代子模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>迭代子模式</strong>是一种<strong>行为型设计模式</strong>，它提供一种方法顺序访问一个聚合对象（集合）中的各个元素，而又不暴露该对象的内部表示。  迭代子模式将集合的遍历行为抽象出来，封装到迭代器对象中，由迭代器负责完成集合的遍历。</p><h4 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. 适用场景</h4><ul><li><strong>访问一个聚合对象的内容而无需暴露它的内部表示：</strong> 客户端不需要知道集合内部是如何存储元素的，只需要通过迭代器提供的接口来访问集合中的元素。</li><li><strong>支持多种遍历方式：</strong>  可以为同一个集合创建不同的迭代器，以支持不同的遍历方式（例如，正序遍历、倒序遍历、跳跃遍历等）。</li><li><strong>为遍历不同的聚合结构提供一个统一的接口：</strong>  不同的集合可以实现相同的迭代器接口，客户端可以使用统一的方式来遍历不同的集合。</li></ul><h4 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3. 注意点"></a>3. 注意点</h4><ul><li><strong>简化了集合的访问方式：</strong> 客户端不需要知道集合的内部结构，只需要使用迭代器提供的接口来访问集合中的元素。</li><li><strong>支持多种遍历方式：</strong> 可以为同一个集合创建不同的迭代器，以支持不同的遍历方式。</li><li><strong>提高代码的可复用性：</strong>  迭代器可以被多个客户端复用。</li><li><strong>符合单一职责原则：</strong> 迭代器负责集合的遍历，集合负责存储元素，职责分离。</li><li><strong>符合开闭原则：</strong>  可以增加新的迭代器类，而不需要修改现有的集合类。</li><li><strong>可能存在并发问题：</strong>  在多线程环境下，需要考虑迭代器的线程安全问题。</li></ul><h4 id="4-代码示例"><a href="#4-代码示例" class="headerlink" title="4. 代码示例"></a>4. 代码示例</h4><p><strong>场景：</strong></p><p>假设你正在开发一个音乐播放器。 你需要能够遍历播放列表中的歌曲，并提供一种统一的方式来访问播放列表中的元素，而不需要暴露播放列表的内部实现细节。 使用迭代子模式，你可以创建一个迭代器对象，用于遍历播放列表中的歌曲。</p><p><strong>1. 迭代器接口 (Iterator Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器接口，定义了遍历集合的通用方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体迭代器 (Concrete Iterator)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体迭代器，用于遍历歌曲列表</span></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SongIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; songs;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SongIterator</span><span class="params">(List&lt;String&gt; songs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.songs = songs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; songs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> songs.get(position++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 集合接口 (Aggregate Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合接口，定义了创建迭代器的通用方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Playlist</span> &#123;</span><br><span class="line">    Iterator&lt;String&gt; <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体集合 (Concrete Aggregate)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体集合，表示歌曲播放列表</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SongPlaylist</span> <span class="keyword">implements</span> <span class="title class_">Playlist</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; songs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSong</span><span class="params">(String song)</span> &#123;</span><br><span class="line">        songs.add(song);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">createIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SongIterator</span>(songs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建播放列表</span></span><br><span class="line">        <span class="type">SongPlaylist</span> <span class="variable">playlist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SongPlaylist</span>();</span><br><span class="line">        playlist.addSong(<span class="string">&quot;歌曲1&quot;</span>);</span><br><span class="line">        playlist.addSong(<span class="string">&quot;歌曲2&quot;</span>);</span><br><span class="line">        playlist.addSong(<span class="string">&quot;歌曲 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = playlist.createIterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历播放列表</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">song</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;正在播放: &quot;</span> + song);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-关键点说明"><a href="#5-关键点说明" class="headerlink" title="5. 关键点说明"></a>5. 关键点说明</h4><ul><li><strong><code>Iterator</code> 接口：</strong> 定义了 <code>hasNext()</code> 和 <code>next()</code> 方法，表示遍历集合的通用方法。 这就是**迭代器接口 (Iterator Interface)**。</li><li><strong><code>SongIterator</code> 类：</strong> 实现了 <code>Iterator</code> 接口，用于遍历歌曲列表。 它包含一个 <code>songs</code> 字段，用于存储歌曲列表，以及一个 <code>position</code> 字段，用于记录当前遍历的位置。 这就是**具体迭代器 (Concrete Iterator)**。</li><li><strong><code>Playlist</code> 接口：</strong> 定义了 <code>createIterator()</code> 方法，表示创建迭代器的通用方法。 这就是**集合接口 (Aggregate Interface)**。</li><li><strong><code>SongPlaylist</code> 类：</strong> 实现了 <code>Playlist</code> 接口，表示歌曲播放列表。 它包含一个 <code>songs</code> 字段，用于存储歌曲。  <code>createIterator()</code> 方法用于创建 <code>SongIterator</code> 对象。 这就是**具体集合 (Concrete Aggregate)**。</li><li><strong><code>IteratorPatternDemo</code> 类：</strong> 客户端代码，演示了如何使用迭代子模式来遍历歌曲播放列表。</li></ul><h4 id="6-运行结果："><a href="#6-运行结果：" class="headerlink" title="6. 运行结果："></a>6. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正在播放: 歌曲1</span><br><span class="line">正在播放: 歌曲2</span><br><span class="line">正在播放: 歌曲 3</span><br></pre></td></tr></table></figure><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h4><p><strong>迭代子模式</strong> 提供了一种统一的方式来访问集合中的元素，而不需要暴露集合的内部实现细节。 适用于需要遍历集合中的元素，并且不希望暴露集合的内部结构时。可以将集合的遍历行为抽象出来，封装到迭代器对象中，由迭代器负责完成集合的遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 迭代子模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-享元模式</title>
      <link href="/2025/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之享元模式"><a href="#设计模式之享元模式" class="headerlink" title="设计模式之享元模式"></a>设计模式之享元模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>享元模式</strong> 是一种<strong>结构型设计模式</strong>，它通过共享细粒度的对象来有效地支持大量对象。 享元模式尝试重用现有对象，而不是创建新的对象。通过共享，享元模式可以减少内存使用，提高性能。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>减少对象数量：</strong> 通过共享对象来减少应用程序中的对象数量，从而减少内存占用。</li><li><strong>提高性能：</strong> 通过重用现有对象来避免创建新对象的开销，从而提高性能。</li><li><strong>分离内部状态和外部状态：</strong> 将对象的状态分为内部状态（可以共享）和外部状态（需要在使用时传入），从而使对象可以被共享。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>享元模式主要包含以下角色：</p><ul><li><strong>享元接口 (Flyweight)：</strong><ul><li>定义了享元对象需要实现的接口。</li><li>通常包含一个或多个方法，用于操作享元对象的外部状态。</li></ul></li><li><strong>具体享元 (Concrete Flyweight)：</strong><ul><li>实现了享元接口。</li><li>存储享元对象的内部状态。</li><li>是可共享的对象。</li></ul></li><li><strong>非共享具体享元 (Unshared Concrete Flyweight)：</strong> (可选)<ul><li>实现了享元接口。</li><li>存储享元对象的内部状态。</li><li><strong>不可共享</strong>的对象。</li></ul></li><li><strong>享元工厂 (Flyweight Factory)：</strong><ul><li>负责创建和管理享元对象。</li><li>维护一个享元池（例如，一个 Map），用于存储已经创建的享元对象。</li><li>当客户端请求一个享元对象时，工厂首先检查享元池中是否已经存在该对象。 如果存在，则直接返回该对象；否则，创建一个新的对象并将其添加到享元池中。</li></ul></li><li><strong>客户端 (Client)：</strong><ul><li>通过享元工厂来获取享元对象。</li><li>负责传递享元对象的外部状态。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>应用程序中使用大量的对象。</li><li>大量对象拥有相同的内部状态，可以将内部状态共享。</li><li>对象的外部状态可以与内部状态分离。</li><li>通过共享对象可以显著减少内存占用。</li></ul><h4 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>减少内存占用：</strong> 通过共享对象来减少应用程序中的对象数量，从而减少内存占用。</li><li><strong>提高性能：</strong> 通过重用现有对象来避免创建新对象的开销，从而提高性能。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>增加了系统的复杂性：</strong> 需要分离内部状态和外部状态，并创建享元工厂来管理享元对象，增加了系统的复杂性。</li><li><strong>读取享元状态的开销：</strong> 如果外部状态需要频繁地传递给享元对象，可能会导致额外的性能开销。</li><li><strong>线程安全问题：</strong>  需要考虑多线程环境下享元对象的线程安全问题。</li></ul><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><p><strong>场景：</strong><br>假设你正在开发一个文本编辑器。 在文本编辑器中，可能会有很多重复的字符，例如，字母 “a”、数字 “1” 等。 如果为每个字符都创建一个对象，会占用大量的内存。 使用享元模式，你可以将这些重复的字符对象共享，从而减少内存的占用。</p><p><strong>1. 享元接口 (Flyweight Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元接口，定义了字符的通用操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CharacterFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体享元 (Concrete Flyweight)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体享元，表示具体的字符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCharacter</span> <span class="keyword">implements</span> <span class="title class_">CharacterFlyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCharacter</span><span class="params">(<span class="type">char</span> character)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.character = character;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符: &quot;</span> + character + <span class="string">&quot; (位置: &quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 享元工厂 (Flyweight Factory)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂，用于创建和管理享元对象</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, CharacterFlyweight&gt; characterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CharacterFlyweight <span class="title function_">getCharacter</span><span class="params">(<span class="type">char</span> character)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!characterMap.containsKey(character)) &#123;</span><br><span class="line">            characterMap.put(character, <span class="keyword">new</span> <span class="title class_">ConcreteCharacter</span>(character));</span><br><span class="line">            System.out.println(<span class="string">&quot;创建字符: &quot;</span> + character);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> characterMap.get(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CharacterFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用享元对象</span></span><br><span class="line">        factory.getCharacter(<span class="string">&#x27;A&#x27;</span>).display(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        factory.getCharacter(<span class="string">&#x27;B&#x27;</span>).display(<span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">        factory.getCharacter(<span class="string">&#x27;A&#x27;</span>).display(<span class="number">50</span>, <span class="number">60</span>); <span class="comment">// 重复使用 &#x27;A&#x27;</span></span><br><span class="line">        factory.getCharacter(<span class="string">&#x27;C&#x27;</span>).display(<span class="number">70</span>, <span class="number">80</span>);</span><br><span class="line">        factory.getCharacter(<span class="string">&#x27;B&#x27;</span>).display(<span class="number">90</span>, <span class="number">100</span>); <span class="comment">// 重复使用 &#x27;B&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-关键点说明："><a href="#7-关键点说明：" class="headerlink" title="7. 关键点说明："></a>7. 关键点说明：</h4><ul><li><strong><code>CharacterFlyweight</code> 接口：</strong> 定义了 <code>display()</code> 方法，表示字符的通用操作。 这就是**享元接口 (Flyweight Interface)**。</li><li><strong><code>ConcreteCharacter</code> 类：</strong> 实现了 <code>CharacterFlyweight</code> 接口，表示具体的字符。 它包含一个 <code>character</code> 字段，用于存储字符的值。 这就是**具体享元 (Concrete Flyweight)**。</li><li><strong><code>CharacterFactory</code> 类：</strong> 用于创建和管理享元对象。 它维护一个 <code>characterMap</code>，用于存储已经创建的字符对象。 当客户端请求一个字符对象时，工厂首先检查 <code>characterMap</code> 中是否已经存在该对象。 如果存在，则直接返回该对象；否则，创建一个新的对象并将其添加到 <code>characterMap</code> 中。  这就是**享元工厂 (Flyweight Factory)**。</li><li><strong><code>FlyweightPatternDemo</code> 类：</strong> 客户端代码，演示了如何使用享元模式来共享字符对象。</li></ul><h4 id="8-运行结果："><a href="#8-运行结果：" class="headerlink" title="8. 运行结果："></a>8. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建字符: A</span><br><span class="line">字符: A (位置: 10, 20)</span><br><span class="line">创建字符: B</span><br><span class="line">字符: B (位置: 30, 40)</span><br><span class="line">字符: A (位置: 50, 60)</span><br><span class="line">创建字符: C</span><br><span class="line">字符: C (位置: 70, 80)</span><br><span class="line">字符: B (位置: 90, 100)</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p><strong>享元模式</strong> 通过共享细粒度的对象，从而减少内存的占用。 享元模式适用于当应用程序中存在大量的重复对象，并且这些对象的状态可以分离成内部状态和外部状态时。 内部状态可以被共享，而外部状态需要在每次使用对象时传入。 合理使用享元模式可以减少内存占用，提高应用程序的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 享元模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-组合模式</title>
      <link href="/2025/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之组合模式"><a href="#设计模式之组合模式" class="headerlink" title="设计模式之组合模式"></a>设计模式之组合模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>组合模式</strong> 是一种<strong>结构型设计模式</strong>，它允许你将对象组合成树形结构来表示”部分-整体”的层次结构。 组合模式使得客户端可以用相同的方式处理单个对象（叶子节点）和组合对象（容器节点）。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>表示对象的层次结构：</strong> 将对象组织成树形结构，表示”部分-整体”的关系。</li><li><strong>统一处理单个对象和组合对象：</strong> 客户端可以使用相同的方式处理叶子节点和容器节点，无需区分它们的类型。</li><li><strong>简化客户端代码：</strong> 客户端无需关心对象的内部结构，只需要调用统一的接口即可。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>组合模式主要包含以下角色：</p><ul><li><strong>组件 (Component)：</strong><ul><li>定义了组合中所有对象的通用接口。</li><li>可以是接口或抽象类。</li><li>声明了用于访问和管理子组件的方法（例如，<code>addComponent()</code>, <code>removeComponent()</code>, <code>getChild()</code>）。</li></ul></li><li><strong>叶子节点 (Leaf)：</strong><ul><li>表示组合中的叶子节点对象。</li><li>实现了组件接口。</li><li>不能包含子组件。</li></ul></li><li><strong>容器节点 (Composite)：</strong><ul><li>表示组合中的容器节点对象。</li><li>实现了组件接口。</li><li>可以包含子组件。</li><li>实现了用于管理子组件的方法。</li></ul></li><li><strong>客户端 (Client)：</strong><ul><li>通过组件接口来操作组合结构。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>需要表示对象的部分-整体层次结构。</li><li>希望客户端能够以一致的方式处理单个对象和组合对象。</li><li>希望在不修改客户端代码的情况下，动态地添加或删除组合中的组件。</li></ul><h4 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>清晰地定义了层次结构：</strong> 更容易理解系统的组织方式</li><li><strong>统一了对单个对象和组合对象的操作：</strong> 简化了客户端代码。</li><li><strong>扩展性好：</strong> 可以很容易地添加新的组件。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>设计可能过于抽象：</strong>  如果组件之间的关系过于复杂，可能会导致设计过于抽象，增加理解难度。</li><li><strong>难以限制组件的类型：</strong>  在某些情况下，可能需要限制容器节点中可以包含的组件类型，但组合模式本身并没有提供直接的机制来实现这种限制。需要额外的类型检查。</li></ul><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><p><strong>场景：</strong><br>假设你正在开发一个文件系统模拟器。 你需要表示文件和目录的结构，并且能够对文件和目录进行统一的操作，例如，计算大小、移动、删除等。 使用组合模式，你可以将文件和目录都看作是组件，并将它们组织成一个树形结构，从而可以对整个树形结构进行统一的操作。</p><p><strong>1. 组件接口 (Component Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件接口，定义了文件和目录的通用操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(FileSystemComponent component)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(FileSystemComponent component)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 叶子节点 (Leaf)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 叶子节点，表示文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">implements</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String name, <span class="type">long</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;文件不支持添加组件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;文件不支持移除组件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件: &quot;</span> + name + <span class="string">&quot; (大小: &quot;</span> + size + <span class="string">&quot; 字节)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 容器节点 (Composite)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器节点，表示目录</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">implements</span> <span class="title class_">FileSystemComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemComponent&gt; components;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Directory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.components = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemComponent component : components) &#123;</span><br><span class="line">            totalSize += component.getSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(FileSystemComponent component)</span> &#123;</span><br><span class="line">        components.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;目录: &quot;</span> + name + <span class="string">&quot; (大小: &quot;</span> + getSize() + <span class="string">&quot; 字节)&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (FileSystemComponent component : components) &#123;</span><br><span class="line">            component.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompositePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;文档1.txt&quot;</span>, <span class="number">1024</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;图片1.jpg&quot;</span>, <span class="number">2048</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;视频1.mp4&quot;</span>, <span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建目录</span></span><br><span class="line">        <span class="type">Directory</span> <span class="variable">directory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;我的文档&quot;</span>);</span><br><span class="line">        <span class="type">Directory</span> <span class="variable">directory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;我的图片&quot;</span>);</span><br><span class="line">        <span class="type">Directory</span> <span class="variable">rootDirectory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>(<span class="string">&quot;根目录&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加文件到目录</span></span><br><span class="line">        directory1.addComponent(file1);</span><br><span class="line">        directory1.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;报告.docx&quot;</span>, <span class="number">512</span>));</span><br><span class="line">        directory2.addComponent(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加目录到根目录</span></span><br><span class="line">        rootDirectory.addComponent(directory1);</span><br><span class="line">        rootDirectory.addComponent(directory2);</span><br><span class="line">        rootDirectory.addComponent(file3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示文件系统结构</span></span><br><span class="line">        rootDirectory.display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算根目录的大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n根目录总大小: &quot;</span> + rootDirectory.getSize() + <span class="string">&quot; 字节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-关键点说明："><a href="#7-关键点说明：" class="headerlink" title="7. 关键点说明："></a>7. 关键点说明：</h4><ul><li><strong><code>FileSystemComponent</code> 接口：</strong> 定义了 <code>getName()</code>, <code>getSize()</code>, <code>addComponent()</code>, <code>removeComponent()</code>, <code>display()</code> 方法，表示文件和目录的通用操作。 这就是**组件接口 (Component Interface)**。</li><li><strong><code>File</code> 类：</strong> 实现了 <code>FileSystemComponent</code> 接口，表示文件。 <code>addComponent()</code> 和 <code>removeComponent()</code> 方法抛出 <code>UnsupportedOperationException</code> 异常，因为文件不能包含其他组件。  这就是**叶子节点 (Leaf)**。</li><li><strong><code>Directory</code> 类：</strong> 实现了 <code>FileSystemComponent</code> 接口，表示目录。  它维护一个 <code>components</code> 列表，用于存储目录中的文件和子目录。  <code>addComponent()</code> 和 <code>removeComponent()</code> 方法用于添加和删除目录中的组件。 这就是**容器节点 (Composite)**。</li><li><strong><code>CompositePatternDemo</code> 类：</strong> 客户端代码，演示了如何创建文件和目录对象，并将它们组织成一个树形结构，以及如何使用组合模式来显示文件系统结构和计算目录大小。</li></ul><h4 id="8-运行结果："><a href="#8-运行结果：" class="headerlink" title="8. 运行结果："></a>8. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目录: 根目录 (大小: 8602 字节)</span><br><span class="line">目录: 我的文档 (大小: 1536 字节)</span><br><span class="line">文件: 文档1.txt (大小: 1024 字节)</span><br><span class="line">文件: 报告.docx (大小: 512 字节)</span><br><span class="line">目录: 我的图片 (大小: 2048 字节)</span><br><span class="line">文件: 图片1.jpg (大小: 2048 字节)</span><br><span class="line">文件: 视频1.mp4 (大小: 4096 字节)</span><br><span class="line"></span><br><span class="line">根目录总大小: 8602 字节</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p><strong>组合模式</strong> 通过将对象组织成树形结构，并能够对整个树形结构进行统一的操作，实现了对部分-整体层次结构的表示。 组合模式适用于当你需要表示对象的部分-整体层次结构，并且希望客户端能够以一致的方式处理单个对象和组合对象时。 合理使用组合模式可以简化客户端代码，提高系统的可维护性和可扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-责任链模式</title>
      <link href="/2025/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之责任链模式"><a href="#设计模式之责任链模式" class="headerlink" title="设计模式之责任链模式"></a>设计模式之责任链模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>责任链模式</strong> 是一种<strong>行为型设计模式</strong>，它允许将请求沿着处理者链进行发送。 收到请求后，每个处理者可以决定处理该请求，或者将其传递给链中的下一个处理者。  它避免将请求的发送者与接收者耦合在一起，让多个对象都有机会处理这个请求。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>解耦请求的发送者和接收者：</strong>  发送者不需要知道哪个对象会处理请求。</li><li><strong>动态处理请求：</strong>  可以在运行时动态地添加、删除或修改处理者。</li><li><strong>简化对象：</strong>  将处理请求的责任分配给多个对象，简化了每个对象的职责。</li><li><strong>增加灵活性：</strong>  可以灵活地调整处理请求的顺序。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>责任链模式主要包含以下角色：</p><ul><li><strong>抽象处理者 (Handler)：</strong><ul><li>定义一个处理请求的接口。</li><li>维护一个指向下一个处理者的引用（可选）。</li></ul></li><li><strong>具体处理者 (Concrete Handler)：</strong><ul><li>实现抽象处理者定义的接口。</li><li>决定是否处理请求，如果可以处理，则处理请求；否则，将请求传递给下一个处理者。</li></ul></li><li><strong>客户端 (Client)：</strong><ul><li>创建处理链，并将请求发送给链中的第一个处理者。</li></ul></li><li><strong>请求 (Request):</strong><ul><li>表示需要被处理的请求对象。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>有多个对象可以处理一个请求，但具体由哪个对象处理该请求需要在运行时决定。</li><li>需要在不明确指定请求处理者的情况下，向多个对象中的一个提交请求。</li><li>需要动态指定一组对象处理请求。</li></ul><h4 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a>5. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>降低耦合度：</strong>  解耦了请求的发送者和接收者。</li><li><strong>灵活性：</strong>  可以动态地添加、删除或修改处理者。</li><li><strong>可扩展性：</strong>  可以很容易地添加新的处理者。</li><li><strong>单一职责原则：</strong> 每个处理者只负责处理自己的职责范围内的请求。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>不能保证请求一定被处理：</strong>  如果链中的所有处理者都不能处理该请求，则请求将被丢弃。</li><li><strong>性能问题：</strong>  如果链太长，可能会影响性能。</li><li><strong>调试困难：</strong>  由于请求在链中传递，调试可能会比较困难。</li></ul><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><p><strong>场景：</strong><br>假设你正在开发一个客户服务系统。 当客户提出请求时，需要经过一系列的处理步骤，例如，检查请求类型、验证身份、查询数据库、生成响应等。 不同的请求可能需要经过不同的处理步骤。 使用责任链模式，你可以将这些处理步骤组织成一个链，并将客户请求传递给链中的第一个处理器，由链中的处理器依次处理请求，直到请求被处理完毕。</p><p><strong>1. 抽象处理者 (Handler)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象处理者，定义了处理请求的接口和指向下一个处理者的指针</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">null</span>); <span class="comment">// 允许没有后续处理者的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求传递给下一个处理者</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">passToNext</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            nextHandler.handleRequest(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求已处理完毕，无后续处理者。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体处理者 (Concrete Handler)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体处理者，实现了处理请求的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypeCheckHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TypeCheckHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nextHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TypeCheckHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType().equals(<span class="string">&quot;TypeA&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TypeCheckHandler: 处理 TypeA 请求。&quot;</span>);</span><br><span class="line">            request.setProcessed(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passToNext(request); <span class="comment">// 传递给下一个处理者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuthenticationHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthenticationHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nextHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthenticationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.isAuthenticated()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;AuthenticationHandler: 用户已通过身份验证。&quot;</span>);</span><br><span class="line">            request.setProcessed(<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;AuthenticationHandler: 用户身份验证失败，拒绝请求。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 停止传递</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passToNext(request); <span class="comment">// 传递给下一个处理者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseQueryHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseQueryHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nextHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseQueryHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.isProcessed()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;DatabaseQueryHandler: 查询数据库，获取相关信息。&quot;</span>);</span><br><span class="line">            request.setProcessed(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passToNext(request); <span class="comment">// 传递给下一个处理者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ResponseGenerationHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseGenerationHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(nextHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ResponseGenerationHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.isProcessed()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ResponseGenerationHandler: 生成响应。&quot;</span>);</span><br><span class="line">            request.setProcessed(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        passToNext(request); <span class="comment">// 传递给下一个处理者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 请求类 (Request)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求类，封装了请求的信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> authenticated;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> processed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(String type, <span class="type">boolean</span> authenticated)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.authenticated = authenticated;</span><br><span class="line">        <span class="built_in">this</span>.processed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authenticated;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isProcessed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProcessed</span><span class="params">(<span class="type">boolean</span> processed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.processed = processed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainOfResponsibilityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建处理链</span></span><br><span class="line">        <span class="type">TypeCheckHandler</span> <span class="variable">typeCheckHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeCheckHandler</span>();</span><br><span class="line">        <span class="type">AuthenticationHandler</span> <span class="variable">authenticationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthenticationHandler</span>();</span><br><span class="line">        <span class="type">DatabaseQueryHandler</span> <span class="variable">databaseQueryHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatabaseQueryHandler</span>();</span><br><span class="line">        <span class="type">ResponseGenerationHandler</span> <span class="variable">responseGenerationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseGenerationHandler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置责任链顺序</span></span><br><span class="line">        typeCheckHandler.setNextHandler(authenticationHandler);</span><br><span class="line">        authenticationHandler.setNextHandler(databaseQueryHandler);</span><br><span class="line">        databaseQueryHandler.setNextHandler(responseGenerationHandler);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//创建请求</span></span><br><span class="line">        <span class="type">Request</span> <span class="variable">request1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;TypeA&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;TypeB&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理请求 1:&quot;</span>);</span><br><span class="line">        typeCheckHandler.handleRequest(request1); <span class="comment">// 从类型检查开始</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n处理请求 2:&quot;</span>);</span><br><span class="line">        typeCheckHandler.handleRequest(request2); <span class="comment">// 从类型检查开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-关键点说明："><a href="#7-关键点说明：" class="headerlink" title="7. 关键点说明："></a>7. 关键点说明：</h4><ul><li><strong><code>Handler</code> 抽象类：</strong> 定义了 <code>handleRequest()</code> 方法，表示处理请求的接口，以及 <code>passToNext()</code> 方法，用于将请求传递给下一个处理者。  这就是**抽象处理者 (Handler)**。 重要的是，添加了<code>setNextHandler</code>方法和无参数的构造函数，使得责任链的构建更加灵活.</li><li><strong><code>TypeCheckHandler</code>, <code>AuthenticationHandler</code>, <code>DatabaseQueryHandler</code>, <code>ResponseGenerationHandler</code> 类：</strong> 实现了 <code>Handler</code> 抽象类，表示具体的处理者。 每个类中的 <code>handleRequest()</code> 方法实现了具体的处理逻辑，并根据情况决定是否将请求传递给下一个处理者。 这就是**具体处理者 (Concrete Handler)**。</li><li><strong><code>Request</code> 类：</strong> 封装了请求的信息，例如请求类型、身份验证状态等。</li><li><strong><code>ChainOfResponsibilityDemo</code> 类：</strong> 客户端代码，演示了如何创建处理链和请求对象，以及如何使用责任链模式来处理请求。 链的建立现在更加灵活。</li></ul><h4 id="8-运行结果："><a href="#8-运行结果：" class="headerlink" title="8. 运行结果："></a>8. 运行结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">处理请求 1:</span><br><span class="line">TypeCheckHandler: 处理 TypeA 请求。</span><br><span class="line">AuthenticationHandler: 用户已通过身份验证。</span><br><span class="line">DatabaseQueryHandler: 查询数据库，获取相关信息。</span><br><span class="line">ResponseGenerationHandler: 生成响应。</span><br><span class="line">请求已处理完毕，无后续处理者。</span><br><span class="line"></span><br><span class="line">处理请求 2:</span><br><span class="line">TypeCheckHandler: 处理 TypeA 请求。</span><br><span class="line">AuthenticationHandler: 用户身份验证失败，拒绝请求。</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p><strong>责任链模式</strong> 通过将请求的处理过程分解成一系列的处理步骤，并将这些步骤组织成一个链，实现了请求发送者和接收者的解耦。 责任链模式适用于当一个请求需要经过多个处理步骤，并且这些处理步骤的顺序可以动态变化时。  通过合理使用责任链模式，可以提高系统的灵活性、可维护性和可扩展性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2025/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之桥接模式"><a href="#设计模式之桥接模式" class="headerlink" title="设计模式之桥接模式"></a>设计模式之桥接模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>桥接模式</strong> 是一种<strong>结构型设计模式</strong>，它将<strong>抽象部分</strong>与其<strong>实现部分</strong>分离，使它们都可以独立地变化。 桥接模式使用封装、组合以及继承等行为来让不同的类承担不同的责任。 这样做的好处是可以将抽象部分和实现部分隔离开来，从而更容易独立地改变它们。</p><h4 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h4><p>桥接模式主要包含以下角色：</p><ul><li><strong>抽象类 (Abstraction)：</strong><ul><li>定义抽象类的接口，维护一个指向实现类接口对象的指针。</li></ul></li><li><strong>扩展抽象类 (Refined Abstraction)：</strong><ul><li>扩展抽象类的接口，实现抽象类定义的部分或全部方法。</li></ul></li><li><strong>实现类接口 (Implementor)：</strong><ul><li>定义实现类的接口，该接口不一定要与抽象类的接口完全一致，实际上通常可以提供更为基本的操作，而抽象类则在这些基本操作的基础上构建更高层次的接口。</li></ul></li><li><strong>具体实现类 (Concrete Implementor)：</strong><ul><li>实现实现类接口，提供具体的实现。</li></ul></li></ul><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>解耦抽象和实现：</strong> 将抽象和实现分离，提高了系统的灵活性和可维护性。</li><li><strong>可扩展性：</strong> 可以很容易地添加新的抽象类和新的实现类。</li><li><strong>隐藏实现细节：</strong> 客户端不需要关心具体的实现细节，只需要关心抽象接口。</li><li><strong>避免类爆炸：</strong> 避免了继承导致的类爆炸问题。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>增加了系统的复杂性：</strong> 桥接模式引入了更多的类和接口，增加了系统的复杂性。</li><li><strong>需要正确识别抽象和实现：</strong> 需要仔细分析系统，正确识别抽象和实现，才能应用桥接模式。</li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当一个类存在两个或多个独立变化的维度时。</li><li>当抽象部分和实现部分需要独立扩展时。</li><li>当不希望使用继承的方式来避免类爆炸时。</li><li>需要在多个对象间共享实现时。</li></ul><h4 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h4><p><strong>场景：</strong><br>假设你正在开发一个绘图系统。 你有不同形状（例如，圆形、矩形），并且你希望能够在不同的绘图 API（例如，使用 OpenGL、DirectX）上绘制这些形状。 使用桥接模式，你可以将形状的抽象与其具体的绘图实现解耦，使得它们可以独立变化。</p><p><strong>1. 形状抽象接口 (Abstraction Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形状抽象接口，定义了形状的基本行为</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 扩展抽象类 (Refined Abstraction)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展抽象类，继承自 Shape 接口，并添加了额外的行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y, radius;</span><br><span class="line">    <span class="keyword">private</span> DrawingAPI drawingAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius, DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        <span class="built_in">this</span>.drawingAPI = drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawingAPI.drawCircle(x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y, width, height;</span><br><span class="line">    <span class="keyword">private</span> DrawingAPI drawingAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height, DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.drawingAPI = drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawingAPI.drawRectangle(x, y, width, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 绘图 API 接口 (Implementor Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘图 API 接口，定义了绘图的基本操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体绘图 API 实现 (Concrete Implementor)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体绘图 API 实现，实现了 DrawingAPI 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLDrawingAPI</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 OpenGL 绘制圆形，坐标: (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)，半径: &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 OpenGL 绘制矩形，坐标: (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)，宽度: &quot;</span> + width + <span class="string">&quot;，高度: &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectXDrawingAPI</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 DirectX 绘制圆形，坐标: (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)，半径: &quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 DirectX 绘制矩形，坐标: (&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;)，宽度: &quot;</span> + width + <span class="string">&quot;，高度: &quot;</span> + height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BridgePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建绘图 API 实现</span></span><br><span class="line">        <span class="type">DrawingAPI</span> <span class="variable">openGLDrawingAPI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenGLDrawingAPI</span>();</span><br><span class="line">        <span class="type">DrawingAPI</span> <span class="variable">directXDrawingAPI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectXDrawingAPI</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建形状对象，并指定绘图 API</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, openGLDrawingAPI);</span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">rectangle1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">80</span>, <span class="number">60</span>, directXDrawingAPI);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制形状</span></span><br><span class="line">        circle1.draw();</span><br><span class="line">        rectangle1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建不同 API 的形状</span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">150</span>, <span class="number">150</span>, <span class="number">75</span>, directXDrawingAPI);</span><br><span class="line">        circle2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-关键点说明"><a href="#6-关键点说明" class="headerlink" title="6. 关键点说明"></a>6. 关键点说明</h4><ul><li><strong><code>Shape</code> 接口：</strong> 定义了 <code>draw()</code> 方法，表示形状的基本行为。 这就是<strong>抽象接口 (Abstraction Interface)</strong>.</li><li><strong><code>Circle</code> 和 <code>Rectangle</code> 类：</strong> 实现了 <code>Shape</code> 接口，表示具体的形状。 它们持有一个 <code>DrawingAPI</code> 对象的引用，并将 <code>draw()</code> 方法的实现委托给 <code>DrawingAPI</code>。 这就是<strong>扩展抽象类 (Refined Abstraction)</strong>.</li><li><strong><code>DrawingAPI</code> 接口：</strong> 定义了 <code>drawCircle()</code> 和 <code>drawRectangle()</code> 方法，表示绘图的基本操作。 这就是<strong>实现接口 (Implementor Interface)</strong>.</li><li><strong><code>OpenGLDrawingAPI</code> 和 <code>DirectXDrawingAPI</code> 类：</strong> 实现了 <code>DrawingAPI</code> 接口，表示具体的绘图 API 实现。 这就是<strong>具体实现 (Concrete Implementor)</strong>.</li><li><strong><code>BridgePatternDemo</code> 类：</strong> 客户端代码，演示了如何创建形状对象和绘图 API 实现，以及如何使用桥接模式来绘制形状。</li></ul><h4 id="7-运行结果"><a href="#7-运行结果" class="headerlink" title="7. 运行结果"></a>7. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 OpenGL 绘制圆形，坐标: (100, 100)，半径: 50</span><br><span class="line">使用 DirectX 绘制矩形，坐标: (200, 200)，宽度: 80，高度: 60</span><br><span class="line">使用 DirectX 绘制圆形，坐标: (150, 150)，半径: 75</span><br></pre></td></tr></table></figure><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p><strong>桥接模式</strong> 通过将抽象部分和实现部分分离，使得它们可以独立地变化，提高了系统的灵活性和可维护性。 桥接模式适用于当一个类存在两个或多个独立变化的维度，并且需要避免类爆炸的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-访问者模式</title>
      <link href="/2025/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之访问者模式"><a href="#设计模式之访问者模式" class="headerlink" title="设计模式之访问者模式"></a>设计模式之访问者模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>访问者模式</strong> 是一种<strong>行为型设计模式</strong>，它允许在<strong>不改变</strong>对象结构的前提下，定义作用于这些对象结构中各个元素的新操作。其核心思想是将<strong>数据结构</strong>和<strong>作用于结构上的操作</strong>解耦，使得操作集合可以相对自由地演化。 访问者模式适用于当一个对象结构包含很多类对象，而你又想对这些对象实施一些依赖于其具体类的操作时。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>解耦数据结构和操作：</strong> 将作用于对象结构上的操作从对象自身中分离出来，使得操作可以独立变化。</li><li><strong>增加新的操作：</strong> 允许在不修改对象结构的前提下，增加新的操作。</li><li><strong>操作的集中化：</strong> 将相关的操作集中到一个访问者类中，便于管理和维护。</li><li><strong>支持多态访问：</strong> 可以根据不同的对象类型，执行不同的操作。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>访问者模式主要包含以下角色：</p><ul><li><strong>访问者 (Visitor)：</strong><ul><li>声明一个访问操作接口，该接口为对象结构中每一个 ConcreteElement 都有一个 visit() 方法。</li></ul></li><li><strong>具体访问者 (ConcreteVisitor)：</strong><ul><li>实现 Visitor 声明的接口，也就是实际对 ConcreteElement 进行操作的类。</li></ul></li><li><strong>元素 (Element)：</strong><ul><li>定义一个 accept() 方法，接受一个访问者对象作为参数。</li></ul></li><li><strong>具体元素 (ConcreteElement)：</strong><ul><li>实现 Element 接口，代表被访问的具体对象。</li><li>通常在 accept() 方法中调用访问者的 visit() 方法，将自身引用作为参数传递给访问者。</li></ul></li><li><strong>对象结构 (Object Structure)：</strong><ul><li>是一个包含元素的集合，提供一个高层接口，允许访问者访问它的元素。</li><li>可以是一个列表、一个树或其他任何复杂的结构。</li></ul></li></ul><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>符合单一职责原则：</strong> 将与对象结构相关的访问行为集中到了访问者类中，符合单一职责原则。</li><li><strong>扩展性良好：</strong> 可以很容易地添加新的访问者，从而扩展新的操作。</li><li><strong>对象结构稳定时适用：</strong> 当对象结构不经常变化时，访问者模式可以很好地将操作从对象结构中分离出来。</li><li><strong>便于算法复用：</strong> 可以将相同的算法应用于不同的对象结构。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>对象结构变化时维护困难：</strong> 如果对象结构发生变化，例如增加或删除元素，则需要修改所有访问者类，维护成本较高。</li><li><strong>破坏封装性：</strong> 访问者需要访问元素的内部状态，可能会破坏元素的封装性。</li><li><strong>具体元素对访问者依赖性强：</strong> 具体元素必须提供 <code>accept</code> 方法来接受访问者，增加了元素对访问者的依赖性。</li></ul><h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><ul><li>一个对象结构包含很多类对象，而你又想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。</li><li>当对象结构很少改变，但经常需要在此结构上定义新的操作时。</li></ul><h4 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. 示例代码</h4><p><strong>场景：</strong></p><p>假设你正在开发一个动物园管理系统。 你有不同种类的动物（例如，狮子、猴子、海豚），并且你想要对这些动物执行不同的操作（例如，喂食、玩耍、检查健康状况）。 使用访问者模式，你可以在不修改动物类的前提下，动态地添加这些操作。</p><p><strong>1. 动物接口 (Element Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物接口，定义了接受访问者的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(AnimalVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体动物类 (Concrete Element)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体动物类，实现了 Animal 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(AnimalVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>); <span class="comment">// 接受访问者，并将自身作为参数传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狮子咆哮！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(AnimalVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>); <span class="comment">// 接受访问者，并将自身作为参数传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">climb</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猴子爬树！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dolphin</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(AnimalVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.visit(<span class="built_in">this</span>); <span class="comment">// 接受访问者，并将自身作为参数传递</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;海豚游泳！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 动物访问者接口 (Visitor Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物访问者接口，定义了访问不同种类动物的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnimalVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Lion lion)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monkey monkey)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dolphin dolphin)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体动物访问者类 (Concrete Visitor)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体动物访问者类，实现了 AnimalVisitor 接口，定义了具体的访问行为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FeedVisitor</span> <span class="keyword">implements</span> <span class="title class_">AnimalVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Lion lion)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喂狮子吃肉！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monkey monkey)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喂猴子吃香蕉！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dolphin dolphin)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喂海豚吃鱼！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayVisitor</span> <span class="keyword">implements</span> <span class="title class_">AnimalVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Lion lion)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;和狮子玩耍（小心点！）&quot;</span>);</span><br><span class="line">        lion.roar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monkey monkey)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;和猴子玩耍，给它挠痒痒！&quot;</span>);</span><br><span class="line">        monkey.climb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dolphin dolphin)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;和海豚玩耍，一起跳跃！&quot;</span>);</span><br><span class="line">        dolphin.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCheckVisitor</span> <span class="keyword">implements</span> <span class="title class_">AnimalVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Lion lion)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查狮子的健康状况...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Monkey monkey)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查猴子的健康状况...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(Dolphin dolphin)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;检查海豚的健康状况...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 对象结构 (Object Structure)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animals.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animals.remove(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(AnimalVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">            animal.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动物对象</span></span><br><span class="line">        <span class="type">Lion</span> <span class="variable">lion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lion</span>();</span><br><span class="line">        <span class="type">Monkey</span> <span class="variable">monkey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monkey</span>();</span><br><span class="line">        <span class="type">Dolphin</span> <span class="variable">dolphin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dolphin</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动物园</span></span><br><span class="line">        <span class="type">Zoo</span> <span class="variable">zoo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zoo</span>();</span><br><span class="line">        zoo.addAnimal(lion);</span><br><span class="line">        zoo.addAnimal(monkey);</span><br><span class="line">        zoo.addAnimal(dolphin);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建访问者对象</span></span><br><span class="line">        <span class="type">FeedVisitor</span> <span class="variable">feedVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FeedVisitor</span>();</span><br><span class="line">        <span class="type">PlayVisitor</span> <span class="variable">playVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlayVisitor</span>();</span><br><span class="line">        <span class="type">HealthCheckVisitor</span> <span class="variable">healthCheckVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HealthCheckVisitor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让动物园接受访问者</span></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 喂食 ---&quot;</span>);</span><br><span class="line">        zoo.accept(feedVisitor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 玩耍 ---&quot;</span>);</span><br><span class="line">        zoo.accept(playVisitor);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--- 健康检查 ---&quot;</span>);</span><br><span class="line">        zoo.accept(healthCheckVisitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-关键点说明"><a href="#7-关键点说明" class="headerlink" title="7. 关键点说明"></a>7. 关键点说明</h4><ul><li><strong><code>Animal</code> 接口：</strong> 定义了 <code>accept()</code> 方法，用于接受访问者。 这就是<strong>元素 (Element)</strong> 接口.</li><li><strong><code>Lion</code>, <code>Monkey</code>, <code>Dolphin</code> 类：</strong> 实现了 <code>Animal</code> 接口，表示具体的动物种类。 每个类中的 <code>accept()</code> 方法调用访问者的 <code>visit()</code> 方法，并将自身作为参数传递。 这就是<strong>具体元素 (Concrete Element)</strong>.</li><li><strong><code>AnimalVisitor</code> 接口：</strong> 定义了 <code>visit()</code> 方法，用于访问不同种类的动物。 这就是<strong>访问者 (Visitor)</strong> 接口.</li><li><strong><code>FeedVisitor</code>, <code>PlayVisitor</code>, <code>HealthCheckVisitor</code> 类：</strong> 实现了 <code>AnimalVisitor</code> 接口，定义了具体的访问行为。  每个类中的 <code>visit()</code> 方法实现了对特定动物的访问操作。 这就是<strong>具体访问者 (Concrete Visitor)</strong>.</li><li><strong><code>Zoo</code> 类：</strong>  维护了一个 <code>Animal</code> 列表，并提供 <code>accept</code> 方法来接受访问者，并让访问者访问每一个动物. 这就是<strong>对象结构 (Object Structure)</strong>.</li><li><strong><code>VisitorPatternDemo</code> 类：</strong> 客户端代码，演示了如何创建动物对象和访问者对象，以及如何使用访问者来执行不同的操作。</li></ul><h4 id="8-运行结果"><a href="#8-运行结果" class="headerlink" title="8. 运行结果"></a>8. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- 喂食 ---</span><br><span class="line">喂狮子吃肉！</span><br><span class="line">喂猴子吃香蕉！</span><br><span class="line">喂海豚吃鱼！</span><br><span class="line">--- 玩耍 ---</span><br><span class="line">和狮子玩耍（小心点！）</span><br><span class="line">狮子咆哮！</span><br><span class="line">和猴子玩耍，给它挠痒痒！</span><br><span class="line">猴子爬树！</span><br><span class="line">和海豚玩耍，一起跳跃！</span><br><span class="line">海豚游泳！</span><br><span class="line">--- 健康检查 ---</span><br><span class="line">检查狮子的健康状况...</span><br><span class="line">检查猴子的健康状况...</span><br><span class="line">检查海豚的健康状况...</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>访问者模式通过分离对象结构和操作，提供了灵活的操作扩展机制。 当对象结构稳定且需要定义多种操作时，访问者模式是一种有效的解决方案。 但需要注意的是，如果对象结构频繁变化，维护访问者类的成本也会相应增加。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰器模式</title>
      <link href="/2025/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之装饰器模式"><a href="#设计模式之装饰器模式" class="headerlink" title="设计模式之装饰器模式"></a>设计模式之装饰器模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>装饰器模式</strong>是一种<strong>结构型设计模式</strong>，它允许在<strong>不改变</strong>现有对象结构的前提下，<strong>动态地</strong>给对象添加额外的职责。 这种模式创建了一个装饰器类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供额外的功能。 装饰器模式利用<strong>组合</strong>而非继承的方式， 具有比继承更加灵活性的特点，可以有效地避免类爆炸的问题。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>动态扩展功能：</strong> 在运行时动态地给对象增加额外的职责。</li><li><strong>避免继承的复杂性：</strong> 需要给一个现有的类增加职责，但是又不想通过继承的方式来实现的时候（应该优先使用组合而非继承），或者通过继承的方式不现实的时候（可能由于排列组合产生类爆炸的问题）。</li><li><strong>保持接口一致性：</strong>  确保装饰后的对象和原始对象具有相同的接口，客户端可以以一致的方式对待它们。</li><li><strong>灵活组合：</strong>  允许以不同的顺序和组合方式应用多个装饰器。</li></ul><h4 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h4><ul><li>需要在运行时动态地给对象增加额外的职责，而不能通过继承来实现。</li><li>需要给一个类增加的职责有很多，而且这些职责是可以动态组合的。</li><li>需要避免因为职责的增加而导致类的数量剧增（“类爆炸”）。</li><li>当不能使用继承的时候，使用装饰模式。</li></ul><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>灵活性：</strong> 可以在运行时动态地添加或删除职责，而无需修改原始类。</li><li><strong>扩展性：</strong> 可以很容易地添加新的装饰器，扩展对象的功能。</li><li><strong>避免继承：</strong> 通过组合而非继承的方式扩展功能，避免了继承带来的类爆炸问题。</li><li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性增加：</strong>  使用装饰器模式可能会导致类的数量增加，使得系统更加复杂。</li><li><strong>调试困难：</strong>  由于使用了多层包装，可能会增加调试的难度。</li><li><strong>装饰器的顺序很重要：</strong>  不同的装饰器顺序可能会导致不同的结果。</li><li><strong>可能产生大量细小对象：</strong> 过度使用装饰器可能会导致系统中存在大量细小对象，影响性能。</li></ul><h4 id="5-模式结构"><a href="#5-模式结构" class="headerlink" title="5. 模式结构"></a>5. 模式结构</h4><p>装饰器模式主要包含以下角色：</p><ul><li><strong>组件 (Component)：</strong><ul><li>定义一个对象接口，可以给这些对象动态地添加职责。</li></ul></li><li><strong>具体组件 (Concrete Component)：</strong><ul><li>实现组件接口。</li><li>定义了具体的对象，也就是被装饰器装饰的对象。</li></ul></li><li><strong>装饰器 (Decorator)：</strong><ul><li>持有一个组件对象的实例，并定义一个与组件接口一致的接口。</li><li>负责给组件添加额外的职责。</li></ul></li><li><strong>具体装饰器 (Concrete Decorator)：</strong><ul><li>实现装饰器接口，负责给组件添加具体的职责。</li></ul></li></ul><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><p><strong>场景：</strong><br>假设你正在开发一个咖啡店的订单系统。 你有不同种类的咖啡（例如，浓缩咖啡、美式咖啡），并且你想要允许顾客添加各种调料（例如，牛奶、摩卡、奶油）来定制他们的咖啡。 使用装饰器模式，你可以在运行时动态地组合这些调料，而无需修改咖啡类的代码。</p><p><strong>1. 咖啡接口 (Component Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 咖啡接口，定义了咖啡的基本行为（描述和价格）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体咖啡类 (Concrete Component)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体咖啡类，实现了 Coffee 接口，表示具体的咖啡种类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;浓缩咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.49</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 调料装饰器抽象类 (Decorator Abstract Class)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料装饰器抽象类，实现了 Coffee 接口，并持有一个 Coffee 对象的引用</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Coffee coffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription(); <span class="comment">// 默认行为：委托给被装饰的咖啡对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost(); <span class="comment">// 默认行为：委托给被装饰的咖啡对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体调料装饰器类 (Concrete Decorator)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体调料装饰器类，继承了 CoffeeDecorator 类，并添加了额外的行为（描述和价格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 牛奶&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">0.50</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mocha</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mocha</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 摩卡&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">0.75</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whip</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Whip</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 奶油&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">1.00</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一杯浓缩咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">espresso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(espresso.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + espresso.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用牛奶和摩卡装饰浓缩咖啡</span></span><br><span class="line">        espresso = <span class="keyword">new</span> <span class="title class_">Milk</span>(espresso);</span><br><span class="line">        espresso = <span class="keyword">new</span> <span class="title class_">Mocha</span>(espresso);</span><br><span class="line">        System.out.println(espresso.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + espresso.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一杯美式咖啡，并用奶油装饰</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">americano</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">        americano = <span class="keyword">new</span> <span class="title class_">Whip</span>(americano);</span><br><span class="line">        System.out.println(americano.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + americano.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-关键点说明"><a href="#7-关键点说明" class="headerlink" title="7. 关键点说明"></a>7. 关键点说明</h4><ul><li><strong><code>Coffee</code> 接口：</strong> 定义了 <code>getDescription()</code> 和 <code>getCost()</code> 方法，表示咖啡的基本行为。 这就是<strong>组件 (Component)</strong>.</li><li><strong><code>Espresso</code> 和 <code>Americano</code> 类：</strong> 实现了 <code>Coffee</code> 接口，表示具体的咖啡种类. 这就是<strong>具体组件 (Concrete Component)</strong>.</li><li><strong><code>CoffeeDecorator</code> 抽象类：</strong> 实现了 <code>Coffee</code> 接口，并持有一个 <code>Coffee</code> 对象的引用。 它是所有调料装饰器的基类。 这就是<strong>装饰器 (Decorator)</strong>.</li><li><strong><code>Milk</code>, <code>Mocha</code>, <code>Whip</code> 类：</strong> 继承了 <code>CoffeeDecorator</code> 类，并添加了额外的行为（描述和价格），表示具体的调料. 这就是<strong>具体装饰器 (Concrete Decorator)</strong>.</li><li><strong><code>DecoratorPatternDemo</code> 类：</strong> 客户端代码，演示了如何创建咖啡对象，并使用调料装饰器动态地组合调料。</li></ul><h4 id="8-运行结果"><a href="#8-运行结果" class="headerlink" title="8. 运行结果"></a>8. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浓缩咖啡 价格: $1.99</span><br><span class="line">浓缩咖啡, 牛奶, 摩卡 价格: $3.24</span><br><span class="line">美式咖啡, 奶油 价格: $3.49</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>装饰器模式是一种强大的设计模式，它允许你在运行时动态地扩展对象的功能，而无需修改对象的代码。 它通过组合而非继承的方式，提供了比继承更加灵活的扩展方式，并且符合开闭原则。 在实际应用中，需要注意装饰器的顺序，以及避免过度使用装饰器导致系统复杂性增加。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 装饰器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2025/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>观察者模式是一种<strong>行为型设计模式</strong>，也被称为<strong>发布-订阅模式</strong>。它定义了一种<strong>一对多</strong>的依赖关系，允许一个对象（<strong>主题</strong>）在状态改变时通知多个依赖它的对象（<strong>观察者</strong>），而无需知道观察者的具体类型。 观察者模式主要用于构建<strong>松耦合</strong>的系统，其中一个对象状态的改变需要通知其他对象，但又希望避免对象间的紧密依赖关系。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>建立依赖关系：</strong> 定义主题和观察者之间的一对多依赖关系。</li><li><strong>状态同步：</strong> 当主题状态改变时，自动通知所有注册的观察者。</li><li><strong>松耦合：</strong> 解耦主题和观察者，使得它们可以独立变化。</li><li><strong>事件驱动：</strong> 支持事件驱动的系统架构，主题作为事件源，观察者作为事件处理者。</li></ul><h4 id="3-观察者模式的职责"><a href="#3-观察者模式的职责" class="headerlink" title="3. 观察者模式的职责"></a>3. 观察者模式的职责</h4><p>观察者模式的核心职责是实现<strong>一对多的通知机制</strong>。当一个对象的状态发生变化时，需要及时通知一系列相关的对象，使它们能够做出相应的响应。</p><p><strong>实现方式 (通知策略)：</strong></p><ul><li><strong>推 (Push) 模式：</strong> 主题将状态变化的详细信息（例如，所有相关数据）以广播的方式推送给所有观察者。 观察者被动接收这些信息，并根据需要进行处理。 优点是观察者无需主动请求数据，缺点是可能推送过多无用信息。</li><li><strong>拉 (Pull) 模式：</strong> 主题只通知观察者状态发生了改变，观察者需要主动向主题请求获取最新的状态信息。 优点是观察者可以按需获取数据，缺点是需要额外的请求操作。</li></ul><h4 id="4-模式结构"><a href="#4-模式结构" class="headerlink" title="4. 模式结构"></a>4. 模式结构</h4><p>观察者模式涉及以下角色：</p><ul><li><strong>主题 (Subject)：</strong><ul><li>维护一个观察者列表。</li><li>提供注册 (registerObserver)、移除 (removeObserver) 观察者的方法。</li><li>在状态改变时，通知 (notifyObservers) 所有注册的观察者。</li></ul></li><li><strong>观察者 (Observer)：</strong><ul><li>定义一个 <code>update()</code> 方法，用于接收主题的通知并更新自身状态。</li></ul></li><li><strong>具体主题 (Concrete Subject)：</strong><ul><li>实现主题接口，存储主题的内部状态。</li><li>在状态改变时，调用 <code>notifyObservers()</code> 方法通知所有观察者。</li></ul></li><li><strong>具体观察者 (Concrete Observer)：</strong><ul><li>实现观察者接口，接收主题的通知并更新自身状态。</li><li>可以持有具体主题的引用，以便在需要时获取主题的更多信息（拉模式）。</li></ul></li><li><strong>客户端 (Client):</strong> 创建主题对象和观察者对象，并建立它们之间的联系。</li></ul><h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><ul><li>当一个对象的状态改变需要通知其他对象，而你希望避免对象间的紧密耦合。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。 将这两者封装在独立的对象中，使它们可以独立地改变和复用。</li><li>在分布式系统中，实现跨系统的消息交换，例如消息队列、事件总线等。</li><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。</li></ul><h4 id="6-模式优点"><a href="#6-模式优点" class="headerlink" title="6. 模式优点"></a>6. 模式优点</h4><ul><li><strong>松耦合：</strong> 主题和观察者之间是松散耦合的，可以独立地改变和复用。</li><li><strong>可扩展性：</strong> 可以很容易地添加新的观察者，而无需修改主题的代码。</li><li><strong>灵活性：</strong> 支持不同的通知策略（推、拉），可以根据具体需求选择合适的策略。</li><li><strong>支持广播通信：</strong> 主题可以同时通知多个观察者。</li></ul><h4 id="7-模式缺点"><a href="#7-模式缺点" class="headerlink" title="7. 模式缺点"></a>7. 模式缺点</h4><ul><li><strong>可能产生无效更新：</strong> 如果观察者不关心主题的某个状态变化，仍然会收到通知，造成性能浪费（推模式）。</li><li><strong>观察者难以跟踪主题的变化：</strong> 观察者可能不知道是什么原因导致了主题的状态变化，难以进行调试和维护。</li><li><strong>可能导致循环依赖：</strong> 如果主题和观察者之间存在循环依赖关系，可能导致系统崩溃。</li></ul><h4 id="8-示例代码-推模式"><a href="#8-示例代码-推模式" class="headerlink" title="8. 示例代码 (推模式)"></a>8. 示例代码 (推模式)</h4><p><strong>场景：</strong></p><p>假设你正在开发一个天气预报系统。 有一个 <code>WeatherData</code> 类负责获取天气数据（温度、湿度、气压），然后你需要将这些数据推送给多个订阅者（观察者），例如显示当前天气信息的显示器、记录天气数据的日志系统等。</p><p><strong>1. 主题接口 (Subject Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题接口，定义了注册、移除和通知观察者的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 观察者接口 (Observer Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口，定义了接收更新的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 具体主题类 (Concrete Subject)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体主题类，实现了 Subject 接口，维护了观察者列表，并在状态改变时通知观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当天气数据改变时，调用此方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置天气数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged(); <span class="comment">// 数据改变后，通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体观察者类 (Concrete Observer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体观察者类，实现了 Observer 接口，接收主题的状态更新并进行相应的处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>); <span class="comment">// 注册到主题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前气象：温度 &quot;</span> + temperature + <span class="string">&quot; 度，湿度 &quot;</span> + humidity + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建主题对象</span></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建观察者对象</span></span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>(weatherData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置天气数据，主题会通知观察者</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">25</span>, <span class="number">60</span>, <span class="number">1013</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">26</span>, <span class="number">65</span>, <span class="number">1012</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除观察者</span></span><br><span class="line">        weatherData.removeObserver(currentDisplay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次设置天气数据，观察者不会收到通知</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">27</span>, <span class="number">70</span>, <span class="number">1011</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-关键点说明"><a href="#9-关键点说明" class="headerlink" title="9. 关键点说明"></a>9. 关键点说明</h4><ul><li><strong><code>Subject</code> 接口：</strong> 定义了 <code>registerObserver()</code>, <code>removeObserver()</code>, <code>notifyObservers()</code> 方法，用于管理观察者。</li><li><strong><code>Observer</code> 接口：</strong> 定义了 <code>update()</code> 方法，观察者通过此方法接收主题的更新。</li><li><strong><code>WeatherData</code> 类：</strong>  实现了 <code>Subject</code> 接口，维护了观察者列表。 当天气数据发生改变时 ( <code>setMeasurements()</code> 方法)，调用 <code>notifyObservers()</code> 方法通知所有已注册的观察者。</li><li><strong><code>CurrentConditionsDisplay</code> 类：</strong> 实现了 <code>Observer</code> 接口，接收 <code>WeatherData</code> 的更新，并显示当前天气信息。</li><li><strong><code>ObserverPatternDemo</code> 类：</strong> 客户端代码，演示了如何创建主题和观察者，以及如何注册、移除和通知观察者。</li></ul><h4 id="10-运行结果"><a href="#10-运行结果" class="headerlink" title="10. 运行结果"></a>10. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前气象：温度 25.0 度，湿度 60.0%</span><br><span class="line">当前气象：温度 26.0 度，湿度 65.0%</span><br></pre></td></tr></table></figure><h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h4><p>观察者模式是一种非常有用的设计模式，可以用于构建松耦合、可扩展的系统。 通过将主题和观察者解耦，可以使它们独立地变化，从而提高系统的灵活性和可维护性。 在实际应用中，需要根据具体的需求选择合适的通知策略，并注意避免可能出现的循环依赖问题。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配者模式</title>
      <link href="/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>适配器模式是一种<strong>结构型设计模式</strong>，它允许<strong>将一个类的接口转换成客户端所期望的另一种接口</strong>，从而使原本接口不兼容而无法一起工作的类能够协同工作。 适配器模式通过创建一个适配器类，充当两者之间的桥梁，实现了接口的转换和兼容.</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>接口转换：</strong> 将现有类的接口转换为客户端需要的接口。</li><li><strong>系统兼容：</strong> 解决接口不兼容问题，使得不同接口的类可以协同工作。</li><li><strong>代码复用：</strong> 复用现有类，避免修改源代码。</li><li><strong>透明适配：</strong> 对客户端隐藏适配过程，客户端无需关心适配器的存在。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>适配器模式涉及以下角色：</p><ul><li><strong>目标接口 (Target):</strong> 定义客户端期望使用的接口，也是客户端所依赖的接口。</li><li><strong>适配者 (Adaptee):</strong> 现有需要被适配的类，其接口与目标接口不兼容。</li><li><strong>适配器 (Adapter):</strong> 核心组件，实现目标接口，并持有适配者类的实例，将适配者类的接口转换为目标接口。</li><li><strong>客户端 (Client):</strong> 通过目标接口使用适配器，无需关心适配者类的具体实现。</li></ul><h4 id="4-适配器模式的两种实现方式"><a href="#4-适配器模式的两种实现方式" class="headerlink" title="4. 适配器模式的两种实现方式"></a>4. 适配器模式的两种实现方式</h4><p>在 Java 中，适配器模式通常分为两种类型：<strong>类适配器</strong>和<strong>对象适配器</strong>。对象适配器是更常用的方式，因为它更灵活。<br><strong>4.1 类适配器 (Class Adapter)</strong></p><ul><li><strong>实现方式：</strong> 通过<strong>多重继承</strong>实现。 适配器类同时<strong>继承目标类</strong>和<strong>适配者类</strong>。</li><li><strong>工作原理：</strong> 适配器类继承目标类，从而可以作为目标类型使用；同时继承适配者类，从而可以访问适配者的功能。</li><li><strong>优缺点：</strong><ul><li><em>优点：</em> 实现简单，可以直接使用适配者的方法。</li><li><em>缺点：</em> 只能适配类，不能适配对象；Java 不支持多重类继承，因此存在局限性，实际应用较少。<br><strong>4.2 对象适配器 (Object Adapter)</strong></li></ul></li><li><strong>实现方式：</strong> 通过<strong>组合</strong>实现。 适配器类持有一个<strong>适配者类的实例</strong>，并<strong>实现目标接口</strong>。</li><li><strong>工作原理：</strong> 适配器类实现目标接口，并调用适配者类的实例的方法，从而将适配者的功能适配到目标接口。</li><li><strong>优缺点：</strong><ul><li><em>优点：</em> 可以适配对象，更加灵活；可以使用接口或抽象类作为目标接口，扩展性更好。</li><li><em>缺点：</em> 相比类适配器，实现稍复杂，需要维护一个适配者实例。</li></ul></li></ul><h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><ul><li>系统需要使用现有的类，但该类的接口与系统的接口不兼容。</li><li>需要创建一个可复用的类，使其能够与不相关的类或不可预见的类协同工作。</li><li>需要统一多个类的接口，将其转换为统一的接口。</li><li>希望在不修改源代码的情况下，使用某个类的功能。</li></ul><h4 id="6-模式优点"><a href="#6-模式优点" class="headerlink" title="6. 模式优点"></a>6. 模式优点</h4><ul><li><strong>提高类的复用性：</strong> 适配器模式允许使用现有的类，即使它们的接口不兼容。</li><li><strong>提高灵活性：</strong> 可以根据需要创建多个适配器，以满足不同的接口需求。</li><li><strong>符合开闭原则：</strong> 可以在不修改现有代码的情况下引入新的适配器。</li><li><strong>解耦合：</strong> 将客户端与适配者解耦，降低系统依赖性。</li></ul><h4 id="7-模式缺点"><a href="#7-模式缺点" class="headerlink" title="7. 模式缺点"></a>7. 模式缺点</h4><ul><li><strong>增加代码复杂性：</strong> 适配器模式可能会增加代码的复杂性，特别是当适配器链很长时。</li><li><strong>过度使用：</strong> 过度使用适配器模式可能会导致系统难以理解和维护。 需要谨慎使用，避免不必要的适配。</li></ul><h4 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h4><p><em>这里只对“对象适配器”进行演示，因为在Java开发过程中“类适配器”几乎用不到。</em><br><strong>场景：</strong><br>假设你有一个旧的音频播放器接口 <code>LegacyMediaPlayer</code>，它只能播放 <code>MP3</code> 格式的音频文件。 现在你想要让它也能播放 <code>MP4</code> 格式的音频文件，但是你不能修改 <code>LegacyMediaPlayer</code> 接口。 这时，你可以使用适配器模式来解决这个问题。</p><p><strong>1. 旧的音频播放器接口 (Legacy MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的音频播放器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LegacyMediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">playMP3</span><span class="params">(String filename)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 旧的音频播放器实现类 (Concrete Legacy MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的音频播放器实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LegacyMP3Player</span> <span class="keyword">implements</span> <span class="title class_">LegacyMediaPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMP3</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在播放 MP3 文件: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 新的音频播放器接口 (New MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的音频播放器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String filename, String fileType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 新的 MP4 音频播放器 (Adaptee)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的 MP4 音频播放器 (Adaptee)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP4Player</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMP4</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在播放 MP4 文件: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 适配器类 (Adapter)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MediaAdapter</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MP4Player mp4Player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MediaAdapter</span><span class="params">(MP4Player mp4Player)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mp4Player = mp4Player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String filename, String fileType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            mp4Player.playMP4(filename);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持的音频格式: &quot;</span> + fileType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建旧的 MP3 播放器</span></span><br><span class="line">        <span class="type">LegacyMediaPlayer</span> <span class="variable">mp3Player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LegacyMP3Player</span>();</span><br><span class="line">        mp3Player.playMP3(<span class="string">&quot;old_song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MP4 播放器</span></span><br><span class="line">        <span class="type">MP4Player</span> <span class="variable">mp4Player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MP4Player</span>();</span><br><span class="line">        <span class="comment">// 创建适配器</span></span><br><span class="line">        <span class="type">MediaPlayer</span> <span class="variable">mediaAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaAdapter</span>(mp4Player);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用适配器播放 MP4 文件</span></span><br><span class="line">        mediaAdapter.play(<span class="string">&quot;new_song.mp4&quot;</span>, <span class="string">&quot;mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试播放其他格式的文件</span></span><br><span class="line">        mediaAdapter.play(<span class="string">&quot;another_song.avi&quot;</span>, <span class="string">&quot;avi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ul><li><strong>LegacyMediaPlayer 接口：</strong> 旧的 MP3 播放器接口，只能播放 MP3 文件。</li><li><strong>LegacyMP3Player 类：</strong> 实现了 <code>LegacyMediaPlayer</code> 接口，播放 MP3 文件。</li><li><strong>MediaPlayer 接口：</strong> 新的音频播放器接口，可以播放多种格式的文件。</li><li><strong>MP4Player 类：</strong> 新的 MP4 播放器，可以播放 MP4 文件。</li><li><strong>MediaAdapter 类：</strong> 适配器类，实现了 <code>MediaPlayer</code> 接口，并持有 <code>MP4Player</code> 的实例。 当需要播放 MP4 文件时，适配器调用 <code>MP4Player</code> 的 <code>playMP4()</code> 方法，从而将 <code>MP4Player</code> 适配到 <code>MediaPlayer</code> 接口。</li><li><strong>AdapterPatternDemo 类：</strong> 客户端代码，演示了如何使用适配器来播放 MP4 文件。</li></ul><h4 id="9-运行结果"><a href="#9-运行结果" class="headerlink" title="9. 运行结果"></a>9. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正在播放 MP3 文件: old_song.mp3</span><br><span class="line">正在播放 MP4 文件: new_song.mp4</span><br><span class="line">不支持的音频格式: avi</span><br></pre></td></tr></table></figure><h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h4><p>适配器模式通过将一个类的接口转换成客户端所期望的另一种接口，实现了接口的兼容和复用。 对象适配器是更常用的实现方式，因为它更灵活，可以适配对象，并且可以使用接口或抽象类作为目标接口。 在选择使用适配器模式时，需要权衡其优点和缺点，并根据具体的应用场景进行选择。 避免过度使用，保持代码的简洁和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 适配者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之策略模式"><a href="#设计模式之策略模式" class="headerlink" title="设计模式之策略模式"></a>设计模式之策略模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>策略模式是一种<strong>行为型设计模式</strong>，它定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。 策略模式让算法独立于使用它的客户而变化，使得可以在运行时动态地选择算法。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>封装算法：</strong> 将不同的算法封装到独立的类中。</li><li><strong>算法可互换：</strong> 使算法可以相互替换，而不会影响客户端代码。</li><li><strong>运行时选择：</strong> 允许在运行时选择不同的算法。</li><li><strong>解耦合：</strong> 将算法与使用算法的客户端代码解耦。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>策略模式主要包含以下角色：</p><ul><li><strong>策略接口 (Strategy):</strong><ul><li>定义算法的接口，所有具体的策略类都必须实现该接口。</li></ul></li><li><strong>具体策略类 (Concrete Strategy):</strong><ul><li>实现策略接口，封装具体的算法。</li></ul></li><li><strong>环境类 (Context):</strong><ul><li>持有一个策略接口的引用。</li><li>负责在运行时选择合适的策略。</li><li>客户端通过环境类来使用策略。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当一个类有很多行为，而且这些行为在运行时需要动态地改变时。</li><li>当需要使用不同的算法来解决同一个问题时。</li><li>当算法的实现细节需要对客户端隐藏时。</li><li>当需要避免使用大量的 <code>if-else</code> 或 <code>switch</code> 语句时。</li></ul><p><strong>实际案例：</strong></p><ul><li><strong>会员折扣：</strong> 针对不同会员等级（初级、中级、高级）应用不同的折扣策略。</li><li><strong>支付方式：</strong> 支持多种支付方式，如信用卡支付、支付宝支付、微信支付等。</li><li><strong>排序算法：</strong> 针对不同的数据规模或特点，选择不同的排序算法（如快速排序、归并排序、插入排序等）。</li><li><strong>缓存策略：</strong> 根据不同的场景，选择不同的缓存策略（如 LRU、FIFO、LFU 等）。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>算法可互换：</strong> 可以在运行时动态地切换算法。</li><li><strong>避免多重条件判断：</strong> 使用策略模式可以避免使用大量的 <code>if-else</code> 或 <code>switch</code> 语句。</li><li><strong>扩展性良好：</strong> 增加新的策略类非常容易，无需修改现有代码。</li><li><strong>代码复用：</strong> 不同的客户端可以复用相同的策略类。</li><li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>策略类会增多：</strong> 每种算法都需要一个具体的策略类，可能会导致类的数量增加。</li><li><strong>客户端需要了解所有策略：</strong> 客户端需要知道所有可用的策略，才能选择合适的策略。 在某些情况下，这可能会暴露算法的实现细节。</li></ul><h4 id="7-实现方式"><a href="#7-实现方式" class="headerlink" title="7. 实现方式"></a>7. 实现方式</h4><ol><li><strong>定义策略接口：</strong> 声明算法的接口。</li><li><strong>实现具体策略类：</strong> 实现策略接口，封装具体的算法。</li><li><strong>创建环境类：</strong><ul><li>持有策略接口的引用。</li><li>提供设置策略的方法，允许客户端在运行时选择策略。</li><li>在需要使用算法的地方调用策略接口的方法。</li></ul></li><li><strong>客户端：</strong> 创建环境类对象，并根据需要设置不同的策略。</li></ol><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 策略接口 (Strategy Interface)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体策略类 (Concrete Strategy Classes)</span></span><br><span class="line"><span class="comment">// 具体策略类 - 信用卡支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardNumber;</span><br><span class="line">    <span class="keyword">private</span> String cvv;</span><br><span class="line">    <span class="keyword">private</span> String expiryDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreditCardPayment</span><span class="params">(String name, String cardNumber, String cvv, String expiryDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.cardNumber = cardNumber;</span><br><span class="line">        <span class="built_in">this</span>.cvv = cvv;</span><br><span class="line">        <span class="built_in">this</span>.expiryDate = expiryDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用信用卡支付: &quot;</span> + amount + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;信用卡信息: &quot;</span> + cardNumber); <span class="comment">// 实际场景需要加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类 - 支付宝支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlipayPayment</span><span class="params">(String account)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用支付宝支付: &quot;</span> + amount + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝账号: &quot;</span> + account); <span class="comment">// 实际场景需要加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 环境类 (Context Class)</span></span><br><span class="line"><span class="comment">// 环境类 - 支付上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShoppingCart</span><span class="params">(PaymentStrategy paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentStrategy</span><span class="params">(PaymentStrategy paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        paymentStrategy.pay(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建购物车</span></span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>(<span class="keyword">new</span> <span class="title class_">CreditCardPayment</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;1234567890123456&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;2025-12&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用信用卡支付</span></span><br><span class="line">        cart.checkout(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换支付方式为支付宝</span></span><br><span class="line">        cart.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">AlipayPayment</span>(<span class="string">&quot;zhangsan@example.com&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用支付宝支付</span></span><br><span class="line">        cart.checkout(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ul><li><strong>PaymentStrategy 接口：</strong> 定义了支付的接口 <code>pay(int amount)</code>，所有具体的支付策略都必须实现这个接口。</li><li><strong>CreditCardPayment 类：</strong> 实现了 <code>PaymentStrategy</code> 接口，使用信用卡进行支付。</li><li><strong>AlipayPayment 类：</strong> 实现了 <code>PaymentStrategy</code> 接口，使用支付宝进行支付。</li><li><strong>ShoppingCart 类：</strong> 环境类，它持有一个 <code>PaymentStrategy</code> 接口的引用，并在 <code>checkout()</code> 方法中调用 <code>PaymentStrategy</code> 的 <code>pay()</code> 方法。</li><li><strong>StrategyPatternDemo 类：</strong> 客户端代码，它创建了一个 <code>ShoppingCart</code> 对象，并设置不同的 <code>PaymentStrategy</code>，然后调用 <code>checkout()</code> 方法进行支付。</li></ul><h4 id="9-运行结果"><a href="#9-运行结果" class="headerlink" title="9. 运行结果"></a>9. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用信用卡支付: 100 元</span><br><span class="line">信用卡信息: 1234567890123456</span><br><span class="line">使用支付宝支付: 50 元</span><br><span class="line">支付宝账号: zhangsan@example.com</span><br></pre></td></tr></table></figure><h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h4><p>策略模式通过封装算法并使其可互换，实现了算法与客户端代码的解耦，提高了代码的灵活性和可维护性。 在选择使用策略模式时，需要权衡其优点和缺点，并根据具体的应用场景进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之原型模式"><a href="#设计模式之原型模式" class="headerlink" title="设计模式之原型模式"></a>设计模式之原型模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>原型模式是一种<strong>创建型设计模式</strong>，它允许通过复制现有对象来创建新的对象，而无需知道创建对象的具体类。 简单来说，原型模式就是“克隆”对象。 原型模式特别适用于创建复杂对象或者构造耗时的实例，因为复制一个已经存在的实例可以使程序运行更高效。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>对象复制：</strong> 使用已存在的对象作为原型，通过复制生成新的对象。</li><li><strong>避免重复初始化：</strong> 避免重复进行耗时的初始化操作。</li><li><strong>隐藏创建细节：</strong> 客户端无需了解对象创建的复杂过程。</li><li><strong>动态创建：</strong> 运行时动态决定创建哪些对象。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>原型模式主要包含以下角色：</p><ul><li><strong>原型接口 (Prototype):</strong><ul><li>声明 <code>clone()</code> 方法，用于复制对象。</li><li>定义复制对象所需的接口。</li></ul></li><li><strong>具体原型类 (Concrete Prototype):</strong><ul><li>实现 <code>Prototype</code> 接口。</li><li>实现 <code>clone()</code> 方法，返回自身的副本。</li><li>可以是浅拷贝或深拷贝。</li></ul></li><li><strong>客户端 (Client):</strong><ul><li>通过调用原型对象的 <code>clone()</code> 方法来创建新的对象。</li><li>无需知道具体原型类的名称。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当创建对象的代价比较大（例如，需要进行复杂的初始化或者占用大量资源）时。</li><li>当需要避免创建一个与特定类无关的对象时。</li><li>当需要在运行时动态地指定产品对象时。</li><li>当一个系统中存在大量相似对象时，可以使用原型模式创建新对象，从而提高效率。</li><li>需要保护性拷贝时，即一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li><li>Spring 框架中的多例 Bean 就是使用原型模式实现的。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>简化创建过程：</strong> 客户端无需了解对象的创建细节。</li><li><strong>提高创建效率：</strong> 通过复制现有对象来创建新对象，避免重复初始化。</li><li><strong>动态性：</strong> 可以在运行时动态地指定创建哪些对象。</li><li><strong>扩展性：</strong> 增加新的原型类非常容易。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>深拷贝复杂：</strong> 深拷贝的实现比较复杂，需要递归复制所有关联对象。</li><li><strong>破坏封装性：</strong> 客户端必须知道具体原型类的类型。</li><li><strong>可能需要修改原始类的代码：</strong> 为了实现 <code>clone()</code> 方法，可能需要修改原始类的代码。</li></ul><h4 id="7-实现方式"><a href="#7-实现方式" class="headerlink" title="7. 实现方式"></a>7. 实现方式</h4><ol><li><strong>实现 <code>Cloneable</code> 接口：</strong> 在 Java 语言中，<code>Cloneable</code> 接口的作用是在运行时通知 Java 虚拟机，可以安全地在实现了此接口的类上使用 <code>clone</code> 方法。在 Java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 <code>CloneNotSupportedException</code> 异常。</li><li><strong>重写 <code>Object</code> 类中的 <code>clone</code> 方法：</strong> Java 中，所有类的父类都是 <code>Object</code> 类，<code>Object</code> 类中有一个 <code>clone</code> 方法，作用是返回对象的一个拷贝，但是其作用域是 <code>protected</code> 类型的，一般的类无法调用，因此 <code>Prototype</code> 类需要将 <code>clone</code> 方法的作用域修改为 <code>public</code> 类型。</li><li><strong>浅拷贝 vs. 深拷贝：</strong><ul><li><strong>浅拷贝：</strong> 只复制对象的基本类型数据和引用，而不复制引用指向的对象。这意味着原始对象和克隆对象会共享引用指向的对象。</li><li><strong>深拷贝：</strong> 复制对象的所有数据，包括引用指向的对象。这意味着原始对象和克隆对象是完全独立的。要实现深拷贝，需要在 <code>clone()</code> 方法中手动复制所有引用指向的对象。</li></ul></li></ol><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><p><strong>浅拷贝示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 原型接口 (Prototype Interface)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Prototype</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>; <span class="comment">// 复制方法</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取名称</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>; <span class="comment">// 设置名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体原型类 (Concrete Prototype Class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持克隆&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;原始对象&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone();</span><br><span class="line">        clone.setName(<span class="string">&quot;克隆对象&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象名称: &quot;</span> + clone.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName()); <span class="comment">// 验证原始对象是否被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始对象名称: 原始对象</span><br><span class="line">克隆对象名称: 克隆对象</span><br><span class="line">原始对象名称: 原始对象</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ul><li><strong>Prototype 接口：</strong> 声明了 <code>clone()</code> 方法，所有具体的原型类都必须实现这个方法。</li><li><strong>ConcretePrototype 类：</strong> 实现了 <code>Prototype</code> 接口，并提供了 <code>clone()</code> 方法的具体实现。 在这个例子中，我们使用 <code>super.clone()</code> 进行浅拷贝。</li><li><strong>PrototypePatternDemo 类：</strong> 客户端代码，它创建了一个 <code>ConcretePrototype</code> 对象，然后使用 <code>clone()</code> 方法创建了一个新的对象。</li></ul><p><strong>深拷贝示例 (如果 ConcretePrototype 包含一个引用类型的成员变量):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data; <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String name, List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">// 深拷贝引用类型的成员变量</span></span><br><span class="line">            clone.data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.data); <span class="comment">// 创建新的 List 对象并复制数据</span></span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持克隆&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        List&lt;String&gt; originalData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        originalData.add(<span class="string">&quot;数据1&quot;</span>);</span><br><span class="line">        originalData.add(<span class="string">&quot;数据2&quot;</span>);</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;原始对象&quot;</span>, originalData);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象数据: &quot;</span> + prototype.getData());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone();</span><br><span class="line">        clone.setName(<span class="string">&quot;克隆对象&quot;</span>);</span><br><span class="line">        clone.getData().add(<span class="string">&quot;新数据&quot;</span>); <span class="comment">// 修改克隆对象的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象名称: &quot;</span> + clone.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象数据: &quot;</span> + clone.getData());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName()); <span class="comment">// 验证原始对象是否被修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象数据: &quot;</span> + prototype.getData()); <span class="comment">// 验证原始对象的数据是否被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个深拷贝的例子中，我们创建了一个新的 <code>ArrayList</code> 对象，并将原始对象 <code>data</code> 中的所有元素复制到新的 <code>ArrayList</code> 中。 这样，原始对象和克隆对象就拥有了独立的 <code>data</code> 列表，修改克隆对象的 <code>data</code> 不会影响原始对象。</p><p><strong>运行结果 (深拷贝示例)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始对象名称: 原始对象</span><br><span class="line">原始对象数据: [数据1, 数据2]</span><br><span class="line">克隆对象名称: 克隆对象</span><br><span class="line">克隆对象数据: [数据1, 数据2, 新数据]</span><br><span class="line">原始对象名称: 原始对象</span><br><span class="line">原始对象数据: [数据1, 数据2]</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>原型模式通过复制现有对象来创建新的对象，避免了重复初始化，提高了创建效率。在实现原型模式时，需要注意浅拷贝和深拷贝的区别，选择合适的拷贝方式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之外观模式"><a href="#设计模式之外观模式" class="headerlink" title="设计模式之外观模式"></a>设计模式之外观模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>外观模式是一种<strong>结构型设计模式</strong>，它为子系统中的一组接口提供了一个统一的入口点。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。 简单来说，外观模式隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的简单接口。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>简化接口：</strong> 为复杂的子系统提供一个简单的、统一的接口。</li><li><strong>解耦：</strong> 降低客户端与子系统之间的耦合度。</li><li><strong>易用性：</strong> 使子系统更容易使用。</li><li><strong>隐藏复杂性：</strong> 隐藏子系统的内部复杂性，客户端无需了解子系统的实现细节。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>外观模式主要包含以下角色：</p><ul><li><strong>外观（Facade）：</strong><ul><li>知道哪些子系统负责处理请求。</li><li>将客户端的请求委派给适当的子系统对象。</li><li>提供一个高层接口，简化子系统的使用。</li></ul></li><li><strong>子系统（Subsystems）：</strong><ul><li>实现子系统的功能。</li><li>处理由 Facade 类委派的请求。</li><li>子系统类并不知道 Facade 的存在。</li></ul></li><li><strong>客户端（Client）：</strong><ul><li>通过 Facade 对象访问子系统。</li><li>客户端不需要直接与子系统交互。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当需要为一个复杂的子系统提供一个简单的接口时。</li><li>当客户端不希望与复杂的子系统直接交互时。</li><li>当需要降低客户端与子系统之间的耦合度时。</li><li>当需要对子系统进行分层时，可以使用外观模式定义每层的入口。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>简化客户端的使用：</strong> 客户端无需了解子系统的复杂性，只需与外观类交互即可。</li><li><strong>降低耦合度：</strong> 降低客户端与子系统之间的耦合度，提高系统的灵活性和可维护性。</li><li><strong>提高可重用性：</strong> 将子系统的实现细节隐藏起来，方便子系统的重用。</li><li><strong>符合最少知识原则：</strong> 客户端只需要了解外观类，而不需要了解子系统的内部实现。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>可能导致外观类过于庞大：</strong> 如果子系统过于复杂，外观类可能会变得非常庞大，难以维护。</li><li><strong>不符合开闭原则：</strong> 如果需要修改子系统，可能需要修改外观类，这违反了开闭原则。</li></ul><h4 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. 实际应用场景</h4><ul><li><strong>编译器：</strong> 编译器可以将词法分析、语法分析、代码生成等子系统的复杂性隐藏起来，提供一个简单的编译接口。</li><li><strong>操作系统：</strong> 操作系统可以提供一个简单的 API 供应用程序调用，而隐藏底层的硬件操作。</li><li><strong>数据库访问：</strong> 可以使用外观模式封装数据库的连接、查询、更新等操作，提供一个简单的数据库访问接口。</li><li><strong>中间件：</strong> 中间件可以封装底层的网络通信、事务管理等复杂性，提供一个简单的服务调用接口。</li></ul><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 子系统类 (Subsystem Classes)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeze</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 冻结&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 执行指令&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">(<span class="type">long</span> position)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 跳转到地址: &quot;</span> + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">long</span> position, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内存加载数据到地址: &quot;</span> + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> lba, <span class="type">int</span> size) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘读取 LBA: &quot;</span> + lba + <span class="string">&quot;，大小: &quot;</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[size]; <span class="comment">// 模拟读取的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 外观类 (Facade Class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> HardDrive hardDrive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        <span class="built_in">this</span>.hardDrive = <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu.freeze();</span><br><span class="line">        memory.load(<span class="number">0x0000</span>, hardDrive.read(<span class="number">0</span>, <span class="number">1024</span>));</span><br><span class="line">        cpu.jump(<span class="number">0x1000</span>);</span><br><span class="line">        cpu.execute();</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑启动完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.startComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点解释：</strong></p><ul><li><strong>CPU, Memory, HardDrive (Subsystems):</strong> 这些是复杂的子系统，客户端通常需要直接与它们交互才能完成某些任务。 在这里，它们模拟计算机的不同组件。</li><li><strong>Computer (Facade):</strong> 外观类提供了一个简化的接口来访问子系统。 客户端只需调用外观类的方法，而无需了解子系统的复杂性。</li><li><strong>FacadePatternDemo (Client):</strong> 客户端类，它使用外观类来启动计算机。 客户端不需要直接与 CPU、内存或硬盘驱动器交互。</li><li><strong>外观模式</strong>通过提供一个统一的接口来访问子系统，简化了客户端的使用。 客户端无需了解子系统的复杂性，只需与外观类交互即可。这降低了客户端与子系统之间的耦合度，提高了代码的可维护性和可重用性。  在这个例子中，<code>Computer</code> 类充当外观，它封装了启动计算机所需的复杂步骤。 客户端只需调用 <code>startComputer()</code> 方法，即可启动计算机，而无需了解 CPU、内存和硬盘驱动器之间的交互细节。</li></ul><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU 冻结</span><br><span class="line">硬盘读取 LBA: 0，大小: 1024</span><br><span class="line">内存加载数据到地址: 0</span><br><span class="line">CPU 跳转到地址: 4096</span><br><span class="line">CPU 执行指令</span><br><span class="line">电脑启动完成！</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>外观模式是一种非常有用的设计模式，它可以简化客户端的使用，降低客户端与子系统之间的耦合度，提高系统的灵活性和可维护性。 然而，也需要注意外观模式的缺点，避免过度使用，导致外观类过于庞大。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 外观模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板方法模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之模板方法模式"><a href="#设计模式之模板方法模式" class="headerlink" title="设计模式之模板方法模式"></a>设计模式之模板方法模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>模板方法模式是一种<strong>行为型设计模式</strong>，它在一个抽象类中定义一个算法的骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些特定步骤。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>定义算法骨架：</strong> 在一个方法中定义一个算法的骨架，并将一些步骤延迟到子类。</li><li><strong>代码复用：</strong> 通过将通用步骤放在父类中，避免子类重复编写相同的代码。</li><li><strong>扩展性：</strong> 允许子类在不改变算法结构的情况下，定制算法的某些步骤。</li><li><strong>控制：</strong> 通过钩子方法，允许子类影响算法的执行流程。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>模板方法模式主要包含以下角色：</p><ul><li><strong>抽象类（Abstract Class）：</strong><ul><li>定义了模板方法，即算法的骨架。</li><li>模板方法由一系列抽象方法和&#x2F;或具体方法组成。</li><li>抽象方法由子类实现。</li><li>具体方法提供默认实现，子类可以选择性地重写。</li><li>可以包含钩子方法，允许子类影响算法的执行流程。</li></ul></li><li><strong>具体类（Concrete Class）：</strong><ul><li>实现了抽象类中的抽象方法，提供算法中特定步骤的具体实现。</li><li>可以选择性地重写抽象类中的具体方法或钩子方法。</li></ul></li><li><strong>客户端（Client）：</strong><ul><li>调用模板方法来执行算法。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当完成某一个任务时，其过程的<strong>步骤是固定</strong>的，但是每个步骤的具体实现是<strong>不确定</strong>的。</li><li>当多个类中具有相同的程序代码，并且仅仅在一些细节上存在不同时。</li><li>需要控制子类的行为，强制子类遵循某种算法流程。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>提高代码复用性：</strong> 将通用步骤放在父类中，避免子类重复编写相同的代码。</li><li><strong>提高扩展性：</strong> 允许子类在不改变算法结构的情况下，定制算法的某些步骤。</li><li><strong>符合开闭原则：</strong> 可以在不修改现有代码的情况下，通过新增子类来扩展算法。</li><li><strong>控制算法流程：</strong> 通过钩子方法，允许子类影响算法的执行流程，同时保持算法结构的稳定。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>增加类的数量：</strong> 每一个不同的实现都需要一个具体的子类，这可能会导致类的数量增加。</li><li><strong>抽象类的约束：</strong> 抽象类定义了算法的骨架，这可能会限制子类的灵活性。</li></ul><h4 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. 实际应用场景</h4><ul><li><strong>框架设计：</strong> 许多框架都使用了模板方法模式，例如：<ul><li>数据库访问的封装</li><li>Junit 单元测试</li><li>Servlet 中关于 doGet&#x2F;doPost 方法的调用</li></ul></li><li><strong>工作流引擎：</strong> 定义工作流的流程，每个步骤的具体实现由不同的子类完成。</li><li><strong>GUI 框架：</strong> 窗口的创建、事件处理等过程可以使用模板方法模式。</li></ul><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象类（Abstract Class）定义模板方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法：定义算法骨架</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">makeCake</span><span class="params">()</span> &#123;</span><br><span class="line">        prepareIngredients();  <span class="comment">// 准备原料</span></span><br><span class="line">        mixIngredients();      <span class="comment">// 混合原料</span></span><br><span class="line">        bakeCake();           <span class="comment">// 烘焙</span></span><br><span class="line">        addFrosting();         <span class="comment">// 添加糖霜</span></span><br><span class="line">        decorateCake();        <span class="comment">// 装饰蛋糕</span></span><br><span class="line">        packageCake();         <span class="comment">// 打包</span></span><br><span class="line">        System.out.println(<span class="string">&quot;蛋糕准备好了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：子类必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法：子类可以选择性地重写</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bakeCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在180度的温度下烘焙30分钟。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法：子类可以选择性地重写，控制算法流程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">needFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认需要糖霜</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法，根据钩子方法决定是否执行</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needFrosting()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加香草糖霜。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不添加糖霜。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">packageCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将蛋糕装在精美的盒子里。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体类（Concrete Class）实现抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChocolateCake</span> <span class="keyword">extends</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备巧克力、面粉、糖、鸡蛋和黄油。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;混合巧克力蛋糕的原料。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用巧克力屑和樱桃装饰。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体类（Concrete Class）实现抽象方法，并覆盖钩子方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VanillaCake</span> <span class="keyword">extends</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备香草精、面粉、糖、鸡蛋和黄油。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;混合香草蛋糕的原料。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用糖针和新鲜水果装饰。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">needFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不加糖霜</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端（Client）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractCake</span> <span class="variable">chocolateCake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateCake</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作巧克力蛋糕：&quot;</span>);</span><br><span class="line">        chocolateCake.makeCake();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n制作香草蛋糕：&quot;</span>);</span><br><span class="line">        <span class="type">AbstractCake</span> <span class="variable">vanillaCake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VanillaCake</span>();</span><br><span class="line">        vanillaCake.makeCake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点解释:</strong></p><ul><li><strong>抽象类 (Abstract Class): <code>AbstractCake</code></strong><ul><li>定义了模板方法 <code>makeCake()</code>，它定义了制作蛋糕的算法骨架。 这个方法是 <code>final</code> 的，防止子类修改算法结构。</li><li>声明了抽象方法 <code>prepareIngredients()</code>, <code>mixIngredients()</code>, <code>decorateCake()</code>。这些方法必须由子类实现，以提供特定类型的蛋糕的制作细节。</li><li>提供了具体方法 <code>bakeCake()</code>, <code>addFrosting()</code>, <code>packageCake()</code>。这些方法提供了默认实现，子类可以选择性地重写。</li><li>提供了钩子方法 <code>needFrosting()</code>。钩子方法允许子类在算法的特定点插入行为，从而控制算法流程。</li></ul></li><li><strong>具体类 (Concrete Classes): <code>ChocolateCake</code>, <code>VanillaCake</code></strong><ul><li>实现了抽象类 <code>AbstractCake</code> 的抽象方法，提供了特定类型蛋糕的制作细节。</li><li><code>VanillaCake</code> 重写了钩子方法 <code>needFrosting()</code>，以取消糖霜步骤。</li></ul></li><li><strong>客户端 (Client): <code>TemplateMethodDemo</code></strong><ul><li>创建了具体类的实例，并调用模板方法 <code>makeCake()</code>，触发了制作蛋糕的过程。</li></ul></li></ul><p><strong>输出结果:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">制作巧克力蛋糕：</span><br><span class="line">准备巧克力、面粉、糖、鸡蛋和黄油。</span><br><span class="line">混合巧克力蛋糕的原料。</span><br><span class="line">在180度的温度下烘焙30分钟。</span><br><span class="line">添加香草糖霜。</span><br><span class="line">用巧克力屑和樱桃装饰。</span><br><span class="line">将蛋糕装在精美的盒子里。</span><br><span class="line">蛋糕准备好了！</span><br><span class="line"></span><br><span class="line">制作香草蛋糕：</span><br><span class="line">准备香草精、面粉、糖、鸡蛋和黄油。</span><br><span class="line">混合香草蛋糕的原料。</span><br><span class="line">在180度的温度下烘焙30分钟。</span><br><span class="line">不添加糖霜。</span><br><span class="line">用糖针和新鲜水果装饰。</span><br><span class="line">将蛋糕装在精美的盒子里。</span><br><span class="line">蛋糕准备好了！</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>模板方法模式通过将算法骨架定义在抽象类中，并将某些步骤的实现延迟到子类，实现了代码的重用和扩展。<br>它允许子类在不改变算法结构的情况下，定制算法的某些步骤。<br>钩子方法提供了一种更灵活的方式来控制算法流程，允许子类在算法的特定点插入行为。<br>但是，也需要注意模板方法模式的缺点，避免过度使用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>建造者模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。 简单来说，就是将对象的构建过程封装起来，允许用户分步骤地构建复杂对象，而无需了解其内部构造细节。<br>与工厂模式不同，建造者模式侧重于<strong>逐步构建</strong>一个复杂的对象，而不是一次性创建。 建造者模式关注的是对象各部分的组装过程，而工厂模式关注的是创建整个对象。</p><h4 id="建造者模式的角色"><a href="#建造者模式的角色" class="headerlink" title="建造者模式的角色"></a>建造者模式的角色</h4><p>建造者模式通常包含以下几个角色：</p><ol><li><strong>抽象建造者 (Builder)：</strong> 定义一个抽象接口，规范产品对象的各个组成部分的建造方法。 这个接口声明了要创建复杂对象的哪些部分，但不涉及具体对象部件的创建。</li><li><strong>具体建造者 (Concrete Builder)：</strong> 实现 Builder 接口，针对不同的商业逻辑，具体化复杂对象的各个部分的创建。 在建造过程完成后，提供产品的实例。</li><li><strong>指挥者 (Director)：</strong> 调用具体建造者来创建复杂对象的各个部分，控制对象各部分的组装顺序。 指挥者不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 指挥者是可选的，如果构建过程足够简单，可以直接由客户端来调用具体建造者。</li><li><strong>产品 (Product)：</strong> 要创建的复杂对象。</li></ol><h4 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="headerlink" title="建造者模式的使用场景"></a>建造者模式的使用场景</h4><p>以下是一些适合使用建造者模式的场景：</p><ol><li><strong>需要生成的对象具有复杂的内部结构：</strong> 当一个对象包含多个部件，且这些部件的创建逻辑复杂时，可以使用建造者模式将构建过程分解为多个步骤。</li><li><strong>需要生成的对象内部属性本身相互依赖：</strong> 当对象的某些属性依赖于其他属性时，可以使用建造者模式来确保属性之间的正确初始化。</li><li><strong>需要控制对象的构建过程：</strong> 当需要对对象的构建过程进行精细控制，例如指定构建顺序或添加验证逻辑时，可以使用建造者模式。</li><li><strong>创建不同表示的对象：</strong>当相同的构建过程需要生成不同类型的对象时，可以使用不同的具体建造者。</li></ol><h4 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h4><ul><li><strong>封装性：</strong> 隐藏了产品内部的构造细节。</li><li><strong>灵活性：</strong> 可以灵活地指定产品的各个部件。</li><li><strong>可读性：</strong> 链式调用使代码更易读。</li><li><strong>可扩展性：</strong> 可以很容易地添加新的建造者类，以构建不同类型的产品。</li><li><strong>控制：</strong> 可以在 <code>build()</code> 方法中添加验证逻辑，保证产品对象的有效性。</li><li><strong>易于维护：</strong> 将复杂的构建过程分解为多个步骤，使得代码更易于理解和维护。</li></ul><h4 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h4><ul><li><strong>关注点不同：</strong> 建造者模式侧重于逐步构建一个复杂的对象，而工厂模式侧重于一次性创建对象。</li><li><strong>复杂度不同：</strong> 建造者模式通常用于构建更复杂的对象，而工厂模式可以用于创建相对简单的对象。</li><li><strong>灵活性不同：</strong> 建造者模式可以更灵活地控制对象的构建过程，而工厂模式的灵活性相对较低。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Java 中的 <code>StringBuilder</code> 就是建造者模式的一个典型应用。它将单个字符或字符串逐步组装成最终的字符串。</p><p>以下是一个使用建造者模式构建电脑的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 产品类 (Product)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String ram;</span><br><span class="line">    <span class="keyword">private</span> String storage;</span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;</span><br><span class="line">    <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，强制使用建造者模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(String cpu, String ram, String storage, String graphicsCard, String display)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram = ram;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">        <span class="built_in">this</span>.graphicsCard = graphicsCard;</span><br><span class="line">        <span class="built_in">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里忽略getter和setter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 toString 方法，方便打印</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;电脑&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;CPU=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, RAM=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, 储存=&#x27;&quot;</span> + storage + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, 显卡=&#x27;&quot;</span> + graphicsCard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, 显示器=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 建造者接口 (Builder Interface) -  也可以是一个抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span>;</span><br><span class="line">        Builder <span class="title function_">ram</span><span class="params">(String ram)</span>;</span><br><span class="line">        Builder <span class="title function_">storage</span><span class="params">(String storage)</span>;</span><br><span class="line">        Builder <span class="title function_">graphicsCard</span><span class="params">(String graphicsCard)</span>;</span><br><span class="line">        Builder <span class="title function_">display</span><span class="params">(String display)</span>;</span><br><span class="line">        Computer <span class="title function_">build</span><span class="params">()</span>;  <span class="comment">// 构建产品的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 具体建造者类 (Concrete Builder)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String ram;</span><br><span class="line">        <span class="keyword">private</span> String storage;</span><br><span class="line">        <span class="keyword">private</span> String graphicsCard;</span><br><span class="line">        <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">cpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">ram</span><span class="params">(String ram)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ram = ram;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">storage</span><span class="params">(String storage)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.storage = storage;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">graphicsCard</span><span class="params">(String graphicsCard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.graphicsCard = graphicsCard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">display</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 可在此处添加验证逻辑，例如，必须有 CPU 和 RAM</span></span><br><span class="line">            <span class="keyword">if</span> (cpu == <span class="literal">null</span> || ram == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;组装电脑，CPU和RAM是必需的。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, ram, storage, graphicsCard, display);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 指挥者类 (Director) - 可选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Computer.Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerDirector</span><span class="params">(Computer.Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">constructGamingComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.cpu(<span class="string">&quot;Intel i9&quot;</span>).ram(<span class="string">&quot;32GB&quot;</span>).storage(<span class="string">&quot;1TB SSD&quot;</span>).graphicsCard(<span class="string">&quot;Nvidia RTX 5070&quot;</span>).display(<span class="string">&quot;27-inch 4K&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">constructOfficeComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.cpu(<span class="string">&quot;Intel i5&quot;</span>).ram(<span class="string">&quot;16GB&quot;</span>).storage(<span class="string">&quot;512GB SSD&quot;</span>).display(<span class="string">&quot;24-inch 1080p&quot;</span>).build(); <span class="comment">// 缺少 graphicsCard 是可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 客户端代码 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用建造者模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一：直接使用 Builder</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder()</span><br><span class="line">                .cpu(<span class="string">&quot;AMD Ryzen 5&quot;</span>)</span><br><span class="line">                .ram(<span class="string">&quot;16GB&quot;</span>)</span><br><span class="line">                .storage(<span class="string">&quot;500GB SSD&quot;</span>)</span><br><span class="line">                .graphicsCard(<span class="string">&quot;AMD Radeon RX 7700&quot;</span>)</span><br><span class="line">                .display(<span class="string">&quot;24 inch&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;电脑 1: &quot;</span> + computer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二：使用 Director，更灵活</span></span><br><span class="line">        Computer.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder();</span><br><span class="line">        <span class="type">ComputerDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerDirector</span>(builder);</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">gamingComputer</span> <span class="operator">=</span> director.constructGamingComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏电脑: &quot;</span> + gamingComputer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">officeComputer</span> <span class="operator">=</span> director.constructOfficeComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;办公电脑: &quot;</span> + officeComputer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试验证逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Computer</span> <span class="variable">invalidComputer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder().storage(<span class="string">&quot;1TB&quot;</span>).build(); <span class="comment">// 缺少 CPU 和 RAM</span></span><br><span class="line">            System.out.println(invalidComputer); <span class="comment">// 不应该执行到这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常: &quot;</span> + e.getMessage());  <span class="comment">// 打印异常信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点说明：</strong></p><ul><li><strong>产品类 (Product)：</strong> <code>Computer</code> 类是最终要创建的复杂对象。 注意它的构造函数是私有的，这样就只能通过 Builder 来创建它，保证了建造过程的控制。</li><li><strong>建造者接口 (Builder Interface)：</strong> <code>Computer.Builder</code> 接口定义了创建 <code>Computer</code> 对象各个部分的方法。 它也可以是一个抽象类，如果有一些通用的构建逻辑。</li><li><strong>具体建造者 (Concrete Builder)：</strong> <code>Computer.ComputerBuilder</code> 实现了 <code>Computer.Builder</code> 接口，负责具体的产品构建过程。 它提供链式调用的方式来设置各个属性，并且 <code>build()</code> 方法返回最终的 <code>Computer</code> 对象。</li><li><strong>指挥者 (Director) - 可选：</strong> <code>ComputerDirector</code> 类负责管理建造者的构建顺序。 它封装了复杂的构建逻辑，客户端只需要选择构建哪种类型的 <code>Computer</code>，而不需要关心构建细节。 如果构建过程很简单，Director 可以省略。</li><li><strong>客户端 (Client)：</strong> 客户端代码创建建造者或指挥者，并调用相应的方法来构建 <code>Computer</code> 对象。 客户端无需关心 <code>Computer</code> 对象的构建细节。</li></ul><p>运行 <code>BuilderDemo.java</code> 将会打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电脑 1: 电脑&#123;CPU=&#x27;AMD Ryzen 5&#x27;, RAM=&#x27;16GB&#x27;, 储存=&#x27;500GB SSD&#x27;, 显卡=&#x27;AMD Radeon RX 7700&#x27;, 显示器=&#x27;24 inch&#x27;&#125;</span><br><span class="line">游戏电脑: 电脑&#123;CPU=&#x27;Intel i9&#x27;, RAM=&#x27;32GB&#x27;, 储存=&#x27;1TB SSD&#x27;, 显卡=&#x27;Nvidia RTX 5070&#x27;, 显示器=&#x27;27-inch 4K&#x27;&#125;</span><br><span class="line">办公电脑: 电脑&#123;CPU=&#x27;Intel i5&#x27;, RAM=&#x27;16GB&#x27;, 储存=&#x27;512GB SSD&#x27;, 显卡=&#x27;null&#x27;, 显示器=&#x27;24-inch 1080p&#x27;&#125;</span><br><span class="line">出现异常: 组装电脑，CPU和RAM是必需的。</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>建造者模式是一种非常有用的创建型设计模式，可以帮助我们构建复杂的对象，并控制对象的构建过程。 它可以提高代码的可读性、可维护性和可扩展性。 在实际开发中，我们可以根据具体情况选择是否使用建造者模式，以及如何使用它。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之代理模式"><a href="#设计模式之代理模式" class="headerlink" title="设计模式之代理模式"></a>设计模式之代理模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>代理模式通过引入一个代理对象来控制对原始对象的访问。代理可以在原始对象的方法调用前后添加额外的处理逻辑，例如权限控制、日志记录、事务管理等，而无需修改原始对象的代码。这是一种实现了 AOP (面向切面编程) 的轻量级方式。</p><p>代理模式与 Spring 的 AOP (面向切面编程) 思想非常相似，都可以在不修改原有代码和业务流程的情况下，动态地切入新代码，增加新功能。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>代理模式常用于以下场景：</p><ul><li><strong>Spring AOP</strong>：实现横切关注点的统一处理。</li><li><strong>日志打印</strong>：在方法调用前后记录日志。</li><li><strong>异常处理</strong>：统一处理方法调用中的异常。</li><li><strong>事务控制</strong>：在方法调用前后开启和关闭事务。</li><li><strong>权限控制</strong>：控制对敏感资源的访问。</li></ul><h4 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h4><p>代理模式主要分为以下三种类型：</p><ul><li><strong>静态代理（Static Proxy）：</strong> 程序员手动创建或通过工具生成代理类的源代码，并在程序运行前完成编译。代理类和委托类的关系在编译前就已确定。</li><li><strong>动态代理（Dynamic Proxy）：</strong> 在运行时动态生成代理类，通常使用反射机制实现。JDK 动态代理要求委托类必须实现接口。</li><li><strong>CGLIB 动态代理（CGLIB Dynamic Proxy）：</strong> 使用 CGLIB 字节码操作库在运行时动态生成代理类，可以代理没有实现接口的类。但 CGLIB 不能代理 <code>final</code> 类。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>静态代理是指在程序运行前，代理类的源代码已经存在，并且代理类和委托类的关系在编译前就已确定。</p><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>可以针对具体对象或接口进行代理。</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>每个需要代理的对象都需要编写相应的代理类，代码冗余。</li></ul><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p><strong>需求：</strong> 在不修改 <code>UserDao</code> 类的情况下，为其 <code>save</code> 方法添加事务控制。</p><p><em>委托类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-动态代理（JDK-动态代理）"><a href="#2-动态代理（JDK-动态代理）" class="headerlink" title="2. 动态代理（JDK 动态代理）"></a>2. 动态代理（JDK 动态代理）</h5><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h6><p>动态代理是指在程序运行时动态生成代理类，代理类不是预先存在的。JDK 动态代理使用反射机制实现，要求委托类必须实现接口。</p><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul><li>无需手动编写代理类，可以在运行时动态指定代理对象，减少代码冗余。</li></ul><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul><li>必须面向接口进行代理，目标业务类必须实现接口。</li></ul><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>InvocationHandler 实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">// 下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> userDaoImpl.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-CGLIB-动态代理"><a href="#3-CGLIB-动态代理" class="headerlink" title="3. CGLIB 动态代理"></a>3. CGLIB 动态代理</h5><h6 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h6><p>CGLIB (Code Generation Library) 动态代理利用 ASM 开源包，对代理对象类的 Class 文件加载进来，通过修改其字节码生成子类来处理。</p><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><ul><li>可以直接代理类，不需要实现接口。</li></ul><h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><ul><li>不能代理 <code>final</code> 类。</li><li>需要导入 CGLIB 相关的 jar 包。</li></ul><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CGLIB 动态代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="built_in">this</span>.targetObject = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理实际方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之工厂模式"><a href="#设计模式之工厂模式" class="headerlink" title="设计模式之工厂模式"></a>设计模式之工厂模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，客户端无需关心对象的创建逻辑，而是通过一个共同的接口来获取新创建的对象。工厂模式实现了创建者和调用者的分离，常见的工厂模式分为简单工厂、工厂方法和抽象工厂模式。</p><h4 id="工厂模式的优点"><a href="#工厂模式的优点" class="headerlink" title="工厂模式的优点"></a>工厂模式的优点</h4><ul><li>工厂模式是用工厂方法代替 <code>new</code> 操作的一种模式，是常用的实例化对象模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护和修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制，从而将调用者与实现类解耦。</li></ul><h4 id="为什么要学习工厂设计模式"><a href="#为什么要学习工厂设计模式" class="headerlink" title="为什么要学习工厂设计模式"></a>为什么要学习工厂设计模式</h4><p>如果你想了解或学习许多框架的源码，或者你想自己开发框架，就必须先掌握设计模式，尤其是工厂设计模式，它被广泛应用。例如 Spring、MyBatis 等框架的源码中都大量使用了工厂模式。</p><h4 id="Spring-开发中的工厂设计模式"><a href="#Spring-开发中的工厂设计模式" class="headerlink" title="Spring 开发中的工厂设计模式"></a>Spring 开发中的工厂设计模式</h4><ol><li><strong>Spring IOC</strong><ul><li>Spring IOC 容器创建 Bean 的过程使用了工厂设计模式。</li><li>在 Spring 中，无论是通过 XML 配置、配置类还是注解来创建 Bean，大部分都是通过简单工厂来实现的。</li><li>当容器拿到 Bean 的名称和 Class 类型后，动态地通过反射创建具体的对象，最后将创建的对象放到 Map 中。</li></ul></li><li><strong>为什么 Spring IOC 要使用工厂设计模式创建 Bean 呢？</strong><ul><li>在实际开发中，如果 A 对象调用 B，B 调用 C，C 调用 D，程序的耦合性就会变高（耦合大致分为类与类之间的依赖，方法与方法之间的依赖）。</li><li>Java 的三层架构编程，都是控制层调用业务层，业务层调用数据访问层时，都是直接 <code>new</code> 对象，耦合性大大提升，代码重复量很高，对象满天飞。</li><li>为了避免这种情况，Spring 使用工厂模式编程，创建一个工厂，由工厂创建 Bean，以后需要对象就直接从工厂获取即可。Spring IOC 容器的工厂中有一个静态的 Map 集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到 Map 集合中，保证了实例不会重复影响程序效率。</li></ul></li></ol><h4 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h4><p>工厂模式分为简单工厂、工厂方法和抽象工厂模式。</p><ul><li><strong>简单工厂：</strong> 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</li><li><strong>工厂方法：</strong> 用来生产同一等级结构中的固定产品。（支持拓展增加产品）</li><li><strong>抽象工厂：</strong> 用来生产不同产品族的全部产品。（不支持拓展增加产品，支持增加产品族）</li></ul><h5 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h5><p>简单工厂模式相当于一个工厂中有各种产品，创建在一个类中。客户端无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。<br><strong>代码演示:</strong><br><em>创建工厂接口（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建另外一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建核心工厂类，由它决定具体调用哪个产品</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Milk <span class="title function_">createMilk</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;蒙牛&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;伊利&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> MilkFactory.createMilk(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> MilkFactory.createMilk(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂的优点&#x2F;缺点</strong></p><ul><li><strong>优点：</strong> 简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li><li><strong>缺点：</strong> 工厂类集中了所有实例的创建逻辑，容易违反 <a href="https://blog.csdn.net/u013249965/article/details/51779634" title="CSDN的博主JoJo小风有详细的介绍">GRASPR</a> 的高内聚的责任分配原则。</li></ul><h5 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h5><p>工厂方法模式 Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><p><strong>代码演示:</strong><br><em>创建工厂接口（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口（所有的产品需要 new 出来必须继承它来实现方法）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    Milk <span class="title function_">createMilk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的另一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiuFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLiFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MengNiuFactory</span>().createMilk();</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YiLiFactory</span>().createMilk();</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h5><p><em>这个模式如同它的名字，理解起来很抽象，以下内容也是我根据前辈的思路和自己的理解来总结的。</em><br><strong>抽象工厂模式：</strong></p><ul><li>是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的方式。</li><li>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li><li>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品。</li></ul><blockquote><p>个人理解: 我就以蒙牛举个例子</p><p>把蒙牛比喻成超级工厂</p><p>那么蒙牛的子品牌（特仑苏、纯甄等），就是蒙牛创建的其他工厂</p><p>蒙牛有自己的产品</p><p>特仑苏有自己的产品</p><p>纯甄也有自己的产品</p></blockquote><p>而它们之间的关系，如图所示：<br> <img src="https://i.imgs.ovh/2025/04/23/cq4pU.png" alt="示例图片" title="个人理解，仅供参考"> </p><p> <em><strong>我对这个设计模式理解还比较浅薄，就不展示代码了.</strong></em><br>想详细了解抽象工厂模式的，可以参考以下链接：<br><a href="https://liaoxuefeng.com/books/java/design-patterns/creational/abstract-factory/index.html" title="廖雪峰大佬对抽象工厂的理解">廖雪峰的官方网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>单例模式</strong>是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>单例模式常用于以下场景：</p><ul><li><strong>系统服务：</strong> 像 Windows 的任务管理器和回收站这样的系统服务，通常也使用单例模式，以确保系统中只有一个实例运行。</li><li><strong>线程池：</strong> 多线程环境中的线程池通常使用单例模式，以便于对池中的线程进行统一管理和控制。</li><li><strong>日志：</strong> 应用程序的日志记录器通常使用单例模式，以确保所有日志信息都追加到同一个文件中。</li><li><strong>计数器：</strong> 网站计数器通常使用单例模式实现，以保证同步。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li><strong>唯一实例：</strong> 确保一个类只有一个实例，防止其他对象多次实例化，从而确保所有对象都访问相同的实例。</li><li><strong>可控的实例化过程：</strong> 类可以自己控制实例化过程，从而具有一定的伸缩性。</li><li><strong>受控访问：</strong> 提供对唯一实例的受控访问点。</li><li><strong>节省资源：</strong> 由于系统中只存在一个对象，可以节约系统资源，尤其是在需要频繁创建和销毁对象时，可以提高系统性能。</li><li><strong>允许可变数目的实例：</strong> 在某些变体中，单例模式可以扩展为允许固定数量的实例。</li><li><strong>避免多重占用：</strong> 避免对共享资源的多重占用。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li><strong>不适用于变化的对象：</strong> 如果同一类型的对象需要在不同的用例场景中发生变化，单例模式可能会引起数据错误，因为它无法保存彼此的状态。</li><li><strong>扩展困难：</strong> 由于单例模式中没有抽象层，单例类的扩展比较困难。</li><li><strong>职责过重：</strong> 单例类承担了过多的职责，在一定程度上违背了单一职责原则。</li><li><strong>可能导致资源浪费：</strong> 如果长时间不使用单例实例，可能会被系统回收，导致对象状态丢失。</li><li><strong>隐藏依赖关系：</strong> 单例模式会隐藏组件之间的依赖关系，降低代码的可测试性。</li></ol><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol><li><strong>防止反射攻击：</strong> 需要防止通过反射机制创建新的单例对象，破坏单例模式。</li><li><strong>线程安全：</strong> 在使用懒汉式单例时，需要注意线程安全问题。</li><li><strong>继承限制：</strong> 饿汉式和懒汉式单例的构造方法是私有的，因此不能被继承。某些单例模式（如登记式模式）可以被继承。</li></ol><h4 id="防止反射攻击"><a href="#防止反射攻击" class="headerlink" title="防止反射攻击"></a>防止反射攻击</h4><p>以下代码展示了如何防止通过反射机制破坏单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;有请求破坏单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择单例创建方式"><a href="#如何选择单例创建方式" class="headerlink" title="如何选择单例创建方式"></a>如何选择单例创建方式</h4><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。</li><li>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。最好使用饿汉式。</li></ul><h4 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h4><p>以下是几种常见的单例模式实现方式：</p><ol><li>饿汉式</li><li>懒汉式</li><li>静态内部类</li><li>枚举单例</li><li>双重检测锁（不推荐）</li></ol><h5 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h5><p>在类加载时就创建实例，线程安全，调用效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter1</span> &#123;</span><br><span class="line">    <span class="comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Chapter1</span> <span class="variable">chapter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chapter1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter1构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chapter1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter1</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter1.getInstance();</span><br><span class="line">        <span class="type">Chapter1</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter1.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h5><p>在第一次使用时才创建实例，具有懒加载功能，但需要处理线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter2</span> &#123;</span><br><span class="line">    <span class="comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chapter2 chapter2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter2构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Chapter2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chapter2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            chapter2 = <span class="keyword">new</span> <span class="title class_">Chapter2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chapter2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter2</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter2.getInstance();</span><br><span class="line">        <span class="type">Chapter2</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter2.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h5><p>结合了懒汉式和饿汉式的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter3构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonClassInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Chapter3</span> <span class="variable">CHAPTER_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chapter3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法没有同步</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.CHAPTER_3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter3</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter3.getInstance();</span><br><span class="line">        <span class="type">Chapter3</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter3.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4. 枚举单例"></a>4. 枚举单例</h5><p>实现简单、调用效率高，枚举本身就是单例，由 JVM 从根本上提供保障，避免通过反射和反序列化的漏洞，但没有延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Chapter.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter4</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter4.getInstance();</span><br><span class="line">        <span class="type">Chapter4</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter4.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Chapter</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> Chapter4 chapter4;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Chapter</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;枚举Chapter私有构造参数&quot;</span>);</span><br><span class="line">            chapter4 = <span class="keyword">new</span> <span class="title class_">Chapter4</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Chapter4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> chapter4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-双重检测锁（不推荐）"><a href="#5-双重检测锁（不推荐）" class="headerlink" title="5. 双重检测锁（不推荐）"></a>5. 双重检测锁（不推荐）</h5><p>由于 JVM 本质重排序的原因，可能会初始化多次，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chapter5 chapter5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter4构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chapter5 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Chapter5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chapter5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    chapter5 = <span class="keyword">new</span> <span class="title class_">Chapter5</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chapter5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter5</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter5.getInstance();</span><br><span class="line">        <span class="type">Chapter5</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter5.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h4><p>在实际开发过程中，单例模式最常用的情况是模块与模块之间的解耦。<br>简化示例图：<br><img src="https://i.imgs.ovh/2025/04/22/cUMIb.png" alt="不使用单例模式" title="不使用单例模式"><br><img src="https://i.imgs.ovh/2025/04/22/cUQZ1.png" alt="使用单例模式" title="使用单例模式"><br><em>以上仅限个人看法，其实单例模式还有很多应用场景；只是我是个菜鸟，工作这么久也就这种场景使用过单例模式。</em></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习下设计模式</title>
      <link href="/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近打算面试，了解一下自己是否与时代脱节。在面试过程中，我发现自己对设计模式的认识和理解还不够深入，因此决定重新复习一下。</p><h3 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h3><ul><li>设计模式是一套在软件开发中被反复使用、广为人知、经过分类编目的代码设计经验总结。</li><li>使用设计模式的目的是为了提高代码的可重用性、可读性、可靠性和可维护性。</li></ul><h3 id="2-为什么要学习设计模式"><a href="#2-为什么要学习设计模式" class="headerlink" title="2. 为什么要学习设计模式"></a>2. 为什么要学习设计模式</h3><ul><li><strong>阅读源码：</strong> 理解设计模式是阅读 JDK、Spring、SpringMVC、IO 等源码的基础，否则会感到困惑和难以理解。</li><li><strong>理解现有代码：</strong> 在实际工作中，我们经常会接手现有项目，理解前辈们使用的设计模式对于维护和扩展代码至关重要。</li><li><strong>编写高质量代码：</strong> 使用设计模式可以提高代码的复用性和可扩展性，从而编写出更理想的代码。</li></ul><h3 id="3-设计模式分类"><a href="#3-设计模式分类" class="headerlink" title="3. 设计模式分类"></a>3. 设计模式分类</h3><p> <img src="https://i.imgs.ovh/2025/04/19/jGCmc.png" alt="设计模式分类类"> </p><ul><li><strong>创建型模式 (Creational Patterns)：</strong> 主要关注对象的创建过程，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li><strong>结构型模式 (Structural Patterns)：</strong> 描述如何将类或对象组合成更大的结构，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><strong>行为型模式 (Behavioral Patterns)：</strong> 关注对象之间的交互和职责分配，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h3 id="4-设计模式的六大原则"><a href="#4-设计模式的六大原则" class="headerlink" title="4. 设计模式的六大原则"></a>4. 设计模式的六大原则</h3><p><img src="https://i.imgs.ovh/2025/04/19/jG7P9.png" alt="设计模式的六大原则">  </p><ul><li><p><strong>开放封闭原则 (Open&#x2F;Closed Principle, OCP)</strong></p><ul><li><strong>原则思想：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着尽量通过扩展软件实体的功能来满足新的需求，而不是修改已有的代码。</li><li><strong>描述：</strong> 软件产品在其生命周期内会不断面临变化。为了提高项目的稳定性和灵活性，我们应该在设计时考虑到这些变化，并使系统能够适应它们。</li><li><strong>优点：</strong> 遵循单一职责原则，保证每个类都有明确的职责；符合里氏替换原则，保证继承体系的正确性。</li></ul></li><li><p><strong>里氏代换原则 (Liskov Substitution Principle, LSP)</strong></p><ul><li><strong>原则思想：</strong> 所有引用基类的地方必须能透明地使用其子类的对象。</li><li><strong>概要：</strong> 子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法。</li><li><strong>优点：</strong> 提高程序的健壮性，即使增加了子类，原有子类的功能也能继续运行，互不影响。</li></ul></li><li><p><strong>单一职责原则 (Single Responsibility Principle, SRP)</strong></p><ul><li><strong>原则思想：</strong> 一个类应该只有一个引起它变化的原因。</li><li><strong>描述：</strong> 一个类应该只负责一个职责，当需要修改类的功能时，只应该有一个原因。这有助于降低类之间的耦合度，提高代码的可读性和可维护性。</li><li><strong>优点：</strong> 降低类和类之间的耦合度，提高可读性、可维护性和可扩展性，降低代码变更的风险。</li></ul></li><li><p><strong>依赖倒转原则 (Dependency Inversion Principle, DIP)</strong></p><ul><li>核心思想是面向接口编程，依赖于抽象而不是依赖于具体实现。</li><li>在程序代码中传递参数或建立关联关系时，尽量引用层次高的抽象层类。</li><li>是开放封闭原则的基础。</li></ul></li><li><p><strong>接口隔离原则 (Interface Segregation Principle, ISP)</strong></p><ul><li>使用多个专门的接口比使用单一的总接口要好。</li><li>核心思想是降低类之间的耦合度。</li><li>例如：将支付接口和订单接口拆分为两个独立的接口。</li></ul></li><li><p><strong>迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则 (Principle of Least Knowledge)</strong></p><ul><li>一个对象应当对其他对象有尽可能少的了解，从而降低类与类之间的耦合度。</li><li>一个类应该尽量减少对其他对象的依赖。只有各个模块之间的耦合度降低，才能提高代码的复用率。</li><li>例如：如果一个类只需要调用另一个类的少数几个方法，就应该尽量避免直接引用整个类，而是通过接口或委托等方式进行交互。</li></ul></li></ul><blockquote><p>这里描述的设计模式只是基础，更详细的就不描述了，如果你是一个萌新可以去找一本叫《<strong>大话设计模式</strong>》的书，我之前就是看这本书进行学习的。主要是这里面用故事的方式去描述“设计模式”，比纯理论知识好理解太多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔-企业支付到微信零钱</title>
      <link href="/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/"/>
      <url>/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近企业网站做了个活动，用户在活动期间可以获得积分，积分可以兑换礼品现金红包提现到用户的微信钱包中，在参与开发这个功能时遇到的问题在这里记录下。</p><h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><p><strong>请求体</strong></p><ol><li>请求URL中的参数组装 需要把参数名ASCII字典序排序最后加上<br>key&#x3D;{微信商户平台(pay.weixin.qq.com)-&gt;账户设置-&gt;API安全-&gt;密钥设置}</li><li>请求URL中的参数对应请求体内的XML参数都要有，编码要全部设置为 UTF-8</li><li>请求体内需要添加 <strong>apiclient_cert.p12</strong> 证书</li><li>最终返回结果 成功即为成功，失败需要以下几步操作:<ul><li>查询企业付款 来确认支付结果为失败还是转账中</li><li>若为失败根据失败信息判断以原订单号重新发起请求还是以新的订单号发起请求</li></ul></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p><strong>SIGNERROR 签名错误</strong></p><ul><li>请求时编码要是全部设置为 UTF-8;</li><li>key 传的不正确，key 和 app_id 一定要对的上，如果已经接入过微信支付，要确认这里的传的就是微信支付中用到的 key</li><li>签名的参数和传递给微信的参数不匹配，一般是拼接参数不正确导致的，DEMO 中参数</li></ul><p>已经配置好了，只要不修改参数的个数基本不会有问题;</p><p><strong>NO_AUTH 此 IP 地址不允许调用接口</strong></p><ul><li>新版本商户后台默认需要 IP 校验，有些人填 192.168.1.XXX 这种内网 IP 是不行的，可以<br>访问 ip168 之类的网站获取自己的外网地址；在开发阶段也可以先关掉校验，方便本地调试;</li></ul><p><strong>OPENID_ERROR Openid 错误</strong></p><ul><li>app_id 和 openid 没对上导致的，比如公司同时开通了小程序和微信服务号，两个应用关<br>联了同一个商户，极有可能就是用的小程序 app_id 作为参数，但是传的是微信服务号关联<br>的 openid</li></ul><p><strong>注意项</strong><br>Java需要用到：apiclient_cert.p12证书、证书秘钥、AppId、openId、商品号</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> Java </tag>
            
            <tag> 微信支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown软件推荐-Win系统</title>
      <link href="/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于Hexo是使用Markdown语法编写博客，<br>而在记事本上写Markdown语法是非常麻烦的，主要是预览不到显示效果。<br>win系统上有很多编辑器，我把网上有些热度的编辑器都下载下来使用下，在这里记录下我在使用这些软件的优缺点。</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora可以说是win系统上推荐度最高的Markdown编辑器，搜索首推就是它。<br>当然它也没有辜负大家对他的推荐，<br>功能非常强大，<br>支持实时预览，<br>支持更换主题，<br>支持导出PDF，支持导出Word，还有其他很多格式，<br>最主要是可以全屏编辑，不像有些编辑器左面总是有两个框框，<br>可以说是win系统上最好用的Markdown编辑器；<br>最大的缺点就是需要付费。<br>下面展示两个Typora图片，源码模式和实时预览：<br><img src="https://i.imgs.ovh/2025/04/13/aRi4c.png" alt="源码模式"><br><img src="https://i.imgs.ovh/2025/04/13/aRNk9.png" alt="实时预览"><br>最终贫穷的我还是放弃了Typora。</p><h3 id="微信Markdown编辑器"><a href="#微信Markdown编辑器" class="headerlink" title="微信Markdown编辑器"></a>微信Markdown编辑器</h3><p>应该很多人不是很了解这个，它不是软件而是一个网址可以直接在线编辑Markdown，<br>但是它的功能有限，只能导出html和md格式，支持实时预览，不过是手机端的，如果和我一样只是简单的写博客，记录自己的一时的想法，还是可以的。<br><a href="https://doocs-md.pages.dev/" title="微信Markdown编辑器">微信Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/13/akaHA.png" alt="微信Markdown编辑器"></p><h3 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h3><p>这是也是个网页，功能强大，支持实时预览，有兴趣的可以去看看<br><a href="https://zybuluo.com/mdeditor" title="Cmd Markdown编辑器">Cmd Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPRkr.png" alt="Cmd Markdown编辑器"></p><h3 id="Notable"><a href="#Notable" class="headerlink" title="Notable"></a>Notable</h3><p>这是一款开源的Markdown编辑器，界面还行，就是左面总是有两个框框 不能关闭！<br>不支持实时预览，不过能预览就是要点击上面的Edit按钮，所以在编辑md文件的时候总是去点击Edit按钮，比较麻烦。最终让我放弃的原因是它的功能栏是英文的，不能切换中文。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aMmf4.png" alt="Notable编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aMueA.png" alt="Notable预览模式"></p><h3 id="MarkText"><a href="#MarkText" class="headerlink" title="MarkText"></a>MarkText</h3><p>这也是一个开源的Markdown编辑器，界面不错，不过我看GitHub上已经很久没有更新了，<br>下载的时候找到了个MarkText中文特别版，默认界面很像Typora，如果不习惯全屏的也可以打开侧边栏，功能很多，日常使用完全足够了。<br>这个编辑器不支持实时预览，预览界面可以用Ctrl+E快捷键打开。Typora最好的替代工具。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPVsL.png" alt="MarkText编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aPbKx.png" alt="MarkText预览模式"></p><h3 id="Zettlr"><a href="#Zettlr" class="headerlink" title="Zettlr"></a>Zettlr</h3><p>这个编辑器让我一言难尽啊，它很强大、很专业。<br>功能很多，但我只是想要一个简单的Markdown编辑器，够日常使用就行。<br>有兴趣的可以去看看<br><a href="https://www.zettlr.com/" title="Zettlr官网">Zettlr官网</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPQkH.png" alt="Zettlr"></p><h3 id="最后强烈推荐一个编辑器"><a href="#最后强烈推荐一个编辑器" class="headerlink" title="最后强烈推荐一个编辑器"></a>最后强烈推荐一个编辑器</h3><p><strong>没错！就是它！ VSCode！</strong><br>VSCode是微软推出的一款代码编辑器，支持多种语言，包括Markdown。<br>只需要安装Markdown插件，就可以在VSCode中编辑Markdown文件了。<br>下面我推荐三个插件：</p><blockquote><p>Markdown All in One</p></blockquote><p>在VSCode编辑Markdown文件就靠它</p><blockquote><p>Markdown Preview Enhanced</p></blockquote><p>将原生markdown预览的黑色背景改为白色</p><blockquote><p>Markdown Preview Github Styling</p></blockquote><p>将原生markdown预览的样式改为Github的样式<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPuBb.png" alt="VSCode MD文档编辑页面"></p><h3 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h3><p>还有其他很多Markdown编辑器，比如：</p><blockquote><p>Simplenote<br>Boostnote<br>Inkdrop<br>Yu Writer<br>MarkdownPad</p></blockquote><p>这些编辑器我都没有使用过，有兴趣的可以去试试。<br>好了，这就是我在win系统上使用的Markdown编辑器了，<br>希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> Markdown </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Markdown语法</title>
      <link href="/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的使用和Markdown基础语法"><a href="#Hexo的使用和Markdown基础语法" class="headerlink" title="Hexo的使用和Markdown基础语法"></a>Hexo的使用和Markdown基础语法</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo是一个快速、简洁且高效的博客框架，使用Markdown解析文章。markdown是一种轻量级标记语言（在百度百科上抄下来的），总之，就是一种格式，方便写者排版，在Hexo中，markdown是用来写文章的。所以，在写文章之前，你需要先了解一下markdown的基础语法。</p><h3 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h3><blockquote><p>记录学习下markdown的基础语法：</p></blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><ul><li>1️⃣ <strong>一级标题</strong>：<code># 标题内容</code>  </li><li>2️⃣ <strong>二级标题</strong>：<code>## 标题内容</code>  </li><li>3️⃣ <strong>三级标题</strong>：<code>### 标题内容</code></li></ul><p>以此类推，最多六级标题。标题前面的井号数量表示标题级别，井号后面要加一个空格。</p><h3 id="二、文字格式"><a href="#二、文字格式" class="headerlink" title="二、文字格式"></a>二、文字格式</h3><ul><li><code>**加粗的文字**</code> 或者 <code>__加粗的文字__</code>：<strong>加粗字</strong>  </li><li><code>*斜体的文字*</code> 或者 <code>_斜体的文字_</code>：<em>斜体字</em>  </li><li><code>***加粗且斜体的文字***</code> 或者 <code>___加粗且斜体的文字___</code>：<em><strong>加粗斜体字</strong></em>  </li><li><code>~~删除的文字~~</code>：<del>删除线</del></li></ul><p>这些格式可以让文字更加醒目，突出重点。</p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>使用<code>-</code>、<code>*</code>或<code>+</code>作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>- 列表项1 </code><br><code>- 列表项2</code><br><code>- 列表项3</code></p><p>显示效果：</p><ul><li>列表项1</li><li>列表项1</li><li>列表项1</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ul><li>使用数字加点作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>1. 列表项1 </code><br><code>2. 列表项2</code><br><code>3. 列表项3</code></p><p>显示效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h3><ul><li><strong>普通链接</strong>：<code>[链接描述](链接地址)</code><br>示例：<code>[百度一下](https://www.baidu.com)</code><br>显示效果：<a href="https://www.baidu.com/">百度一下</a>  </li><li><strong>带标题的链接</strong>：<code>[链接描述](链接地址 &quot;标题&quot;)</code><br>示例：<code>[百度一下](https://www.baidu.com &quot;百度首页&quot;)</code><br>显示效果：<a href="https://www.baidu.com/" title="百度首页">百度一下</a></li></ul><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><ul><li><strong>插入图片</strong>：<code>![图片描述](图片链接)</code><br>示例：<code>![示例图片](https://i.imgs.ovh/2025/04/13/aAO0p.jpeg)</code><br>显示效果：<br><img src="https://i.imgs.ovh/2025/04/13/aAO0p.jpeg" alt="示例图片"><br>图片描述会显示在图片无法加载时。</li></ul><h2 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h2><ul><li>使用<code>&gt;</code>来表示引用。<br>示例：<code>&gt; 这是一段引用的文字</code><br>显示效果：  <blockquote><p>这是一段引用的文字</p></blockquote></li></ul><h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><h3 id="（一）行内代码"><a href="#（一）行内代码" class="headerlink" title="（一）行内代码"></a>（一）行内代码</h3><ul><li>使用反引号<code>`</code>来标记。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这里是一段`</span>代码   </span><br></pre></td></tr></table></figure>显示效果：<br><code>这里是一段</code>代码</li></ul><h3 id="（二）代码块"><a href="#（二）代码块" class="headerlink" title="（二）代码块"></a>（二）代码块</h3><ul><li>使用三个反引号&#96;&#96;&#96;来标记代码块。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="code">```python</span></span><br><span class="line"><span class="code">$ print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="code">$ ```</span></span><br></pre></td></tr></table></figure><blockquote><p>$号是为了不让代码块被解析为Markdown的转义字符。</p></blockquote>显示效果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>• 使用<code>|</code>来分隔列，<code>-</code>来分隔表头和内容。<br>  示例：<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|列1|列2|列3|</span><br><span class="line">|---|---|---|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><h2 id="九、分割线"><a href="#九、分割线" class="headerlink" title="九、分割线"></a>九、分割线</h2><p>• 使用三个或更多<code>---</code>、<code>***</code>或<code>___</code>来创建分割线。</p><p>示例：<code>---</code>或<code>***</code>或<code>___</code></p><p>显示效果：</p><hr><p>或</p><hr><p>或</p><hr><h2 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h2><ul><li>使用<code>- [ ]</code>表示未完成的任务，<code>- [x]</code>表示已完成的任务。<br>示例：  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务1</span><br><span class="line"><span class="bullet">-</span> [x] 任务2</span><br></pre></td></tr></table></figure>显示效果：<ul><li><input disabled="" type="checkbox"> 任务1</li><li><input checked="" disabled="" type="checkbox"> 任务2</li></ul></li></ul><h2 id="十一、表情符号"><a href="#十一、表情符号" class="headerlink" title="十一、表情符号"></a>十一、表情符号</h2><ul><li>Markdown支持使用表情符号的短代码。<br>示例：<code>:smile:</code><br>显示效果：😄</li></ul><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><ul><li>换行：在行尾添加两个空格即可换行。</li><li>转义字符：使用<code>\</code>来转义特殊字符，比如<code>\*</code>会显示为<code>*</code>。</li></ul><hr><h4 id="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"><a href="#以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪" class="headerlink" title="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"></a>以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪</h4><blockquote><p>最后，Markdown语法还有很多，只是大多不是我常用的，这里就不记录，如果有兴趣的可以去学习一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题-Solitude</title>
      <link href="/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/"/>
      <url>/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/</url>
      
        <content type="html"><![CDATA[<p>第一次使用Hexo，安装了主题Solitude，记录一下安装过程。<br>首先Solitude主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器。</p><h3 id="在根目录下执行以下命令："><a href="#在根目录下执行以下命令：" class="headerlink" title="在根目录下执行以下命令："></a>在根目录下执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>有两种安装方法一种是使用git直接下载主题，一种是使用npm下载主题。<br>我是用npm下载的。所以这里记录的是npm下载的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-solitude</span><br></pre></td></tr></table></figure><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改Hexo配置文件_config.yml，将主题设置为Solitude。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: solitude</span><br></pre></td></tr></table></figure><h3 id="测试主题是否应用成功"><a href="#测试主题是否应用成功" class="headerlink" title="测试主题是否应用成功"></a>测试主题是否应用成功</h3><p>根据Hexo官方文档，我们可以使用以下命令来测试主题是否应用成功：</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="访问本地服务器"><a href="#访问本地服务器" class="headerlink" title="访问本地服务器"></a>访问本地服务器</h3><p>在浏览器中输入一下网址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http://localhost:4000/</span><br></pre></td></tr></table></figure><p>如果看到了Solitude主题的页面，说明主题应用成功。<br>但是这个页面默认是英文的，我们可以修改配置文件_config.yml，将语言设置为中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><p>然后重新生成静态文件，启动本地服务器，访问本地服务器，就可以看到Solitude主题的中文页面了。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>Solitude主题的配置文件是_config.solitude.yml，默认是不存在的需要我们拷贝到根目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ copy .\node_modules\hexo-theme-solitude\_config.yml .\_config.solitude.yml</span><br></pre></td></tr></table></figure><p>_config.solitude.yml配置文件优先级高于_config.yml，所以得在_config.solitude.yml中配置主题。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello-Hexo</title>
      <link href="/2025/04/06/Hello-Hexo/"/>
      <url>/2025/04/06/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>！这是部署的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a> 以获取更多信息。<br>如果在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，或者在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上进行提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个新博客"><a href="#创建一个新博客" class="headerlink" title="创建一个新博客"></a>创建一个新博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名称&quot;</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">写作</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="清除静态文件和缓存文件"><a href="#清除静态文件和缓存文件" class="headerlink" title="清除静态文件和缓存文件"></a>清除静态文件和缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
