<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-装饰器模式</title>
      <link href="/2025/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之装饰器模式"><a href="#设计模式之装饰器模式" class="headerlink" title="设计模式之装饰器模式"></a>设计模式之装饰器模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>装饰器模式</strong>是一种<strong>结构型设计模式</strong>，它允许在<strong>不改变</strong>现有对象结构的前提下，<strong>动态地</strong>给对象添加额外的职责。 这种模式创建了一个装饰器类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供额外的功能。 装饰器模式利用<strong>组合</strong>而非继承的方式， 具有比继承更加灵活性的特点，可以有效地避免类爆炸的问题。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>动态扩展功能：</strong> 在运行时动态地给对象增加额外的职责。</li><li><strong>避免继承的复杂性：</strong> 需要给一个现有的类增加职责，但是又不想通过继承的方式来实现的时候（应该优先使用组合而非继承），或者通过继承的方式不现实的时候（可能由于排列组合产生类爆炸的问题）。</li><li><strong>保持接口一致性：</strong>  确保装饰后的对象和原始对象具有相同的接口，客户端可以以一致的方式对待它们。</li><li><strong>灵活组合：</strong>  允许以不同的顺序和组合方式应用多个装饰器。</li></ul><h4 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h4><ul><li>需要在运行时动态地给对象增加额外的职责，而不能通过继承来实现。</li><li>需要给一个类增加的职责有很多，而且这些职责是可以动态组合的。</li><li>需要避免因为职责的增加而导致类的数量剧增（“类爆炸”）。</li><li>当不能使用继承的时候，使用装饰模式。</li></ul><h4 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h4><p><strong>优点：</strong></p><ul><li><strong>灵活性：</strong> 可以在运行时动态地添加或删除职责，而无需修改原始类。</li><li><strong>扩展性：</strong> 可以很容易地添加新的装饰器，扩展对象的功能。</li><li><strong>避免继承：</strong> 通过组合而非继承的方式扩展功能，避免了继承带来的类爆炸问题。</li><li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性增加：</strong>  使用装饰器模式可能会导致类的数量增加，使得系统更加复杂。</li><li><strong>调试困难：</strong>  由于使用了多层包装，可能会增加调试的难度。</li><li><strong>装饰器的顺序很重要：</strong>  不同的装饰器顺序可能会导致不同的结果。</li><li><strong>可能产生大量细小对象：</strong> 过度使用装饰器可能会导致系统中存在大量细小对象，影响性能。</li></ul><h4 id="5-模式结构"><a href="#5-模式结构" class="headerlink" title="5. 模式结构"></a>5. 模式结构</h4><p>装饰器模式主要包含以下角色：</p><ul><li><strong>组件 (Component)：</strong><ul><li>定义一个对象接口，可以给这些对象动态地添加职责。</li></ul></li><li><strong>具体组件 (Concrete Component)：</strong><ul><li>实现组件接口。</li><li>定义了具体的对象，也就是被装饰器装饰的对象。</li></ul></li><li><strong>装饰器 (Decorator)：</strong><ul><li>持有一个组件对象的实例，并定义一个与组件接口一致的接口。</li><li>负责给组件添加额外的职责。</li></ul></li><li><strong>具体装饰器 (Concrete Decorator)：</strong><ul><li>实现装饰器接口，负责给组件添加具体的职责。</li></ul></li></ul><h4 id="6-代码示例"><a href="#6-代码示例" class="headerlink" title="6. 代码示例"></a>6. 代码示例</h4><p><strong>场景：</strong><br>假设你正在开发一个咖啡店的订单系统。 你有不同种类的咖啡（例如，浓缩咖啡、美式咖啡），并且你想要允许顾客添加各种调料（例如，牛奶、摩卡、奶油）来定制他们的咖啡。 使用装饰器模式，你可以在运行时动态地组合这些调料，而无需修改咖啡类的代码。</p><p><strong>1. 咖啡接口 (Component Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 咖啡接口，定义了咖啡的基本行为（描述和价格）</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 具体咖啡类 (Concrete Component)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体咖啡类，实现了 Coffee 接口，表示具体的咖啡种类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;浓缩咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2.49</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 调料装饰器抽象类 (Decorator Abstract Class)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料装饰器抽象类，实现了 Coffee 接口，并持有一个 Coffee 对象的引用</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Coffee coffee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeDecorator</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription(); <span class="comment">// 默认行为：委托给被装饰的咖啡对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost(); <span class="comment">// 默认行为：委托给被装饰的咖啡对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体调料装饰器类 (Concrete Decorator)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体调料装饰器类，继承了 CoffeeDecorator 类，并添加了额外的行为（描述和价格）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 牛奶&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">0.50</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mocha</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mocha</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 摩卡&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">0.75</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Whip</span> <span class="keyword">extends</span> <span class="title class_">CoffeeDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Whip</span><span class="params">(Coffee coffee)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getDescription() + <span class="string">&quot;, 奶油&quot;</span>; <span class="comment">// 添加调料的描述</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCost() + <span class="number">1.00</span>; <span class="comment">// 添加调料的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一杯浓缩咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">espresso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">        System.out.println(espresso.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + espresso.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用牛奶和摩卡装饰浓缩咖啡</span></span><br><span class="line">        espresso = <span class="keyword">new</span> <span class="title class_">Milk</span>(espresso);</span><br><span class="line">        espresso = <span class="keyword">new</span> <span class="title class_">Mocha</span>(espresso);</span><br><span class="line">        System.out.println(espresso.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + espresso.getCost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一杯美式咖啡，并用奶油装饰</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">americano</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">        americano = <span class="keyword">new</span> <span class="title class_">Whip</span>(americano);</span><br><span class="line">        System.out.println(americano.getDescription() + <span class="string">&quot; 价格: $&quot;</span> + americano.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-代码解释"><a href="#7-代码解释" class="headerlink" title="7. 代码解释"></a>7. 代码解释</h4><ul><li><strong><code>Coffee</code> 接口：</strong> 定义了 <code>getDescription()</code> 和 <code>getCost()</code> 方法，表示咖啡的基本行为。 这就是<strong>组件 (Component)</strong>.</li><li><strong><code>Espresso</code> 和 <code>Americano</code> 类：</strong> 实现了 <code>Coffee</code> 接口，表示具体的咖啡种类. 这就是<strong>具体组件 (Concrete Component)</strong>.</li><li><strong><code>CoffeeDecorator</code> 抽象类：</strong> 实现了 <code>Coffee</code> 接口，并持有一个 <code>Coffee</code> 对象的引用。 它是所有调料装饰器的基类。 这就是<strong>装饰器 (Decorator)</strong>.</li><li><strong><code>Milk</code>, <code>Mocha</code>, <code>Whip</code> 类：</strong> 继承了 <code>CoffeeDecorator</code> 类，并添加了额外的行为（描述和价格），表示具体的调料. 这就是<strong>具体装饰器 (Concrete Decorator)</strong>.</li><li><strong><code>DecoratorPatternDemo</code> 类：</strong> 客户端代码，演示了如何创建咖啡对象，并使用调料装饰器动态地组合调料。</li></ul><h4 id="8-运行结果"><a href="#8-运行结果" class="headerlink" title="8. 运行结果"></a>8. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浓缩咖啡 价格: $1.99</span><br><span class="line">浓缩咖啡, 牛奶, 摩卡 价格: $3.24</span><br><span class="line">美式咖啡, 奶油 价格: $3.49</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>装饰器模式是一种强大的设计模式，它允许你在运行时动态地扩展对象的功能，而无需修改对象的代码。 它通过组合而非继承的方式，提供了比继承更加灵活的扩展方式，并且符合开闭原则。 在实际应用中，需要注意装饰器的顺序，以及避免过度使用装饰器导致系统复杂性增加。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2025/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之观察者模式"><a href="#设计模式之观察者模式" class="headerlink" title="设计模式之观察者模式"></a>设计模式之观察者模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>观察者模式是一种<strong>行为型设计模式</strong>，也被称为<strong>发布-订阅模式</strong>。它定义了一种<strong>一对多</strong>的依赖关系，允许一个对象（<strong>主题</strong>）在状态改变时通知多个依赖它的对象（<strong>观察者</strong>），而无需知道观察者的具体类型。 观察者模式主要用于构建<strong>松耦合</strong>的系统，其中一个对象状态的改变需要通知其他对象，但又希望避免对象间的紧密依赖关系。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>建立依赖关系：</strong> 定义主题和观察者之间的一对多依赖关系。</li><li><strong>状态同步：</strong> 当主题状态改变时，自动通知所有注册的观察者。</li><li><strong>松耦合：</strong> 解耦主题和观察者，使得它们可以独立变化。</li><li><strong>事件驱动：</strong> 支持事件驱动的系统架构，主题作为事件源，观察者作为事件处理者。</li></ul><h4 id="3-观察者模式的职责"><a href="#3-观察者模式的职责" class="headerlink" title="3. 观察者模式的职责"></a>3. 观察者模式的职责</h4><p>观察者模式的核心职责是实现<strong>一对多的通知机制</strong>。当一个对象的状态发生变化时，需要及时通知一系列相关的对象，使它们能够做出相应的响应。</p><p><strong>实现方式 (通知策略)：</strong></p><ul><li><strong>推 (Push) 模式：</strong> 主题将状态变化的详细信息（例如，所有相关数据）以广播的方式推送给所有观察者。 观察者被动接收这些信息，并根据需要进行处理。 优点是观察者无需主动请求数据，缺点是可能推送过多无用信息。</li><li><strong>拉 (Pull) 模式：</strong> 主题只通知观察者状态发生了改变，观察者需要主动向主题请求获取最新的状态信息。 优点是观察者可以按需获取数据，缺点是需要额外的请求操作。</li></ul><h4 id="4-模式结构"><a href="#4-模式结构" class="headerlink" title="4. 模式结构"></a>4. 模式结构</h4><p>观察者模式涉及以下角色：</p><ul><li><strong>主题 (Subject)：</strong><ul><li>维护一个观察者列表。</li><li>提供注册 (registerObserver)、移除 (removeObserver) 观察者的方法。</li><li>在状态改变时，通知 (notifyObservers) 所有注册的观察者。</li></ul></li><li><strong>观察者 (Observer)：</strong><ul><li>定义一个 <code>update()</code> 方法，用于接收主题的通知并更新自身状态。</li></ul></li><li><strong>具体主题 (Concrete Subject)：</strong><ul><li>实现主题接口，存储主题的内部状态。</li><li>在状态改变时，调用 <code>notifyObservers()</code> 方法通知所有观察者。</li></ul></li><li><strong>具体观察者 (Concrete Observer)：</strong><ul><li>实现观察者接口，接收主题的通知并更新自身状态。</li><li>可以持有具体主题的引用，以便在需要时获取主题的更多信息（拉模式）。</li></ul></li><li><strong>客户端 (Client):</strong> 创建主题对象和观察者对象，并建立它们之间的联系。</li></ul><h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><ul><li>当一个对象的状态改变需要通知其他对象，而你希望避免对象间的紧密耦合。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面。 将这两者封装在独立的对象中，使它们可以独立地改变和复用。</li><li>在分布式系统中，实现跨系统的消息交换，例如消息队列、事件总线等。</li><li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。</li></ul><h4 id="6-模式优点"><a href="#6-模式优点" class="headerlink" title="6. 模式优点"></a>6. 模式优点</h4><ul><li><strong>松耦合：</strong> 主题和观察者之间是松散耦合的，可以独立地改变和复用。</li><li><strong>可扩展性：</strong> 可以很容易地添加新的观察者，而无需修改主题的代码。</li><li><strong>灵活性：</strong> 支持不同的通知策略（推、拉），可以根据具体需求选择合适的策略。</li><li><strong>支持广播通信：</strong> 主题可以同时通知多个观察者。</li></ul><h4 id="7-模式缺点"><a href="#7-模式缺点" class="headerlink" title="7. 模式缺点"></a>7. 模式缺点</h4><ul><li><strong>可能产生无效更新：</strong> 如果观察者不关心主题的某个状态变化，仍然会收到通知，造成性能浪费（推模式）。</li><li><strong>观察者难以跟踪主题的变化：</strong> 观察者可能不知道是什么原因导致了主题的状态变化，难以进行调试和维护。</li><li><strong>可能导致循环依赖：</strong> 如果主题和观察者之间存在循环依赖关系，可能导致系统崩溃。</li></ul><h4 id="8-示例代码-推模式"><a href="#8-示例代码-推模式" class="headerlink" title="8. 示例代码 (推模式)"></a>8. 示例代码 (推模式)</h4><p><strong>场景：</strong></p><p>假设你正在开发一个天气预报系统。 有一个 <code>WeatherData</code> 类负责获取天气数据（温度、湿度、气压），然后你需要将这些数据推送给多个订阅者（观察者），例如显示当前天气信息的显示器、记录天气数据的日志系统等。</p><p><strong>1. 主题接口 (Subject Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题接口，定义了注册、移除和通知观察者的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 观察者接口 (Observer Interface)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口，定义了接收更新的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 具体主题类 (Concrete Subject)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体主题类，实现了 Subject 接口，维护了观察者列表，并在状态改变时通知观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当天气数据改变时，调用此方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置天气数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged(); <span class="comment">// 数据改变后，通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 具体观察者类 (Concrete Observer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体观察者类，实现了 Observer 接口，接收主题的状态更新并进行相应的处理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>); <span class="comment">// 注册到主题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前气象：温度 &quot;</span> + temperature + <span class="string">&quot; 度，湿度 &quot;</span> + humidity + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObserverPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建主题对象</span></span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建观察者对象</span></span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>(weatherData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置天气数据，主题会通知观察者</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">25</span>, <span class="number">60</span>, <span class="number">1013</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">26</span>, <span class="number">65</span>, <span class="number">1012</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除观察者</span></span><br><span class="line">        weatherData.removeObserver(currentDisplay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次设置天气数据，观察者不会收到通知</span></span><br><span class="line">        weatherData.setMeasurements(<span class="number">27</span>, <span class="number">70</span>, <span class="number">1011</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-代码解释"><a href="#9-代码解释" class="headerlink" title="9. 代码解释"></a>9. 代码解释</h4><ul><li><strong><code>Subject</code> 接口：</strong> 定义了 <code>registerObserver()</code>, <code>removeObserver()</code>, <code>notifyObservers()</code> 方法，用于管理观察者。</li><li><strong><code>Observer</code> 接口：</strong> 定义了 <code>update()</code> 方法，观察者通过此方法接收主题的更新。</li><li><strong><code>WeatherData</code> 类：</strong>  实现了 <code>Subject</code> 接口，维护了观察者列表。 当天气数据发生改变时 ( <code>setMeasurements()</code> 方法)，调用 <code>notifyObservers()</code> 方法通知所有已注册的观察者。</li><li><strong><code>CurrentConditionsDisplay</code> 类：</strong> 实现了 <code>Observer</code> 接口，接收 <code>WeatherData</code> 的更新，并显示当前天气信息。</li><li><strong><code>ObserverPatternDemo</code> 类：</strong> 客户端代码，演示了如何创建主题和观察者，以及如何注册、移除和通知观察者。</li></ul><h4 id="10-运行结果"><a href="#10-运行结果" class="headerlink" title="10. 运行结果"></a>10. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前气象：温度 25.0 度，湿度 60.0%</span><br><span class="line">当前气象：温度 26.0 度，湿度 65.0%</span><br></pre></td></tr></table></figure><h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h4><p>观察者模式是一种非常有用的设计模式，可以用于构建松耦合、可扩展的系统。 通过将主题和观察者解耦，可以使它们独立地变化，从而提高系统的灵活性和可维护性。 在实际应用中，需要根据具体的需求选择合适的通知策略，并注意避免可能出现的循环依赖问题。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配者模式</title>
      <link href="/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>适配器模式是一种<strong>结构型设计模式</strong>，它允许<strong>将一个类的接口转换成客户端所期望的另一种接口</strong>，从而使原本接口不兼容而无法一起工作的类能够协同工作。 适配器模式通过创建一个适配器类，充当两者之间的桥梁，实现了接口的转换和兼容.</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>接口转换：</strong> 将现有类的接口转换为客户端需要的接口。</li><li><strong>系统兼容：</strong> 解决接口不兼容问题，使得不同接口的类可以协同工作。</li><li><strong>代码复用：</strong> 复用现有类，避免修改源代码。</li><li><strong>透明适配：</strong> 对客户端隐藏适配过程，客户端无需关心适配器的存在。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>适配器模式涉及以下角色：</p><ul><li><strong>目标接口 (Target):</strong> 定义客户端期望使用的接口，也是客户端所依赖的接口。</li><li><strong>适配者 (Adaptee):</strong> 现有需要被适配的类，其接口与目标接口不兼容。</li><li><strong>适配器 (Adapter):</strong> 核心组件，实现目标接口，并持有适配者类的实例，将适配者类的接口转换为目标接口。</li><li><strong>客户端 (Client):</strong> 通过目标接口使用适配器，无需关心适配者类的具体实现。</li></ul><h4 id="4-适配器模式的两种实现方式"><a href="#4-适配器模式的两种实现方式" class="headerlink" title="4. 适配器模式的两种实现方式"></a>4. 适配器模式的两种实现方式</h4><p>在 Java 中，适配器模式通常分为两种类型：<strong>类适配器</strong>和<strong>对象适配器</strong>。对象适配器是更常用的方式，因为它更灵活。<br><strong>4.1 类适配器 (Class Adapter)</strong></p><ul><li><strong>实现方式：</strong> 通过<strong>多重继承</strong>实现。 适配器类同时<strong>继承目标类</strong>和<strong>适配者类</strong>。</li><li><strong>工作原理：</strong> 适配器类继承目标类，从而可以作为目标类型使用；同时继承适配者类，从而可以访问适配者的功能。</li><li><strong>优缺点：</strong><ul><li><em>优点：</em> 实现简单，可以直接使用适配者的方法。</li><li><em>缺点：</em> 只能适配类，不能适配对象；Java 不支持多重类继承，因此存在局限性，实际应用较少。<br><strong>4.2 对象适配器 (Object Adapter)</strong></li></ul></li><li><strong>实现方式：</strong> 通过<strong>组合</strong>实现。 适配器类持有一个<strong>适配者类的实例</strong>，并<strong>实现目标接口</strong>。</li><li><strong>工作原理：</strong> 适配器类实现目标接口，并调用适配者类的实例的方法，从而将适配者的功能适配到目标接口。</li><li><strong>优缺点：</strong><ul><li><em>优点：</em> 可以适配对象，更加灵活；可以使用接口或抽象类作为目标接口，扩展性更好。</li><li><em>缺点：</em> 相比类适配器，实现稍复杂，需要维护一个适配者实例。</li></ul></li></ul><h4 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h4><ul><li>系统需要使用现有的类，但该类的接口与系统的接口不兼容。</li><li>需要创建一个可复用的类，使其能够与不相关的类或不可预见的类协同工作。</li><li>需要统一多个类的接口，将其转换为统一的接口。</li><li>希望在不修改源代码的情况下，使用某个类的功能。</li></ul><h4 id="6-模式优点"><a href="#6-模式优点" class="headerlink" title="6. 模式优点"></a>6. 模式优点</h4><ul><li><strong>提高类的复用性：</strong> 适配器模式允许使用现有的类，即使它们的接口不兼容。</li><li><strong>提高灵活性：</strong> 可以根据需要创建多个适配器，以满足不同的接口需求。</li><li><strong>符合开闭原则：</strong> 可以在不修改现有代码的情况下引入新的适配器。</li><li><strong>解耦合：</strong> 将客户端与适配者解耦，降低系统依赖性。</li></ul><h4 id="7-模式缺点"><a href="#7-模式缺点" class="headerlink" title="7. 模式缺点"></a>7. 模式缺点</h4><ul><li><strong>增加代码复杂性：</strong> 适配器模式可能会增加代码的复杂性，特别是当适配器链很长时。</li><li><strong>过度使用：</strong> 过度使用适配器模式可能会导致系统难以理解和维护。 需要谨慎使用，避免不必要的适配。</li></ul><h4 id="8-示例代码"><a href="#8-示例代码" class="headerlink" title="8. 示例代码"></a>8. 示例代码</h4><p><em>这里只对“对象适配器”进行演示，因为在Java开发过程中“类适配器”几乎用不到。</em><br><strong>场景：</strong><br>假设你有一个旧的音频播放器接口 <code>LegacyMediaPlayer</code>，它只能播放 <code>MP3</code> 格式的音频文件。 现在你想要让它也能播放 <code>MP4</code> 格式的音频文件，但是你不能修改 <code>LegacyMediaPlayer</code> 接口。 这时，你可以使用适配器模式来解决这个问题。</p><p><strong>1. 旧的音频播放器接口 (Legacy MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的音频播放器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">LegacyMediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">playMP3</span><span class="params">(String filename)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 旧的音频播放器实现类 (Concrete Legacy MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧的音频播放器实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LegacyMP3Player</span> <span class="keyword">implements</span> <span class="title class_">LegacyMediaPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMP3</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在播放 MP3 文件: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 新的音频播放器接口 (New MediaPlayer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的音频播放器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String filename, String fileType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 新的 MP4 音频播放器 (Adaptee)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的 MP4 音频播放器 (Adaptee)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MP4Player</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMP4</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在播放 MP4 文件: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 适配器类 (Adapter)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 适配器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MediaAdapter</span> <span class="keyword">implements</span> <span class="title class_">MediaPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MP4Player mp4Player;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MediaAdapter</span><span class="params">(MP4Player mp4Player)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mp4Player = mp4Player;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String filename, String fileType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileType.equalsIgnoreCase(<span class="string">&quot;mp4&quot;</span>)) &#123;</span><br><span class="line">            mp4Player.playMP4(filename);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持的音频格式: &quot;</span> + fileType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 客户端 (Client)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建旧的 MP3 播放器</span></span><br><span class="line">        <span class="type">LegacyMediaPlayer</span> <span class="variable">mp3Player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LegacyMP3Player</span>();</span><br><span class="line">        mp3Player.playMP3(<span class="string">&quot;old_song.mp3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 MP4 播放器</span></span><br><span class="line">        <span class="type">MP4Player</span> <span class="variable">mp4Player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MP4Player</span>();</span><br><span class="line">        <span class="comment">// 创建适配器</span></span><br><span class="line">        <span class="type">MediaPlayer</span> <span class="variable">mediaAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaAdapter</span>(mp4Player);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用适配器播放 MP4 文件</span></span><br><span class="line">        mediaAdapter.play(<span class="string">&quot;new_song.mp4&quot;</span>, <span class="string">&quot;mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试播放其他格式的文件</span></span><br><span class="line">        mediaAdapter.play(<span class="string">&quot;another_song.avi&quot;</span>, <span class="string">&quot;avi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ul><li><strong>LegacyMediaPlayer 接口：</strong> 旧的 MP3 播放器接口，只能播放 MP3 文件。</li><li><strong>LegacyMP3Player 类：</strong> 实现了 <code>LegacyMediaPlayer</code> 接口，播放 MP3 文件。</li><li><strong>MediaPlayer 接口：</strong> 新的音频播放器接口，可以播放多种格式的文件。</li><li><strong>MP4Player 类：</strong> 新的 MP4 播放器，可以播放 MP4 文件。</li><li><strong>MediaAdapter 类：</strong> 适配器类，实现了 <code>MediaPlayer</code> 接口，并持有 <code>MP4Player</code> 的实例。 当需要播放 MP4 文件时，适配器调用 <code>MP4Player</code> 的 <code>playMP4()</code> 方法，从而将 <code>MP4Player</code> 适配到 <code>MediaPlayer</code> 接口。</li><li><strong>AdapterPatternDemo 类：</strong> 客户端代码，演示了如何使用适配器来播放 MP4 文件。</li></ul><h4 id="9-运行结果"><a href="#9-运行结果" class="headerlink" title="9. 运行结果"></a>9. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正在播放 MP3 文件: old_song.mp3</span><br><span class="line">正在播放 MP4 文件: new_song.mp4</span><br><span class="line">不支持的音频格式: avi</span><br></pre></td></tr></table></figure><h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h4><p>适配器模式通过将一个类的接口转换成客户端所期望的另一种接口，实现了接口的兼容和复用。 对象适配器是更常用的实现方式，因为它更灵活，可以适配对象，并且可以使用接口或抽象类作为目标接口。 在选择使用适配器模式时，需要权衡其优点和缺点，并根据具体的应用场景进行选择。 避免过度使用，保持代码的简洁和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 适配者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之策略模式"><a href="#设计模式之策略模式" class="headerlink" title="设计模式之策略模式"></a>设计模式之策略模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>策略模式是一种<strong>行为型设计模式</strong>，它定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。 策略模式让算法独立于使用它的客户而变化，使得可以在运行时动态地选择算法。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>封装算法：</strong> 将不同的算法封装到独立的类中。</li><li><strong>算法可互换：</strong> 使算法可以相互替换，而不会影响客户端代码。</li><li><strong>运行时选择：</strong> 允许在运行时选择不同的算法。</li><li><strong>解耦合：</strong> 将算法与使用算法的客户端代码解耦。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>策略模式主要包含以下角色：</p><ul><li><strong>策略接口 (Strategy):</strong><ul><li>定义算法的接口，所有具体的策略类都必须实现该接口。</li></ul></li><li><strong>具体策略类 (Concrete Strategy):</strong><ul><li>实现策略接口，封装具体的算法。</li></ul></li><li><strong>环境类 (Context):</strong><ul><li>持有一个策略接口的引用。</li><li>负责在运行时选择合适的策略。</li><li>客户端通过环境类来使用策略。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当一个类有很多行为，而且这些行为在运行时需要动态地改变时。</li><li>当需要使用不同的算法来解决同一个问题时。</li><li>当算法的实现细节需要对客户端隐藏时。</li><li>当需要避免使用大量的 <code>if-else</code> 或 <code>switch</code> 语句时。</li></ul><p><strong>实际案例：</strong></p><ul><li><strong>会员折扣：</strong> 针对不同会员等级（初级、中级、高级）应用不同的折扣策略。</li><li><strong>支付方式：</strong> 支持多种支付方式，如信用卡支付、支付宝支付、微信支付等。</li><li><strong>排序算法：</strong> 针对不同的数据规模或特点，选择不同的排序算法（如快速排序、归并排序、插入排序等）。</li><li><strong>缓存策略：</strong> 根据不同的场景，选择不同的缓存策略（如 LRU、FIFO、LFU 等）。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>算法可互换：</strong> 可以在运行时动态地切换算法。</li><li><strong>避免多重条件判断：</strong> 使用策略模式可以避免使用大量的 <code>if-else</code> 或 <code>switch</code> 语句。</li><li><strong>扩展性良好：</strong> 增加新的策略类非常容易，无需修改现有代码。</li><li><strong>代码复用：</strong> 不同的客户端可以复用相同的策略类。</li><li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>策略类会增多：</strong> 每种算法都需要一个具体的策略类，可能会导致类的数量增加。</li><li><strong>客户端需要了解所有策略：</strong> 客户端需要知道所有可用的策略，才能选择合适的策略。 在某些情况下，这可能会暴露算法的实现细节。</li></ul><h4 id="7-实现方式"><a href="#7-实现方式" class="headerlink" title="7. 实现方式"></a>7. 实现方式</h4><ol><li><strong>定义策略接口：</strong> 声明算法的接口。</li><li><strong>实现具体策略类：</strong> 实现策略接口，封装具体的算法。</li><li><strong>创建环境类：</strong><ul><li>持有策略接口的引用。</li><li>提供设置策略的方法，允许客户端在运行时选择策略。</li><li>在需要使用算法的地方调用策略接口的方法。</li></ul></li><li><strong>客户端：</strong> 创建环境类对象，并根据需要设置不同的策略。</li></ol><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 策略接口 (Strategy Interface)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体策略类 (Concrete Strategy Classes)</span></span><br><span class="line"><span class="comment">// 具体策略类 - 信用卡支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardNumber;</span><br><span class="line">    <span class="keyword">private</span> String cvv;</span><br><span class="line">    <span class="keyword">private</span> String expiryDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CreditCardPayment</span><span class="params">(String name, String cardNumber, String cvv, String expiryDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.cardNumber = cardNumber;</span><br><span class="line">        <span class="built_in">this</span>.cvv = cvv;</span><br><span class="line">        <span class="built_in">this</span>.expiryDate = expiryDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用信用卡支付: &quot;</span> + amount + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;信用卡信息: &quot;</span> + cardNumber); <span class="comment">// 实际场景需要加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体策略类 - 支付宝支付</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlipayPayment</span><span class="params">(String account)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用支付宝支付: &quot;</span> + amount + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝账号: &quot;</span> + account); <span class="comment">// 实际场景需要加密</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 环境类 (Context Class)</span></span><br><span class="line"><span class="comment">// 环境类 - 支付上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingCart</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy paymentStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShoppingCart</span><span class="params">(PaymentStrategy paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPaymentStrategy</span><span class="params">(PaymentStrategy paymentStrategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentStrategy = paymentStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkout</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        paymentStrategy.pay(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建购物车</span></span><br><span class="line">        <span class="type">ShoppingCart</span> <span class="variable">cart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShoppingCart</span>(<span class="keyword">new</span> <span class="title class_">CreditCardPayment</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;1234567890123456&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;2025-12&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用信用卡支付</span></span><br><span class="line">        cart.checkout(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换支付方式为支付宝</span></span><br><span class="line">        cart.setPaymentStrategy(<span class="keyword">new</span> <span class="title class_">AlipayPayment</span>(<span class="string">&quot;zhangsan@example.com&quot;</span>));</span><br><span class="line">        <span class="comment">// 使用支付宝支付</span></span><br><span class="line">        cart.checkout(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ul><li><strong>PaymentStrategy 接口：</strong> 定义了支付的接口 <code>pay(int amount)</code>，所有具体的支付策略都必须实现这个接口。</li><li><strong>CreditCardPayment 类：</strong> 实现了 <code>PaymentStrategy</code> 接口，使用信用卡进行支付。</li><li><strong>AlipayPayment 类：</strong> 实现了 <code>PaymentStrategy</code> 接口，使用支付宝进行支付。</li><li><strong>ShoppingCart 类：</strong> 环境类，它持有一个 <code>PaymentStrategy</code> 接口的引用，并在 <code>checkout()</code> 方法中调用 <code>PaymentStrategy</code> 的 <code>pay()</code> 方法。</li><li><strong>StrategyPatternDemo 类：</strong> 客户端代码，它创建了一个 <code>ShoppingCart</code> 对象，并设置不同的 <code>PaymentStrategy</code>，然后调用 <code>checkout()</code> 方法进行支付。</li></ul><h4 id="9-运行结果"><a href="#9-运行结果" class="headerlink" title="9. 运行结果"></a>9. 运行结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用信用卡支付: 100 元</span><br><span class="line">信用卡信息: 1234567890123456</span><br><span class="line">使用支付宝支付: 50 元</span><br><span class="line">支付宝账号: zhangsan@example.com</span><br></pre></td></tr></table></figure><h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h4><p>策略模式通过封装算法并使其可互换，实现了算法与客户端代码的解耦，提高了代码的灵活性和可维护性。 在选择使用策略模式时，需要权衡其优点和缺点，并根据具体的应用场景进行选择。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之原型模式"><a href="#设计模式之原型模式" class="headerlink" title="设计模式之原型模式"></a>设计模式之原型模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>原型模式是一种<strong>创建型设计模式</strong>，它允许通过复制现有对象来创建新的对象，而无需知道创建对象的具体类。 简单来说，原型模式就是“克隆”对象。 原型模式特别适用于创建复杂对象或者构造耗时的实例，因为复制一个已经存在的实例可以使程序运行更高效。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>对象复制：</strong> 使用已存在的对象作为原型，通过复制生成新的对象。</li><li><strong>避免重复初始化：</strong> 避免重复进行耗时的初始化操作。</li><li><strong>隐藏创建细节：</strong> 客户端无需了解对象创建的复杂过程。</li><li><strong>动态创建：</strong> 运行时动态决定创建哪些对象。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>原型模式主要包含以下角色：</p><ul><li><strong>原型接口 (Prototype):</strong><ul><li>声明 <code>clone()</code> 方法，用于复制对象。</li><li>定义复制对象所需的接口。</li></ul></li><li><strong>具体原型类 (Concrete Prototype):</strong><ul><li>实现 <code>Prototype</code> 接口。</li><li>实现 <code>clone()</code> 方法，返回自身的副本。</li><li>可以是浅拷贝或深拷贝。</li></ul></li><li><strong>客户端 (Client):</strong><ul><li>通过调用原型对象的 <code>clone()</code> 方法来创建新的对象。</li><li>无需知道具体原型类的名称。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当创建对象的代价比较大（例如，需要进行复杂的初始化或者占用大量资源）时。</li><li>当需要避免创建一个与特定类无关的对象时。</li><li>当需要在运行时动态地指定产品对象时。</li><li>当一个系统中存在大量相似对象时，可以使用原型模式创建新对象，从而提高效率。</li><li>需要保护性拷贝时，即一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li><li>Spring 框架中的多例 Bean 就是使用原型模式实现的。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>简化创建过程：</strong> 客户端无需了解对象的创建细节。</li><li><strong>提高创建效率：</strong> 通过复制现有对象来创建新对象，避免重复初始化。</li><li><strong>动态性：</strong> 可以在运行时动态地指定创建哪些对象。</li><li><strong>扩展性：</strong> 增加新的原型类非常容易。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>深拷贝复杂：</strong> 深拷贝的实现比较复杂，需要递归复制所有关联对象。</li><li><strong>破坏封装性：</strong> 客户端必须知道具体原型类的类型。</li><li><strong>可能需要修改原始类的代码：</strong> 为了实现 <code>clone()</code> 方法，可能需要修改原始类的代码。</li></ul><h4 id="7-实现方式"><a href="#7-实现方式" class="headerlink" title="7. 实现方式"></a>7. 实现方式</h4><ol><li><strong>实现 <code>Cloneable</code> 接口：</strong> 在 Java 语言中，<code>Cloneable</code> 接口的作用是在运行时通知 Java 虚拟机，可以安全地在实现了此接口的类上使用 <code>clone</code> 方法。在 Java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 <code>CloneNotSupportedException</code> 异常。</li><li><strong>重写 <code>Object</code> 类中的 <code>clone</code> 方法：</strong> Java 中，所有类的父类都是 <code>Object</code> 类，<code>Object</code> 类中有一个 <code>clone</code> 方法，作用是返回对象的一个拷贝，但是其作用域是 <code>protected</code> 类型的，一般的类无法调用，因此 <code>Prototype</code> 类需要将 <code>clone</code> 方法的作用域修改为 <code>public</code> 类型。</li><li><strong>浅拷贝 vs. 深拷贝：</strong><ul><li><strong>浅拷贝：</strong> 只复制对象的基本类型数据和引用，而不复制引用指向的对象。这意味着原始对象和克隆对象会共享引用指向的对象。</li><li><strong>深拷贝：</strong> 复制对象的所有数据，包括引用指向的对象。这意味着原始对象和克隆对象是完全独立的。要实现深拷贝，需要在 <code>clone()</code> 方法中手动复制所有引用指向的对象。</li></ul></li></ol><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><p><strong>浅拷贝示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 原型接口 (Prototype Interface)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Prototype</span> <span class="keyword">extends</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Prototype <span class="title function_">clone</span><span class="params">()</span>; <span class="comment">// 复制方法</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取名称</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>; <span class="comment">// 设置名称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体原型类 (Concrete Prototype Class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Prototype) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持克隆&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;原始对象&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone();</span><br><span class="line">        clone.setName(<span class="string">&quot;克隆对象&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象名称: &quot;</span> + clone.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName()); <span class="comment">// 验证原始对象是否被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始对象名称: 原始对象</span><br><span class="line">克隆对象名称: 克隆对象</span><br><span class="line">原始对象名称: 原始对象</span><br></pre></td></tr></table></figure><p><strong>代码解释：</strong></p><ul><li><strong>Prototype 接口：</strong> 声明了 <code>clone()</code> 方法，所有具体的原型类都必须实现这个方法。</li><li><strong>ConcretePrototype 类：</strong> 实现了 <code>Prototype</code> 接口，并提供了 <code>clone()</code> 方法的具体实现。 在这个例子中，我们使用 <code>super.clone()</code> 进行浅拷贝。</li><li><strong>PrototypePatternDemo 类：</strong> 客户端代码，它创建了一个 <code>ConcretePrototype</code> 对象，然后使用 <code>clone()</code> 方法创建了一个新的对象。</li></ul><p><strong>深拷贝示例 (如果 ConcretePrototype 包含一个引用类型的成员变量):</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretePrototype</span> <span class="keyword">implements</span> <span class="title class_">Prototype</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data; <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcretePrototype</span><span class="params">(String name, List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(List&lt;String&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">// 深拷贝引用类型的成员变量</span></span><br><span class="line">            clone.data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.data); <span class="comment">// 创建新的 List 对象并复制数据</span></span><br><span class="line">            <span class="keyword">return</span> clone;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不支持克隆&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原型对象</span></span><br><span class="line">        List&lt;String&gt; originalData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        originalData.add(<span class="string">&quot;数据1&quot;</span>);</span><br><span class="line">        originalData.add(<span class="string">&quot;数据2&quot;</span>);</span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">prototype</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcretePrototype</span>(<span class="string">&quot;原始对象&quot;</span>, originalData);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象数据: &quot;</span> + prototype.getData());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 克隆对象</span></span><br><span class="line">        <span class="type">ConcretePrototype</span> <span class="variable">clone</span> <span class="operator">=</span> (ConcretePrototype) prototype.clone();</span><br><span class="line">        clone.setName(<span class="string">&quot;克隆对象&quot;</span>);</span><br><span class="line">        clone.getData().add(<span class="string">&quot;新数据&quot;</span>); <span class="comment">// 修改克隆对象的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象名称: &quot;</span> + clone.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象数据: &quot;</span> + clone.getData());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象名称: &quot;</span> + prototype.getName()); <span class="comment">// 验证原始对象是否被修改</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始对象数据: &quot;</span> + prototype.getData()); <span class="comment">// 验证原始对象的数据是否被修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个深拷贝的例子中，我们创建了一个新的 <code>ArrayList</code> 对象，并将原始对象 <code>data</code> 中的所有元素复制到新的 <code>ArrayList</code> 中。 这样，原始对象和克隆对象就拥有了独立的 <code>data</code> 列表，修改克隆对象的 <code>data</code> 不会影响原始对象。</p><p><strong>运行结果 (深拷贝示例)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原始对象名称: 原始对象</span><br><span class="line">原始对象数据: [数据1, 数据2]</span><br><span class="line">克隆对象名称: 克隆对象</span><br><span class="line">克隆对象数据: [数据1, 数据2, 新数据]</span><br><span class="line">原始对象名称: 原始对象</span><br><span class="line">原始对象数据: [数据1, 数据2]</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>原型模式通过复制现有对象来创建新的对象，避免了重复初始化，提高了创建效率。在实现原型模式时，需要注意浅拷贝和深拷贝的区别，选择合适的拷贝方式。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之外观模式"><a href="#设计模式之外观模式" class="headerlink" title="设计模式之外观模式"></a>设计模式之外观模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>外观模式是一种<strong>结构型设计模式</strong>，它为子系统中的一组接口提供了一个统一的入口点。外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。 简单来说，外观模式隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的简单接口。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>简化接口：</strong> 为复杂的子系统提供一个简单的、统一的接口。</li><li><strong>解耦：</strong> 降低客户端与子系统之间的耦合度。</li><li><strong>易用性：</strong> 使子系统更容易使用。</li><li><strong>隐藏复杂性：</strong> 隐藏子系统的内部复杂性，客户端无需了解子系统的实现细节。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>外观模式主要包含以下角色：</p><ul><li><strong>外观（Facade）：</strong><ul><li>知道哪些子系统负责处理请求。</li><li>将客户端的请求委派给适当的子系统对象。</li><li>提供一个高层接口，简化子系统的使用。</li></ul></li><li><strong>子系统（Subsystems）：</strong><ul><li>实现子系统的功能。</li><li>处理由 Facade 类委派的请求。</li><li>子系统类并不知道 Facade 的存在。</li></ul></li><li><strong>客户端（Client）：</strong><ul><li>通过 Facade 对象访问子系统。</li><li>客户端不需要直接与子系统交互。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当需要为一个复杂的子系统提供一个简单的接口时。</li><li>当客户端不希望与复杂的子系统直接交互时。</li><li>当需要降低客户端与子系统之间的耦合度时。</li><li>当需要对子系统进行分层时，可以使用外观模式定义每层的入口。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>简化客户端的使用：</strong> 客户端无需了解子系统的复杂性，只需与外观类交互即可。</li><li><strong>降低耦合度：</strong> 降低客户端与子系统之间的耦合度，提高系统的灵活性和可维护性。</li><li><strong>提高可重用性：</strong> 将子系统的实现细节隐藏起来，方便子系统的重用。</li><li><strong>符合最少知识原则：</strong> 客户端只需要了解外观类，而不需要了解子系统的内部实现。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>可能导致外观类过于庞大：</strong> 如果子系统过于复杂，外观类可能会变得非常庞大，难以维护。</li><li><strong>不符合开闭原则：</strong> 如果需要修改子系统，可能需要修改外观类，这违反了开闭原则。</li></ul><h4 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. 实际应用场景</h4><ul><li><strong>编译器：</strong> 编译器可以将词法分析、语法分析、代码生成等子系统的复杂性隐藏起来，提供一个简单的编译接口。</li><li><strong>操作系统：</strong> 操作系统可以提供一个简单的 API 供应用程序调用，而隐藏底层的硬件操作。</li><li><strong>数据库访问：</strong> 可以使用外观模式封装数据库的连接、查询、更新等操作，提供一个简单的数据库访问接口。</li><li><strong>中间件：</strong> 中间件可以封装底层的网络通信、事务管理等复杂性，提供一个简单的服务调用接口。</li></ul><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 子系统类 (Subsystem Classes)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">freeze</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 冻结&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 执行指令&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">(<span class="type">long</span> position)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU 跳转到地址: &quot;</span> + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">long</span> position, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内存加载数据到地址: &quot;</span> + position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] read(<span class="type">long</span> lba, <span class="type">int</span> size) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;硬盘读取 LBA: &quot;</span> + lba + <span class="string">&quot;，大小: &quot;</span> + size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[size]; <span class="comment">// 模拟读取的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 外观类 (Facade Class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> HardDrive hardDrive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        <span class="built_in">this</span>.memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        <span class="built_in">this</span>.hardDrive = <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu.freeze();</span><br><span class="line">        memory.load(<span class="number">0x0000</span>, hardDrive.read(<span class="number">0</span>, <span class="number">1024</span>));</span><br><span class="line">        cpu.jump(<span class="number">0x1000</span>);</span><br><span class="line">        cpu.execute();</span><br><span class="line">        System.out.println(<span class="string">&quot;电脑启动完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        computer.startComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点解释：</strong></p><ul><li><strong>CPU, Memory, HardDrive (Subsystems):</strong> 这些是复杂的子系统，客户端通常需要直接与它们交互才能完成某些任务。 在这里，它们模拟计算机的不同组件。</li><li><strong>Computer (Facade):</strong> 外观类提供了一个简化的接口来访问子系统。 客户端只需调用外观类的方法，而无需了解子系统的复杂性。</li><li><strong>FacadePatternDemo (Client):</strong> 客户端类，它使用外观类来启动计算机。 客户端不需要直接与 CPU、内存或硬盘驱动器交互。</li><li><strong>外观模式</strong>通过提供一个统一的接口来访问子系统，简化了客户端的使用。 客户端无需了解子系统的复杂性，只需与外观类交互即可。这降低了客户端与子系统之间的耦合度，提高了代码的可维护性和可重用性。  在这个例子中，<code>Computer</code> 类充当外观，它封装了启动计算机所需的复杂步骤。 客户端只需调用 <code>startComputer()</code> 方法，即可启动计算机，而无需了解 CPU、内存和硬盘驱动器之间的交互细节。</li></ul><p><strong>输出结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CPU 冻结</span><br><span class="line">硬盘读取 LBA: 0，大小: 1024</span><br><span class="line">内存加载数据到地址: 0</span><br><span class="line">CPU 跳转到地址: 4096</span><br><span class="line">CPU 执行指令</span><br><span class="line">电脑启动完成！</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>外观模式是一种非常有用的设计模式，它可以简化客户端的使用，降低客户端与子系统之间的耦合度，提高系统的灵活性和可维护性。 然而，也需要注意外观模式的缺点，避免过度使用，导致外观类过于庞大。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 外观模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板方法模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之模板方法模式"><a href="#设计模式之模板方法模式" class="headerlink" title="设计模式之模板方法模式"></a>设计模式之模板方法模式</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>模板方法模式是一种<strong>行为型设计模式</strong>，它在一个抽象类中定义一个算法的骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些特定步骤。</p><h4 id="2-模式意图"><a href="#2-模式意图" class="headerlink" title="2. 模式意图"></a>2. 模式意图</h4><ul><li><strong>定义算法骨架：</strong> 在一个方法中定义一个算法的骨架，并将一些步骤延迟到子类。</li><li><strong>代码复用：</strong> 通过将通用步骤放在父类中，避免子类重复编写相同的代码。</li><li><strong>扩展性：</strong> 允许子类在不改变算法结构的情况下，定制算法的某些步骤。</li><li><strong>控制：</strong> 通过钩子方法，允许子类影响算法的执行流程。</li></ul><h4 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h4><p>模板方法模式主要包含以下角色：</p><ul><li><strong>抽象类（Abstract Class）：</strong><ul><li>定义了模板方法，即算法的骨架。</li><li>模板方法由一系列抽象方法和&#x2F;或具体方法组成。</li><li>抽象方法由子类实现。</li><li>具体方法提供默认实现，子类可以选择性地重写。</li><li>可以包含钩子方法，允许子类影响算法的执行流程。</li></ul></li><li><strong>具体类（Concrete Class）：</strong><ul><li>实现了抽象类中的抽象方法，提供算法中特定步骤的具体实现。</li><li>可以选择性地重写抽象类中的具体方法或钩子方法。</li></ul></li><li><strong>客户端（Client）：</strong><ul><li>调用模板方法来执行算法。</li></ul></li></ul><h4 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h4><ul><li>当完成某一个任务时，其过程的<strong>步骤是固定</strong>的，但是每个步骤的具体实现是<strong>不确定</strong>的。</li><li>当多个类中具有相同的程序代码，并且仅仅在一些细节上存在不同时。</li><li>需要控制子类的行为，强制子类遵循某种算法流程。</li></ul><h4 id="5-模式优点"><a href="#5-模式优点" class="headerlink" title="5. 模式优点"></a>5. 模式优点</h4><ul><li><strong>提高代码复用性：</strong> 将通用步骤放在父类中，避免子类重复编写相同的代码。</li><li><strong>提高扩展性：</strong> 允许子类在不改变算法结构的情况下，定制算法的某些步骤。</li><li><strong>符合开闭原则：</strong> 可以在不修改现有代码的情况下，通过新增子类来扩展算法。</li><li><strong>控制算法流程：</strong> 通过钩子方法，允许子类影响算法的执行流程，同时保持算法结构的稳定。</li></ul><h4 id="6-模式缺点"><a href="#6-模式缺点" class="headerlink" title="6. 模式缺点"></a>6. 模式缺点</h4><ul><li><strong>增加类的数量：</strong> 每一个不同的实现都需要一个具体的子类，这可能会导致类的数量增加。</li><li><strong>抽象类的约束：</strong> 抽象类定义了算法的骨架，这可能会限制子类的灵活性。</li></ul><h4 id="7-实际应用场景"><a href="#7-实际应用场景" class="headerlink" title="7. 实际应用场景"></a>7. 实际应用场景</h4><ul><li><strong>框架设计：</strong> 许多框架都使用了模板方法模式，例如：<ul><li>数据库访问的封装</li><li>Junit 单元测试</li><li>Servlet 中关于 doGet&#x2F;doPost 方法的调用</li></ul></li><li><strong>工作流引擎：</strong> 定义工作流的流程，每个步骤的具体实现由不同的子类完成。</li><li><strong>GUI 框架：</strong> 窗口的创建、事件处理等过程可以使用模板方法模式。</li></ul><h4 id="8-代码示例"><a href="#8-代码示例" class="headerlink" title="8. 代码示例"></a>8. 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象类（Abstract Class）定义模板方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法：定义算法骨架</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">makeCake</span><span class="params">()</span> &#123;</span><br><span class="line">        prepareIngredients();  <span class="comment">// 准备原料</span></span><br><span class="line">        mixIngredients();      <span class="comment">// 混合原料</span></span><br><span class="line">        bakeCake();           <span class="comment">// 烘焙</span></span><br><span class="line">        addFrosting();         <span class="comment">// 添加糖霜</span></span><br><span class="line">        decorateCake();        <span class="comment">// 装饰蛋糕</span></span><br><span class="line">        packageCake();         <span class="comment">// 打包</span></span><br><span class="line">        System.out.println(<span class="string">&quot;蛋糕准备好了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法：子类必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法：子类可以选择性地重写</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bakeCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在180度的温度下烘焙30分钟。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法：子类可以选择性地重写，控制算法流程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">needFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 默认需要糖霜</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法，根据钩子方法决定是否执行</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (needFrosting()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加香草糖霜。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不添加糖霜。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">packageCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;将蛋糕装在精美的盒子里。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体类（Concrete Class）实现抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChocolateCake</span> <span class="keyword">extends</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备巧克力、面粉、糖、鸡蛋和黄油。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;混合巧克力蛋糕的原料。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用巧克力屑和樱桃装饰。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 具体类（Concrete Class）实现抽象方法，并覆盖钩子方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VanillaCake</span> <span class="keyword">extends</span> <span class="title class_">AbstractCake</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备香草精、面粉、糖、鸡蛋和黄油。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">mixIngredients</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;混合香草蛋糕的原料。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decorateCake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用糖针和新鲜水果装饰。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">needFrosting</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不加糖霜</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端（Client）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractCake</span> <span class="variable">chocolateCake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChocolateCake</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;制作巧克力蛋糕：&quot;</span>);</span><br><span class="line">        chocolateCake.makeCake();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n制作香草蛋糕：&quot;</span>);</span><br><span class="line">        <span class="type">AbstractCake</span> <span class="variable">vanillaCake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VanillaCake</span>();</span><br><span class="line">        vanillaCake.makeCake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点解释:</strong></p><ul><li><strong>抽象类 (Abstract Class): <code>AbstractCake</code></strong><ul><li>定义了模板方法 <code>makeCake()</code>，它定义了制作蛋糕的算法骨架。 这个方法是 <code>final</code> 的，防止子类修改算法结构。</li><li>声明了抽象方法 <code>prepareIngredients()</code>, <code>mixIngredients()</code>, <code>decorateCake()</code>。这些方法必须由子类实现，以提供特定类型的蛋糕的制作细节。</li><li>提供了具体方法 <code>bakeCake()</code>, <code>addFrosting()</code>, <code>packageCake()</code>。这些方法提供了默认实现，子类可以选择性地重写。</li><li>提供了钩子方法 <code>needFrosting()</code>。钩子方法允许子类在算法的特定点插入行为，从而控制算法流程。</li></ul></li><li><strong>具体类 (Concrete Classes): <code>ChocolateCake</code>, <code>VanillaCake</code></strong><ul><li>实现了抽象类 <code>AbstractCake</code> 的抽象方法，提供了特定类型蛋糕的制作细节。</li><li><code>VanillaCake</code> 重写了钩子方法 <code>needFrosting()</code>，以取消糖霜步骤。</li></ul></li><li><strong>客户端 (Client): <code>TemplateMethodDemo</code></strong><ul><li>创建了具体类的实例，并调用模板方法 <code>makeCake()</code>，触发了制作蛋糕的过程。</li></ul></li></ul><p><strong>输出结果:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">制作巧克力蛋糕：</span><br><span class="line">准备巧克力、面粉、糖、鸡蛋和黄油。</span><br><span class="line">混合巧克力蛋糕的原料。</span><br><span class="line">在180度的温度下烘焙30分钟。</span><br><span class="line">添加香草糖霜。</span><br><span class="line">用巧克力屑和樱桃装饰。</span><br><span class="line">将蛋糕装在精美的盒子里。</span><br><span class="line">蛋糕准备好了！</span><br><span class="line"></span><br><span class="line">制作香草蛋糕：</span><br><span class="line">准备香草精、面粉、糖、鸡蛋和黄油。</span><br><span class="line">混合香草蛋糕的原料。</span><br><span class="line">在180度的温度下烘焙30分钟。</span><br><span class="line">不添加糖霜。</span><br><span class="line">用糖针和新鲜水果装饰。</span><br><span class="line">将蛋糕装在精美的盒子里。</span><br><span class="line">蛋糕准备好了！</span><br></pre></td></tr></table></figure><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h4><p>模板方法模式通过将算法骨架定义在抽象类中，并将某些步骤的实现延迟到子类，实现了代码的重用和扩展。<br>它允许子类在不改变算法结构的情况下，定制算法的某些步骤。<br>钩子方法提供了一种更灵活的方式来控制算法流程，允许子类在算法的特定点插入行为。<br>但是，也需要注意模板方法模式的缺点，避免过度使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之建造者模式"><a href="#设计模式之建造者模式" class="headerlink" title="设计模式之建造者模式"></a>设计模式之建造者模式</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>建造者模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。 简单来说，就是将对象的构建过程封装起来，允许用户分步骤地构建复杂对象，而无需了解其内部构造细节。<br>与工厂模式不同，建造者模式侧重于<strong>逐步构建</strong>一个复杂的对象，而不是一次性创建。 建造者模式关注的是对象各部分的组装过程，而工厂模式关注的是创建整个对象。</p><h4 id="建造者模式的角色"><a href="#建造者模式的角色" class="headerlink" title="建造者模式的角色"></a>建造者模式的角色</h4><p>建造者模式通常包含以下几个角色：</p><ol><li><strong>抽象建造者 (Builder)：</strong> 定义一个抽象接口，规范产品对象的各个组成部分的建造方法。 这个接口声明了要创建复杂对象的哪些部分，但不涉及具体对象部件的创建。</li><li><strong>具体建造者 (Concrete Builder)：</strong> 实现 Builder 接口，针对不同的商业逻辑，具体化复杂对象的各个部分的创建。 在建造过程完成后，提供产品的实例。</li><li><strong>指挥者 (Director)：</strong> 调用具体建造者来创建复杂对象的各个部分，控制对象各部分的组装顺序。 指挥者不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 指挥者是可选的，如果构建过程足够简单，可以直接由客户端来调用具体建造者。</li><li><strong>产品 (Product)：</strong> 要创建的复杂对象。</li></ol><h4 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="headerlink" title="建造者模式的使用场景"></a>建造者模式的使用场景</h4><p>以下是一些适合使用建造者模式的场景：</p><ol><li><strong>需要生成的对象具有复杂的内部结构：</strong> 当一个对象包含多个部件，且这些部件的创建逻辑复杂时，可以使用建造者模式将构建过程分解为多个步骤。</li><li><strong>需要生成的对象内部属性本身相互依赖：</strong> 当对象的某些属性依赖于其他属性时，可以使用建造者模式来确保属性之间的正确初始化。</li><li><strong>需要控制对象的构建过程：</strong> 当需要对对象的构建过程进行精细控制，例如指定构建顺序或添加验证逻辑时，可以使用建造者模式。</li><li><strong>创建不同表示的对象：</strong>当相同的构建过程需要生成不同类型的对象时，可以使用不同的具体建造者。</li></ol><h4 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h4><ul><li><strong>封装性：</strong> 隐藏了产品内部的构造细节。</li><li><strong>灵活性：</strong> 可以灵活地指定产品的各个部件。</li><li><strong>可读性：</strong> 链式调用使代码更易读。</li><li><strong>可扩展性：</strong> 可以很容易地添加新的建造者类，以构建不同类型的产品。</li><li><strong>控制：</strong> 可以在 <code>build()</code> 方法中添加验证逻辑，保证产品对象的有效性。</li><li><strong>易于维护：</strong> 将复杂的构建过程分解为多个步骤，使得代码更易于理解和维护。</li></ul><h4 id="建造者模式与工厂模式的区别"><a href="#建造者模式与工厂模式的区别" class="headerlink" title="建造者模式与工厂模式的区别"></a>建造者模式与工厂模式的区别</h4><ul><li><strong>关注点不同：</strong> 建造者模式侧重于逐步构建一个复杂的对象，而工厂模式侧重于一次性创建对象。</li><li><strong>复杂度不同：</strong> 建造者模式通常用于构建更复杂的对象，而工厂模式可以用于创建相对简单的对象。</li><li><strong>灵活性不同：</strong> 建造者模式可以更灵活地控制对象的构建过程，而工厂模式的灵活性相对较低。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Java 中的 <code>StringBuilder</code> 就是建造者模式的一个典型应用。它将单个字符或字符串逐步组装成最终的字符串。</p><p>以下是一个使用建造者模式构建电脑的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 产品类 (Product)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String ram;</span><br><span class="line">    <span class="keyword">private</span> String storage;</span><br><span class="line">    <span class="keyword">private</span> String graphicsCard;</span><br><span class="line">    <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造器，强制使用建造者模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(String cpu, String ram, String storage, String graphicsCard, String display)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram = ram;</span><br><span class="line">        <span class="built_in">this</span>.storage = storage;</span><br><span class="line">        <span class="built_in">this</span>.graphicsCard = graphicsCard;</span><br><span class="line">        <span class="built_in">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRam</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ram;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStorage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> storage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGraphicsCard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> graphicsCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> display;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Computer&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ram=&#x27;&quot;</span> + ram + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, storage=&#x27;&quot;</span> + storage + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, graphicsCard=&#x27;&quot;</span> + graphicsCard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, display=&#x27;&quot;</span> + display + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 建造者接口 (Builder Interface) -  也可以是一个抽象类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        Builder <span class="title function_">cpu</span><span class="params">(String cpu)</span>;</span><br><span class="line">        Builder <span class="title function_">ram</span><span class="params">(String ram)</span>;</span><br><span class="line">        Builder <span class="title function_">storage</span><span class="params">(String storage)</span>;</span><br><span class="line">        Builder <span class="title function_">graphicsCard</span><span class="params">(String graphicsCard)</span>;</span><br><span class="line">        Builder <span class="title function_">display</span><span class="params">(String display)</span>;</span><br><span class="line">        Computer <span class="title function_">build</span><span class="params">()</span>;  <span class="comment">// 构建产品的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 具体建造者类 (Concrete Builder)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ComputerBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String ram;</span><br><span class="line">        <span class="keyword">private</span> String storage;</span><br><span class="line">        <span class="keyword">private</span> String graphicsCard;</span><br><span class="line">        <span class="keyword">private</span> String display;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">cpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">ram</span><span class="params">(String ram)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ram = ram;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">storage</span><span class="params">(String storage)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.storage = storage;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">graphicsCard</span><span class="params">(String graphicsCard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.graphicsCard = graphicsCard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ComputerBuilder <span class="title function_">display</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 可在此处添加验证逻辑，例如，必须有 CPU 和 RAM</span></span><br><span class="line">            <span class="keyword">if</span> (cpu == <span class="literal">null</span> || ram == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;CPU and RAM are required to build a computer.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(cpu, ram, storage, graphicsCard, display);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 指挥者类 (Director) - 可选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Computer.Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ComputerDirector</span><span class="params">(Computer.Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">constructGamingComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.cpu(<span class="string">&quot;Intel i9&quot;</span>).ram(<span class="string">&quot;32GB&quot;</span>).storage(<span class="string">&quot;1TB SSD&quot;</span>).graphicsCard(<span class="string">&quot;Nvidia RTX 4090&quot;</span>).display(<span class="string">&quot;27-inch 4K&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">constructOfficeComputer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.cpu(<span class="string">&quot;Intel i5&quot;</span>).ram(<span class="string">&quot;16GB&quot;</span>).storage(<span class="string">&quot;512GB SSD&quot;</span>).display(<span class="string">&quot;24-inch 1080p&quot;</span>).build(); <span class="comment">// 缺少 graphicsCard 是可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 客户端代码 (Client)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuilderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用建造者模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一：直接使用 Builder</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder()</span><br><span class="line">                .cpu(<span class="string">&quot;AMD Ryzen 5&quot;</span>)</span><br><span class="line">                .ram(<span class="string">&quot;16GB&quot;</span>)</span><br><span class="line">                .storage(<span class="string">&quot;500GB SSD&quot;</span>)</span><br><span class="line">                .graphicsCard(<span class="string">&quot;AMD Radeon RX 6600&quot;</span>)</span><br><span class="line">                .display(<span class="string">&quot;24 inch&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Computer 1: &quot;</span> + computer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二：使用 Director，更灵活</span></span><br><span class="line">        Computer.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder();</span><br><span class="line">        <span class="type">ComputerDirector</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerDirector</span>(builder);</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">gamingComputer</span> <span class="operator">=</span> director.constructGamingComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;Gaming Computer: &quot;</span> + gamingComputer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">officeComputer</span> <span class="operator">=</span> director.constructOfficeComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;Office Computer: &quot;</span> + officeComputer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试验证逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Computer</span> <span class="variable">invalidComputer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>.ComputerBuilder().storage(<span class="string">&quot;1TB&quot;</span>).build(); <span class="comment">// 缺少 CPU 和 RAM</span></span><br><span class="line">            System.out.println(invalidComputer); <span class="comment">// 不应该执行到这里</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception: &quot;</span> + e.getMessage());  <span class="comment">// 打印异常信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此示例展示了建造者模式的以下优点：</p><ul><li><strong>产品类 (Product)：</strong> <code>Computer</code> 类是最终要创建的复杂对象。 注意它的构造函数是私有的，这样就只能通过 Builder 来创建它，保证了建造过程的控制。</li><li><strong>建造者接口 (Builder Interface)：</strong> <code>Computer.Builder</code> 接口定义了创建 <code>Computer</code> 对象各个部分的方法。 它也可以是一个抽象类，如果有一些通用的构建逻辑。</li><li><strong>具体建造者 (Concrete Builder)：</strong> <code>Computer.ComputerBuilder</code> 实现了 <code>Computer.Builder</code> 接口，负责具体的产品构建过程。 它提供链式调用的方式来设置各个属性，并且 <code>build()</code> 方法返回最终的 <code>Computer</code> 对象。</li><li><strong>指挥者 (Director) - 可选：</strong> <code>ComputerDirector</code> 类负责管理建造者的构建顺序。 它封装了复杂的构建逻辑，客户端只需要选择构建哪种类型的 <code>Computer</code>，而不需要关心构建细节。 如果构建过程很简单，Director 可以省略。</li><li><strong>客户端 (Client)：</strong> 客户端代码创建建造者或指挥者，并调用相应的方法来构建 <code>Computer</code> 对象。 客户端无需关心 <code>Computer</code> 对象的构建细节。</li></ul><p>运行 <code>BuilderDemo.java</code> 将会打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Computer 1: Computer&#123;cpu=&#x27;AMD Ryzen 5&#x27;, ram=&#x27;16GB&#x27;, storage=&#x27;500GB SSD&#x27;, graphicsCard=&#x27;AMD Radeon RX 6600&#x27;, display=&#x27;24 inch&#x27;&#125;</span><br><span class="line">Gaming Computer: Computer&#123;cpu=&#x27;Intel i9&#x27;, ram=&#x27;32GB&#x27;, storage=&#x27;1TB SSD&#x27;, graphicsCard=&#x27;Nvidia RTX 4090&#x27;, display=&#x27;27-inch 4K&#x27;&#125;</span><br><span class="line">Office Computer: Computer&#123;cpu=&#x27;Intel i5&#x27;, ram=&#x27;16GB&#x27;, storage=&#x27;512GB SSD&#x27;, graphicsCard=&#x27;null&#x27;, display=&#x27;24-inch 1080p&#x27;&#125;</span><br><span class="line">Exception: CPU and RAM are required to build a computer.</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>建造者模式是一种非常有用的创建型设计模式，可以帮助我们构建复杂的对象，并控制对象的构建过程。 它可以提高代码的可读性、可维护性和可扩展性。 在实际开发中，我们可以根据具体情况选择是否使用建造者模式，以及如何使用它。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之代理模式"><a href="#设计模式之代理模式" class="headerlink" title="设计模式之代理模式"></a>设计模式之代理模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>代理模式通过引入一个代理对象来控制对原始对象的访问。代理可以在原始对象的方法调用前后添加额外的处理逻辑，例如权限控制、日志记录、事务管理等，而无需修改原始对象的代码。这是一种实现了 AOP (面向切面编程) 的轻量级方式。</p><p>代理模式与 Spring 的 AOP (面向切面编程) 思想非常相似，都可以在不修改原有代码和业务流程的情况下，动态地切入新代码，增加新功能。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>代理模式常用于以下场景：</p><ul><li><strong>Spring AOP</strong>：实现横切关注点的统一处理。</li><li><strong>日志打印</strong>：在方法调用前后记录日志。</li><li><strong>异常处理</strong>：统一处理方法调用中的异常。</li><li><strong>事务控制</strong>：在方法调用前后开启和关闭事务。</li><li><strong>权限控制</strong>：控制对敏感资源的访问。</li></ul><h4 id="代理的分类"><a href="#代理的分类" class="headerlink" title="代理的分类"></a>代理的分类</h4><p>代理模式主要分为以下三种类型：</p><ul><li><strong>静态代理（Static Proxy）：</strong> 程序员手动创建或通过工具生成代理类的源代码，并在程序运行前完成编译。代理类和委托类的关系在编译前就已确定。</li><li><strong>动态代理（Dynamic Proxy）：</strong> 在运行时动态生成代理类，通常使用反射机制实现。JDK 动态代理要求委托类必须实现接口。</li><li><strong>CGLIB 动态代理（CGLIB Dynamic Proxy）：</strong> 使用 CGLIB 字节码操作库在运行时动态生成代理类，可以代理没有实现接口的类。但 CGLIB 不能代理 <code>final</code> 类。</li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><h5 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>静态代理是指在程序运行前，代理类的源代码已经存在，并且代理类和委托类的关系在编译前就已确定。</p><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>可以针对具体对象或接口进行代理。</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>每个需要代理的对象都需要编写相应的代理类，代码冗余。</li></ul><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p><strong>需求：</strong> 在不修改 <code>UserDao</code> 类的情况下，为其 <code>save</code> 方法添加事务控制。</p><p><em>委托类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-动态代理（JDK-动态代理）"><a href="#2-动态代理（JDK-动态代理）" class="headerlink" title="2. 动态代理（JDK 动态代理）"></a>2. 动态代理（JDK 动态代理）</h5><h6 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h6><p>动态代理是指在程序运行时动态生成代理类，代理类不是预先存在的。JDK 动态代理使用反射机制实现，要求委托类必须实现接口。</p><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul><li>无需手动编写代理类，可以在运行时动态指定代理对象，减少代码冗余。</li></ul><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul><li>必须面向接口进行代理，目标业务类必须实现接口。</li></ul><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h6><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>InvocationHandler 实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">// 下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> userDaoImpl.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-CGLIB-动态代理"><a href="#3-CGLIB-动态代理" class="headerlink" title="3. CGLIB 动态代理"></a>3. CGLIB 动态代理</h5><h6 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h6><p>CGLIB (Code Generation Library) 动态代理利用 ASM 开源包，对代理对象类的 Class 文件加载进来，通过修改其字节码生成子类来处理。</p><h6 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h6><ul><li>可以直接代理类，不需要实现接口。</li></ul><h6 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h6><ul><li>不能代理 <code>final</code> 类。</li><li>需要导入 CGLIB 相关的 jar 包。</li></ul><h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h6><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CGLIB 动态代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="built_in">this</span>.targetObject = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理实际方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之工厂模式"><a href="#设计模式之工厂模式" class="headerlink" title="设计模式之工厂模式"></a>设计模式之工厂模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。在工厂模式中，客户端无需关心对象的创建逻辑，而是通过一个共同的接口来获取新创建的对象。工厂模式实现了创建者和调用者的分离，常见的工厂模式分为简单工厂、工厂方法和抽象工厂模式。</p><h4 id="工厂模式的优点"><a href="#工厂模式的优点" class="headerlink" title="工厂模式的优点"></a>工厂模式的优点</h4><ul><li>工厂模式是用工厂方法代替 <code>new</code> 操作的一种模式，是常用的实例化对象模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护和修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制，从而将调用者与实现类解耦。</li></ul><h4 id="为什么要学习工厂设计模式"><a href="#为什么要学习工厂设计模式" class="headerlink" title="为什么要学习工厂设计模式"></a>为什么要学习工厂设计模式</h4><p>如果你想了解或学习许多框架的源码，或者你想自己开发框架，就必须先掌握设计模式，尤其是工厂设计模式，它被广泛应用。例如 Spring、MyBatis 等框架的源码中都大量使用了工厂模式。</p><h4 id="Spring-开发中的工厂设计模式"><a href="#Spring-开发中的工厂设计模式" class="headerlink" title="Spring 开发中的工厂设计模式"></a>Spring 开发中的工厂设计模式</h4><ol><li><strong>Spring IOC</strong><ul><li>Spring IOC 容器创建 Bean 的过程使用了工厂设计模式。</li><li>在 Spring 中，无论是通过 XML 配置、配置类还是注解来创建 Bean，大部分都是通过简单工厂来实现的。</li><li>当容器拿到 Bean 的名称和 Class 类型后，动态地通过反射创建具体的对象，最后将创建的对象放到 Map 中。</li></ul></li><li><strong>为什么 Spring IOC 要使用工厂设计模式创建 Bean 呢？</strong><ul><li>在实际开发中，如果 A 对象调用 B，B 调用 C，C 调用 D，程序的耦合性就会变高（耦合大致分为类与类之间的依赖，方法与方法之间的依赖）。</li><li>Java 的三层架构编程，都是控制层调用业务层，业务层调用数据访问层时，都是直接 <code>new</code> 对象，耦合性大大提升，代码重复量很高，对象满天飞。</li><li>为了避免这种情况，Spring 使用工厂模式编程，创建一个工厂，由工厂创建 Bean，以后需要对象就直接从工厂获取即可。Spring IOC 容器的工厂中有一个静态的 Map 集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到 Map 集合中，保证了实例不会重复影响程序效率。</li></ul></li></ol><h4 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h4><p>工厂模式分为简单工厂、工厂方法和抽象工厂模式。</p><ul><li><strong>简单工厂：</strong> 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</li><li><strong>工厂方法：</strong> 用来生产同一等级结构中的固定产品。（支持拓展增加产品）</li><li><strong>抽象工厂：</strong> 用来生产不同产品族的全部产品。（不支持拓展增加产品，支持增加产品族）</li></ul><h5 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h5><p>简单工厂模式相当于一个工厂中有各种产品，创建在一个类中。客户端无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。<br><strong>代码演示:</strong><br><em>创建工厂接口（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建另外一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建核心工厂类，由它决定具体调用哪个产品</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Milk <span class="title function_">createMilk</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;蒙牛&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;伊利&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> MilkFactory.createMilk(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> MilkFactory.createMilk(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简单工厂的优点&#x2F;缺点</strong></p><ul><li><strong>优点：</strong> 简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li><li><strong>缺点：</strong> 工厂类集中了所有实例的创建逻辑，容易违反 <a href="https://blog.csdn.net/u013249965/article/details/51779634" title="CSDN的博主JoJo小风有详细的介绍">GRASPR</a> 的高内聚的责任分配原则。</li></ul><h5 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h5><p>工厂方法模式 Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><p><strong>代码演示:</strong><br><em>创建工厂接口（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口（所有的产品需要 new 出来必须继承它来实现方法）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    Milk <span class="title function_">createMilk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的另一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiuFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLiFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MengNiuFactory</span>().createMilk();</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YiLiFactory</span>().createMilk();</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h5><p><em>这个模式如同它的名字，理解起来很抽象，以下内容也是我根据前辈的思路和自己的理解来总结的。</em><br><strong>抽象工厂模式：</strong></p><ul><li>是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的方式。</li><li>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li><li>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品。</li></ul><blockquote><p>个人理解: 我就以蒙牛举个例子</p><p>把蒙牛比喻成超级工厂</p><p>那么蒙牛的子品牌（特仑苏、纯甄等），就是蒙牛创建的其他工厂</p><p>蒙牛有自己的产品</p><p>特仑苏有自己的产品</p><p>纯甄也有自己的产品</p></blockquote><p>而它们之间的关系，如图所示：<br> <img src="https://i.imgs.ovh/2025/04/23/cq4pU.png" alt="示例图片" title="个人理解，仅供参考"> </p><p> <em><strong>我对这个设计模式理解还比较浅薄，就不展示代码了.</strong></em><br>想详细了解抽象工厂模式的，可以参考以下链接：<br><a href="https://liaoxuefeng.com/books/java/design-patterns/creational/abstract-factory/index.html" title="廖雪峰大佬对抽象工厂的理解">廖雪峰的官方网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>单例模式</strong>是一种创建型设计模式，它保证一个类只有一个实例，并提供一个全局访问点。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>单例模式常用于以下场景：</p><ul><li><strong>系统服务：</strong> 像 Windows 的任务管理器和回收站这样的系统服务，通常也使用单例模式，以确保系统中只有一个实例运行。</li><li><strong>线程池：</strong> 多线程环境中的线程池通常使用单例模式，以便于对池中的线程进行统一管理和控制。</li><li><strong>日志：</strong> 应用程序的日志记录器通常使用单例模式，以确保所有日志信息都追加到同一个文件中。</li><li><strong>计数器：</strong> 网站计数器通常使用单例模式实现，以保证同步。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li><strong>唯一实例：</strong> 确保一个类只有一个实例，防止其他对象多次实例化，从而确保所有对象都访问相同的实例。</li><li><strong>可控的实例化过程：</strong> 类可以自己控制实例化过程，从而具有一定的伸缩性。</li><li><strong>受控访问：</strong> 提供对唯一实例的受控访问点。</li><li><strong>节省资源：</strong> 由于系统中只存在一个对象，可以节约系统资源，尤其是在需要频繁创建和销毁对象时，可以提高系统性能。</li><li><strong>允许可变数目的实例：</strong> 在某些变体中，单例模式可以扩展为允许固定数量的实例。</li><li><strong>避免多重占用：</strong> 避免对共享资源的多重占用。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li><strong>不适用于变化的对象：</strong> 如果同一类型的对象需要在不同的用例场景中发生变化，单例模式可能会引起数据错误，因为它无法保存彼此的状态。</li><li><strong>扩展困难：</strong> 由于单例模式中没有抽象层，单例类的扩展比较困难。</li><li><strong>职责过重：</strong> 单例类承担了过多的职责，在一定程度上违背了单一职责原则。</li><li><strong>可能导致资源浪费：</strong> 如果长时间不使用单例实例，可能会被系统回收，导致对象状态丢失。</li><li><strong>隐藏依赖关系：</strong> 单例模式会隐藏组件之间的依赖关系，降低代码的可测试性。</li></ol><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol><li><strong>防止反射攻击：</strong> 需要防止通过反射机制创建新的单例对象，破坏单例模式。</li><li><strong>线程安全：</strong> 在使用懒汉式单例时，需要注意线程安全问题。</li><li><strong>继承限制：</strong> 饿汉式和懒汉式单例的构造方法是私有的，因此不能被继承。某些单例模式（如登记式模式）可以被继承。</li></ol><h4 id="防止反射攻击"><a href="#防止反射攻击" class="headerlink" title="防止反射攻击"></a>防止反射攻击</h4><p>以下代码展示了如何防止通过反射机制破坏单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;有请求破坏单例模式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择单例创建方式"><a href="#如何选择单例创建方式" class="headerlink" title="如何选择单例创建方式"></a>如何选择单例创建方式</h4><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。</li><li>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。最好使用饿汉式。</li></ul><h4 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h4><p>以下是几种常见的单例模式实现方式：</p><ol><li>饿汉式</li><li>懒汉式</li><li>静态内部类</li><li>枚举单例</li><li>双重检测锁（不推荐）</li></ol><h5 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h5><p>在类加载时就创建实例，线程安全，调用效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter1</span> &#123;</span><br><span class="line">    <span class="comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Chapter1</span> <span class="variable">chapter1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chapter1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter1构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chapter1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter1</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter1.getInstance();</span><br><span class="line">        <span class="type">Chapter1</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter1.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h5><p>在第一次使用时才创建实例，具有懒加载功能，但需要处理线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter2</span> &#123;</span><br><span class="line">    <span class="comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chapter2 chapter2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter2构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Chapter2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chapter2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            chapter2 = <span class="keyword">new</span> <span class="title class_">Chapter2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chapter2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter2</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter2.getInstance();</span><br><span class="line">        <span class="type">Chapter2</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter2.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3. 静态内部类"></a>3. 静态内部类</h5><p>结合了懒汉式和饿汉式的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter3构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonClassInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Chapter3</span> <span class="variable">CHAPTER_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chapter3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法没有同步</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.CHAPTER_3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter3</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter3.getInstance();</span><br><span class="line">        <span class="type">Chapter3</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter3.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-枚举单例"><a href="#4-枚举单例" class="headerlink" title="4. 枚举单例"></a>4. 枚举单例</h5><p>实现简单、调用效率高，枚举本身就是单例，由 JVM 从根本上提供保障，避免通过反射和反序列化的漏洞，但没有延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Chapter.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter4</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter4.getInstance();</span><br><span class="line">        <span class="type">Chapter4</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter4.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Chapter</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> Chapter4 chapter4;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Chapter</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;枚举Chapter私有构造参数&quot;</span>);</span><br><span class="line">            chapter4 = <span class="keyword">new</span> <span class="title class_">Chapter4</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Chapter4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> chapter4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-双重检测锁（不推荐）"><a href="#5-双重检测锁（不推荐）" class="headerlink" title="5. 双重检测锁（不推荐）"></a>5. 双重检测锁（不推荐）</h5><p>由于 JVM 本质重排序的原因，可能会初始化多次，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chapter5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chapter5 chapter5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Chapter5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Chapter4构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Chapter5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (chapter5 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Chapter5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chapter5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                    chapter5 = <span class="keyword">new</span> <span class="title class_">Chapter5</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chapter5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chapter5</span> <span class="variable">c1</span> <span class="operator">=</span> Chapter5.getInstance();</span><br><span class="line">        <span class="type">Chapter5</span> <span class="variable">c2</span> <span class="operator">=</span> Chapter5.getInstance();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h4><p>在实际开发过程中，单例模式最常用的情况是模块与模块之间的解耦。<br>简化示例图：<br><img src="https://i.imgs.ovh/2025/04/22/cUMIb.png" alt="不使用单例模式" title="不使用单例模式"><br><img src="https://i.imgs.ovh/2025/04/22/cUQZ1.png" alt="使用单例模式" title="使用单例模式"><br><em>以上仅限个人看法，其实单例模式还有很多应用场景；只是我是个菜鸟，工作这么久也就这种场景使用过单例模式。</em></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习下设计模式</title>
      <link href="/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近打算面试，了解一下自己是否与时代脱节。在面试过程中，我发现自己对设计模式的认识和理解还不够深入，因此决定重新复习一下。</p><h3 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h3><ul><li>设计模式是一套在软件开发中被反复使用、广为人知、经过分类编目的代码设计经验总结。</li><li>使用设计模式的目的是为了提高代码的可重用性、可读性、可靠性和可维护性。</li></ul><h3 id="2-为什么要学习设计模式"><a href="#2-为什么要学习设计模式" class="headerlink" title="2. 为什么要学习设计模式"></a>2. 为什么要学习设计模式</h3><ul><li><strong>阅读源码：</strong> 理解设计模式是阅读 JDK、Spring、SpringMVC、IO 等源码的基础，否则会感到困惑和难以理解。</li><li><strong>理解现有代码：</strong> 在实际工作中，我们经常会接手现有项目，理解前辈们使用的设计模式对于维护和扩展代码至关重要。</li><li><strong>编写高质量代码：</strong> 使用设计模式可以提高代码的复用性和可扩展性，从而编写出更理想的代码。</li></ul><h3 id="3-设计模式分类"><a href="#3-设计模式分类" class="headerlink" title="3. 设计模式分类"></a>3. 设计模式分类</h3><p> <img src="https://i.imgs.ovh/2025/04/19/jGCmc.png" alt="设计模式分类类"> </p><ul><li><strong>创建型模式 (Creational Patterns)：</strong> 主要关注对象的创建过程，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li><strong>结构型模式 (Structural Patterns)：</strong> 描述如何将类或对象组合成更大的结构，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><strong>行为型模式 (Behavioral Patterns)：</strong> 关注对象之间的交互和职责分配，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h3 id="4-设计模式的六大原则"><a href="#4-设计模式的六大原则" class="headerlink" title="4. 设计模式的六大原则"></a>4. 设计模式的六大原则</h3><p><img src="https://i.imgs.ovh/2025/04/19/jG7P9.png" alt="设计模式的六大原则">  </p><ul><li><p><strong>开放封闭原则 (Open&#x2F;Closed Principle, OCP)</strong></p><ul><li><strong>原则思想：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着尽量通过扩展软件实体的功能来满足新的需求，而不是修改已有的代码。</li><li><strong>描述：</strong> 软件产品在其生命周期内会不断面临变化。为了提高项目的稳定性和灵活性，我们应该在设计时考虑到这些变化，并使系统能够适应它们。</li><li><strong>优点：</strong> 遵循单一职责原则，保证每个类都有明确的职责；符合里氏替换原则，保证继承体系的正确性。</li></ul></li><li><p><strong>里氏代换原则 (Liskov Substitution Principle, LSP)</strong></p><ul><li><strong>原则思想：</strong> 所有引用基类的地方必须能透明地使用其子类的对象。</li><li><strong>概要：</strong> 子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法。</li><li><strong>优点：</strong> 提高程序的健壮性，即使增加了子类，原有子类的功能也能继续运行，互不影响。</li></ul></li><li><p><strong>单一职责原则 (Single Responsibility Principle, SRP)</strong></p><ul><li><strong>原则思想：</strong> 一个类应该只有一个引起它变化的原因。</li><li><strong>描述：</strong> 一个类应该只负责一个职责，当需要修改类的功能时，只应该有一个原因。这有助于降低类之间的耦合度，提高代码的可读性和可维护性。</li><li><strong>优点：</strong> 降低类和类之间的耦合度，提高可读性、可维护性和可扩展性，降低代码变更的风险。</li></ul></li><li><p><strong>依赖倒转原则 (Dependency Inversion Principle, DIP)</strong></p><ul><li>核心思想是面向接口编程，依赖于抽象而不是依赖于具体实现。</li><li>在程序代码中传递参数或建立关联关系时，尽量引用层次高的抽象层类。</li><li>是开放封闭原则的基础。</li></ul></li><li><p><strong>接口隔离原则 (Interface Segregation Principle, ISP)</strong></p><ul><li>使用多个专门的接口比使用单一的总接口要好。</li><li>核心思想是降低类之间的耦合度。</li><li>例如：将支付接口和订单接口拆分为两个独立的接口。</li></ul></li><li><p><strong>迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则 (Principle of Least Knowledge)</strong></p><ul><li>一个对象应当对其他对象有尽可能少的了解，从而降低类与类之间的耦合度。</li><li>一个类应该尽量减少对其他对象的依赖。只有各个模块之间的耦合度降低，才能提高代码的复用率。</li><li>例如：如果一个类只需要调用另一个类的少数几个方法，就应该尽量避免直接引用整个类，而是通过接口或委托等方式进行交互。</li></ul></li></ul><blockquote><p>这里描述的设计模式只是基础，更详细的就不描述了，如果你是一个萌新可以去找一本叫《<strong>大话设计模式</strong>》的书，我之前就是看这本书进行学习的。主要是这里面用故事的方式去描述“设计模式”，比纯理论知识好理解太多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔-企业支付到微信零钱</title>
      <link href="/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/"/>
      <url>/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近企业网站做了个活动，用户在活动期间可以获得积分，积分可以兑换礼品现金红包提现到用户的微信钱包中，在参与开发这个功能时遇到的问题在这里记录下。</p><h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><p><strong>请求体</strong></p><ol><li>请求URL中的参数组装 需要把参数名ASCII字典序排序最后加上<br>key&#x3D;{微信商户平台(pay.weixin.qq.com)-&gt;账户设置-&gt;API安全-&gt;密钥设置}</li><li>请求URL中的参数对应请求体内的XML参数都要有，编码要全部设置为 UTF-8</li><li>请求体内需要添加 <strong>apiclient_cert.p12</strong> 证书</li><li>最终返回结果 成功即为成功，失败需要以下几步操作:<ul><li>查询企业付款 来确认支付结果为失败还是转账中</li><li>若为失败根据失败信息判断以原订单号重新发起请求还是以新的订单号发起请求</li></ul></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p><strong>SIGNERROR 签名错误</strong></p><ul><li>请求时编码要是全部设置为 UTF-8;</li><li>key 传的不正确，key 和 app_id 一定要对的上，如果已经接入过微信支付，要确认这里的传的就是微信支付中用到的 key</li><li>签名的参数和传递给微信的参数不匹配，一般是拼接参数不正确导致的，DEMO 中参数</li></ul><p>已经配置好了，只要不修改参数的个数基本不会有问题;</p><p><strong>NO_AUTH 此 IP 地址不允许调用接口</strong></p><ul><li>新版本商户后台默认需要 IP 校验，有些人填 192.168.1.XXX 这种内网 IP 是不行的，可以<br>访问 ip168 之类的网站获取自己的外网地址；在开发阶段也可以先关掉校验，方便本地调试;</li></ul><p><strong>OPENID_ERROR Openid 错误</strong></p><ul><li>app_id 和 openid 没对上导致的，比如公司同时开通了小程序和微信服务号，两个应用关<br>联了同一个商户，极有可能就是用的小程序 app_id 作为参数，但是传的是微信服务号关联<br>的 openid</li></ul><p><strong>注意项</strong><br>Java需要用到：apiclient_cert.p12证书、证书秘钥、AppId、openId、商品号</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown软件推荐-Win系统</title>
      <link href="/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于Hexo是使用Markdown语法编写博客，<br>而在记事本上写Markdown语法是非常麻烦的，主要是预览不到显示效果。<br>win系统上有很多编辑器，我把网上有些热度的编辑器都下载下来使用下，在这里记录下我在使用这些软件的优缺点。</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora可以说是win系统上推荐度最高的Markdown编辑器，搜索首推就是它。<br>当然它也没有辜负大家对他的推荐，<br>功能非常强大，<br>支持实时预览，<br>支持更换主题，<br>支持导出PDF，支持导出Word，还有其他很多格式，<br>最主要是可以全屏编辑，不像有些编辑器左面总是有两个框框，<br>可以说是win系统上最好用的Markdown编辑器；<br>最大的缺点就是需要付费。<br>下面展示两个Typora图片，源码模式和实时预览：<br><img src="https://i.imgs.ovh/2025/04/13/aRi4c.png" alt="源码模式"><br><img src="https://i.imgs.ovh/2025/04/13/aRNk9.png" alt="实时预览"><br>最终贫穷的我还是放弃了Typora。</p><h3 id="微信Markdown编辑器"><a href="#微信Markdown编辑器" class="headerlink" title="微信Markdown编辑器"></a>微信Markdown编辑器</h3><p>应该很多人不是很了解这个，它不是软件而是一个网址可以直接在线编辑Markdown，<br>但是它的功能有限，只能导出html和md格式，支持实时预览，不过是手机端的，如果和我一样只是简单的写博客，记录自己的一时的想法，还是可以的。<br><a href="https://doocs-md.pages.dev/" title="微信Markdown编辑器">微信Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/13/akaHA.png" alt="微信Markdown编辑器"></p><h3 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h3><p>这是也是个网页，功能强大，支持实时预览，有兴趣的可以去看看<br><a href="https://zybuluo.com/mdeditor" title="Cmd Markdown编辑器">Cmd Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPRkr.png" alt="Cmd Markdown编辑器"></p><h3 id="Notable"><a href="#Notable" class="headerlink" title="Notable"></a>Notable</h3><p>这是一款开源的Markdown编辑器，界面还行，就是左面总是有两个框框 不能关闭！<br>不支持实时预览，不过能预览就是要点击上面的Edit按钮，所以在编辑md文件的时候总是去点击Edit按钮，比较麻烦。最终让我放弃的原因是它的功能栏是英文的，不能切换中文。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aMmf4.png" alt="Notable编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aMueA.png" alt="Notable预览模式"></p><h3 id="MarkText"><a href="#MarkText" class="headerlink" title="MarkText"></a>MarkText</h3><p>这也是一个开源的Markdown编辑器，界面不错，不过我看GitHub上已经很久没有更新了，<br>下载的时候找到了个MarkText中文特别版，默认界面很像Typora，如果不习惯全屏的也可以打开侧边栏，功能很多，日常使用完全足够了。<br>这个编辑器不支持实时预览，预览界面可以用Ctrl+E快捷键打开。Typora最好的替代工具。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPVsL.png" alt="MarkText编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aPbKx.png" alt="MarkText预览模式"></p><h3 id="Zettlr"><a href="#Zettlr" class="headerlink" title="Zettlr"></a>Zettlr</h3><p>这个编辑器让我一言难尽啊，它很强大、很专业。<br>功能很多，但我只是想要一个简单的Markdown编辑器，够日常使用就行。<br>有兴趣的可以去看看<br><a href="https://www.zettlr.com/" title="Zettlr官网">Zettlr官网</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPQkH.png" alt="Zettlr"></p><h3 id="最后强烈推荐一个编辑器"><a href="#最后强烈推荐一个编辑器" class="headerlink" title="最后强烈推荐一个编辑器"></a>最后强烈推荐一个编辑器</h3><p><strong>没错！就是它！ VSCode！</strong><br>VSCode是微软推出的一款代码编辑器，支持多种语言，包括Markdown。<br>只需要安装Markdown插件，就可以在VSCode中编辑Markdown文件了。<br>下面我推荐三个插件：</p><blockquote><p>Markdown All in One</p></blockquote><p>在VSCode编辑Markdown文件就靠它</p><blockquote><p>Markdown Preview Enhanced</p></blockquote><p>将原生markdown预览的黑色背景改为白色</p><blockquote><p>Markdown Preview Github Styling</p></blockquote><p>将原生markdown预览的样式改为Github的样式<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPuBb.png" alt="VSCode MD文档编辑页面"></p><h3 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h3><p>还有其他很多Markdown编辑器，比如：</p><blockquote><p>Simplenote<br>Boostnote<br>Inkdrop<br>Yu Writer<br>MarkdownPad</p></blockquote><p>这些编辑器我都没有使用过，有兴趣的可以去试试。<br>好了，这就是我在win系统上使用的Markdown编辑器了，<br>希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Markdown </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Markdown语法</title>
      <link href="/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的使用和Markdown基础语法"><a href="#Hexo的使用和Markdown基础语法" class="headerlink" title="Hexo的使用和Markdown基础语法"></a>Hexo的使用和Markdown基础语法</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo是一个快速、简洁且高效的博客框架，使用Markdown解析文章。markdown是一种轻量级标记语言（在百度百科上抄下来的），总之，就是一种格式，方便写者排版，在Hexo中，markdown是用来写文章的。所以，在写文章之前，你需要先了解一下markdown的基础语法。</p><h3 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h3><blockquote><p>记录学习下markdown的基础语法：</p></blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><ul><li>1️⃣ <strong>一级标题</strong>：<code># 标题内容</code>  </li><li>2️⃣ <strong>二级标题</strong>：<code>## 标题内容</code>  </li><li>3️⃣ <strong>三级标题</strong>：<code>### 标题内容</code></li></ul><p>以此类推，最多六级标题。标题前面的井号数量表示标题级别，井号后面要加一个空格。</p><h3 id="二、文字格式"><a href="#二、文字格式" class="headerlink" title="二、文字格式"></a>二、文字格式</h3><ul><li><code>**加粗的文字**</code> 或者 <code>__加粗的文字__</code>：<strong>加粗字</strong>  </li><li><code>*斜体的文字*</code> 或者 <code>_斜体的文字_</code>：<em>斜体字</em>  </li><li><code>***加粗且斜体的文字***</code> 或者 <code>___加粗且斜体的文字___</code>：<em><strong>加粗斜体字</strong></em>  </li><li><code>~~删除的文字~~</code>：<del>删除线</del></li></ul><p>这些格式可以让文字更加醒目，突出重点。</p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>使用<code>-</code>、<code>*</code>或<code>+</code>作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>- 列表项1 </code><br><code>- 列表项2</code><br><code>- 列表项3</code></p><p>显示效果：</p><ul><li>列表项1</li><li>列表项1</li><li>列表项1</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ul><li>使用数字加点作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>1. 列表项1 </code><br><code>2. 列表项2</code><br><code>3. 列表项3</code></p><p>显示效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h3><ul><li><strong>普通链接</strong>：<code>[链接描述](链接地址)</code><br>示例：<code>[百度一下](https://www.baidu.com)</code><br>显示效果：<a href="https://www.baidu.com/">百度一下</a>  </li><li><strong>带标题的链接</strong>：<code>[链接描述](链接地址 &quot;标题&quot;)</code><br>示例：<code>[百度一下](https://www.baidu.com &quot;百度首页&quot;)</code><br>显示效果：<a href="https://www.baidu.com/" title="百度首页">百度一下</a></li></ul><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><ul><li><strong>插入图片</strong>：<code>![图片描述](图片链接)</code><br>示例：<code>![示例图片](https://i.imgs.ovh/2025/04/13/aAO0p.jpeg)</code><br>显示效果：<br><img src="https://i.imgs.ovh/2025/04/13/aAO0p.jpeg" alt="示例图片"><br>图片描述会显示在图片无法加载时。</li></ul><h2 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h2><ul><li>使用<code>&gt;</code>来表示引用。<br>示例：<code>&gt; 这是一段引用的文字</code><br>显示效果：  <blockquote><p>这是一段引用的文字</p></blockquote></li></ul><h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><h3 id="（一）行内代码"><a href="#（一）行内代码" class="headerlink" title="（一）行内代码"></a>（一）行内代码</h3><ul><li>使用反引号<code>`</code>来标记。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这里是一段`</span>代码   </span><br></pre></td></tr></table></figure>显示效果：<br><code>这里是一段</code>代码</li></ul><h3 id="（二）代码块"><a href="#（二）代码块" class="headerlink" title="（二）代码块"></a>（二）代码块</h3><ul><li>使用三个反引号&#96;&#96;&#96;来标记代码块。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="code">```python</span></span><br><span class="line"><span class="code">$ print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="code">$ ```</span></span><br></pre></td></tr></table></figure><blockquote><p>$号是为了不让代码块被解析为Markdown的转义字符。</p></blockquote>显示效果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>• 使用<code>|</code>来分隔列，<code>-</code>来分隔表头和内容。<br>  示例：<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|列1|列2|列3|</span><br><span class="line">|---|---|---|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><h2 id="九、分割线"><a href="#九、分割线" class="headerlink" title="九、分割线"></a>九、分割线</h2><p>• 使用三个或更多<code>---</code>、<code>***</code>或<code>___</code>来创建分割线。</p><p>示例：<code>---</code>或<code>***</code>或<code>___</code></p><p>显示效果：</p><hr><p>或</p><hr><p>或</p><hr><h2 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h2><ul><li>使用<code>- [ ]</code>表示未完成的任务，<code>- [x]</code>表示已完成的任务。<br>示例：  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务1</span><br><span class="line"><span class="bullet">-</span> [x] 任务2</span><br></pre></td></tr></table></figure>显示效果：<ul><li><input disabled="" type="checkbox"> 任务1</li><li><input checked="" disabled="" type="checkbox"> 任务2</li></ul></li></ul><h2 id="十一、表情符号"><a href="#十一、表情符号" class="headerlink" title="十一、表情符号"></a>十一、表情符号</h2><ul><li>Markdown支持使用表情符号的短代码。<br>示例：<code>:smile:</code><br>显示效果：😄</li></ul><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><ul><li>换行：在行尾添加两个空格即可换行。</li><li>转义字符：使用<code>\</code>来转义特殊字符，比如<code>\*</code>会显示为<code>*</code>。</li></ul><hr><h4 id="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"><a href="#以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪" class="headerlink" title="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"></a>以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪</h4><blockquote><p>最后，Markdown语法还有很多，只是大多不是我常用的，这里就不记录，如果有兴趣的可以去学习一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题-Solitude</title>
      <link href="/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/"/>
      <url>/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/</url>
      
        <content type="html"><![CDATA[<p>第一次使用Hexo，安装了主题Solitude，记录一下安装过程。<br>首先Solitude主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器。</p><h3 id="在根目录下执行以下命令："><a href="#在根目录下执行以下命令：" class="headerlink" title="在根目录下执行以下命令："></a>在根目录下执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>有两种安装方法一种是使用git直接下载主题，一种是使用npm下载主题。<br>我是用npm下载的。所以这里记录的是npm下载的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-solitude</span><br></pre></td></tr></table></figure><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改Hexo配置文件_config.yml，将主题设置为Solitude。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: solitude</span><br></pre></td></tr></table></figure><h3 id="测试主题是否应用成功"><a href="#测试主题是否应用成功" class="headerlink" title="测试主题是否应用成功"></a>测试主题是否应用成功</h3><p>根据Hexo官方文档，我们可以使用以下命令来测试主题是否应用成功：</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="访问本地服务器"><a href="#访问本地服务器" class="headerlink" title="访问本地服务器"></a>访问本地服务器</h3><p>在浏览器中输入一下网址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http://localhost:4000/</span><br></pre></td></tr></table></figure><p>如果看到了Solitude主题的页面，说明主题应用成功。<br>但是这个页面默认是英文的，我们可以修改配置文件_config.yml，将语言设置为中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><p>然后重新生成静态文件，启动本地服务器，访问本地服务器，就可以看到Solitude主题的中文页面了。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>Solitude主题的配置文件是_config.solitude.yml，默认是不存在的需要我们拷贝到根目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ copy .\node_modules\hexo-theme-solitude\_config.yml .\_config.solitude.yml</span><br></pre></td></tr></table></figure><p>_config.solitude.yml配置文件优先级高于_config.yml，所以得在_config.solitude.yml中配置主题。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello-Hexo</title>
      <link href="/2025/04/06/Hello-Hexo/"/>
      <url>/2025/04/06/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>！这是部署的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a> 以获取更多信息。<br>如果在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，或者在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上进行提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个新博客"><a href="#创建一个新博客" class="headerlink" title="创建一个新博客"></a>创建一个新博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名称&quot;</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">写作</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="清除静态文件和缓存文件"><a href="#清除静态文件和缓存文件" class="headerlink" title="清除静态文件和缓存文件"></a>清除静态文件和缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
