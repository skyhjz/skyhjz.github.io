<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>代理模式</title>
      <link href="/2025/04/22/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/22/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><h5 id="1-什么是代理模式"><a href="#1-什么是代理模式" class="headerlink" title="1.什么是代理模式"></a>1.什么是代理模式</h5><ul><li>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理&#x2F;添加新的功能。(也就是AO的P微实现)</li><li>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似</li></ul><h5 id="2-代理模式应用场景"><a href="#2-代理模式应用场景" class="headerlink" title="2.代理模式应用场景"></a>2.代理模式应用场景</h5><ul><li>Spring AOP、日志打印、异常处理、事务控制、权限控制等</li></ul><h5 id="3-代理的分类"><a href="#3-代理的分类" class="headerlink" title="3.代理的分类"></a>3.代理的分类</h5><blockquote><p>静态代理(静态定义代理类)：简单代理模式，是动态代理的理论基础。常见使用在代理模式</p></blockquote><blockquote><p>动态代理(动态生成代理类，也称为Jdk自带动态代理)：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。</p></blockquote><blockquote><p>Cglib 、javaassist（字节码操作库）：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）</p></blockquote><h5 id="4代码示例"><a href="#4代码示例" class="headerlink" title="4代码示例"></a>4代码示例</h5><h6 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h6><p><strong>什么是静态代理</strong></p><ul><li>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li><li>缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服，</li><li>优点：但是可以面相实际对象或者是接口的方式实现代理</li></ul><p><strong>代码演示：</strong></p><ul><li>我有一段这样的代码：（如何能在不修改UserDao接口类的情况下开事务和关闭事务呢）<br><em>接口类</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>运行测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改代码，添加代理类</strong><br><em>代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>添加完静态代理的测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h6><p><strong>什么是动态代理</strong></p><ul><li>动态代理也叫做，JDK代理、接口代理。</li><li>动态代理的对象，是利用JDK的API，动态的在内存中构建代理对象（是根据被代理的接口动态生成代理类的class文件，并加载运行的过程），这就叫动态代理。</li><li>缺点：必须是面向接口，目标业务类必须实现接口</li><li>优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象</li></ul><p><strong>代码演示：</strong></p><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>下面是代理类，可重复使用，不像静态代理那样要自己重复编写代理</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>利用动态代理使用代理方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line">        <span class="comment">//类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> userDaoImpl.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance (loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h6><p><strong>CGLIB动态代理原理</strong></p><ul><li>利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li></ul><p><strong>什么是CGLIB动态代理</strong></p><ul><li>CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不能对 final类进行继承。（CGLIB动态代理需要导入jar包）</li></ul><p><strong>代码演示：</strong><br><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CGLIB动态代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">//代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="built_in">this</span>.targetObject = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理实际方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试CGLIB动态代理</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2025/04/20/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/20/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="设计模式之工厂模式"><a href="#设计模式之工厂模式" class="headerlink" title="设计模式之工厂模式"></a>设计模式之工厂模式</h4><h5 id="什么是工厂模式？"><a href="#什么是工厂模式？" class="headerlink" title="什么是工厂模式？"></a>什么是工厂模式？</h5><ul><li>它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式</li></ul><h5 id="工厂模式好处"><a href="#工厂模式好处" class="headerlink" title="工厂模式好处"></a>工厂模式好处</h5><ul><li>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li></ul><h5 id="为什么要学习工厂设计模式"><a href="#为什么要学习工厂设计模式" class="headerlink" title="为什么要学习工厂设计模式"></a>为什么要学习工厂设计模式</h5><ul><li>不知道你们面试题问到过源码没有，你知道Spring的源码吗，MyBatis的源码吗，等等等 如果你想了解或者学习很多框架的源码，或者你想自己开发自己的框架，就必须先掌握设计模式（工厂设计模式用的是非常非常广泛的）</li></ul><h5 id="Spring开发中的工厂设计模式"><a href="#Spring开发中的工厂设计模式" class="headerlink" title="Spring开发中的工厂设计模式"></a>Spring开发中的工厂设计模式</h5><ol><li><strong>Spring IOC</strong><ul><li>如果看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式</li><li>Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。</li><li>当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。</li></ul></li><li><strong>为什么Spring IOC要使用工厂设计模式创建Bean呢</strong><ul><li>在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）</li><li>Java的三层架构编程，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞</li><li>为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。</li></ul></li></ol><h5 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h5><p><strong>工厂模式分为简单工厂、工厂方法、抽象工厂模式</strong></p><blockquote><p>简单工厂: 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p></blockquote><blockquote><p>工厂方法: 用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p></blockquote><blockquote><p>抽象工厂: 用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</p></blockquote><h6 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h6><p>简单工厂模式: 简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。</p><p><strong>代码演示:</strong><br><em>创建工厂（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建另外一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>创建核心工厂类，由他决定具体调用哪产品</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Milk <span class="title function_">createMilk</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;蒙牛&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;伊利&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>演示创建工厂的具体实例</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MengNiu</span> <span class="variable">mengNiu</span> <span class="operator">=</span>MilkFactory.createMilk(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">        <span class="type">YiLi</span> <span class="variable">yiLi</span> <span class="operator">=</span>MilkFactory.createMilk(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单工厂的优点&#x2F;缺点</strong></p><ul><li><strong>优点:</strong> 简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li><li><strong>缺点:</strong> 很明显工厂类集中了所有实例的创建逻辑，容易违反<a href="https://blog.csdn.net/u013249965/article/details/51779634" title="CSDN的博主JoJo小风有详细的介绍">GRASPR</a>的高内聚的责任分配原则</li></ul><h6 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h6><p><strong>工厂方法模式:</strong> 工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节</p><p><strong>代码演示:</strong><br><em>创建工厂（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口（所有的产品需要new出来必须继承他来实现方法）</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    Milk <span class="title function_">createMilk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的另一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiuFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLiFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MengNiuFactory</span>().createMilk();</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YiLiFactory</span>().createMilk();</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h6><p><em><strong>这个模式如同它的名字，理解起来很抽象，以下内容也是我根据前辈的思路和自己的理解来总结的，</strong></em><br><strong>抽象工厂模式:</strong> </p><ul><li>是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的方式。</li><li>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li><li>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品<blockquote><p>个人理解: 我就以蒙牛举个例子<br>把蒙牛比喻成超级工厂<br>那么蒙牛的子品牌（特仑苏、纯甄等），就是蒙牛创建的其他工厂<br>蒙牛有自己的产品<br>特仑苏有自己的产品<br>纯甄也有自己的产品</p></blockquote></li></ul><p>而它们之间的关系，如图所示：<br> <img src="https://i.imgs.ovh/2025/04/23/cq4pU.png" alt="示例图片"> </p><p><em><strong>我对这个设计模式理解还比较浅薄，就不展示代码了.</strong></em><br>想详细了解抽象工厂模式的，可以参考以下链接：<br><a href="https://liaoxuefeng.com/books/java/design-patterns/creational/abstract-factory/index.html" title="廖雪峰大佬对抽象工厂的理解">廖雪峰的官方网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2025/04/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/18/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h3><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><ul><li>保证一个类只有一个实例，并且提供一个访问该全局访问点</li></ul><h4 id="那些地方用到了单例模式"><a href="#那些地方用到了单例模式" class="headerlink" title="那些地方用到了单例模式"></a>那些地方用到了单例模式</h4><ol><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</li><li>多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</li><li>Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个</li><li>windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例</li></ol><h4 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h4><p><strong>优点：</strong></p><ol><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。</li><li>避免对共享资源的多重占用。</li></ol><p><strong>缺点：</strong></p><ol><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><h4 id="单例模式使用注意事项："><a href="#单例模式使用注意事项：" class="headerlink" title="单例模式使用注意事项："></a>单例模式使用注意事项：</h4><ol><li>使用时不能用反射模式创建单例，否则会实例化一个新的对象</li><li>使用懒单例模式时注意线程安全问题</li><li>饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）</li></ol><h4 id="单例防止反射漏洞攻击"><a href="#单例防止反射漏洞攻击" class="headerlink" title="单例防止反射漏洞攻击"></a>单例防止反射漏洞攻击</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式被侵犯！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择单例创建方式"><a href="#如何选择单例创建方式" class="headerlink" title="如何选择单例创建方式"></a>如何选择单例创建方式</h4><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。 </li><li>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。最好使用饿汉式。</li></ul><h4 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h4><p><strong>（主要使用懒汉和懒汉式）</strong></p><ol><li><strong>饿汉式：</strong> 类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li><li><strong>懒汉式：</strong> 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li><li><strong>静态内部方式：</strong> 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的</li><li><strong>枚举单例：</strong> 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)</li></ol><p><strong>懒汉式</strong></p><ul><li>饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Demo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo1构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> demo1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">s1</span> <span class="operator">=</span> Demo1.getInstance();</span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">s2</span> <span class="operator">=</span> Demo1.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>懒汉式</strong></p><ul><li>懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo2 demo2;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo2构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Demo2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (demo2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demo2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">s1</span> <span class="operator">=</span> Demo2.getInstance();</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">s2</span> <span class="operator">=</span> Demo2.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>静态内部类</strong></li><li>静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo3构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonClassInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Demo3</span> <span class="variable">DEMO_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法没有同步</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.DEMO_3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">s1</span> <span class="operator">=</span> Demo3.getInstance();</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">s2</span> <span class="operator">=</span> Demo3.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>枚举单例式</strong></p><ul><li>枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo4</span> <span class="variable">s1</span> <span class="operator">=</span> Demo4.getInstance();</span><br><span class="line">        <span class="type">Demo4</span> <span class="variable">s2</span> <span class="operator">=</span> Demo4.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> Demo4 demo4;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;枚举Demo私有构造参数&quot;</span>);</span><br><span class="line">            demo4 = <span class="keyword">new</span> <span class="title class_">Demo4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Demo4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> demo4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>双重检测锁方式</strong></li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重检测锁方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Demo5 demo5;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo5</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;私有Demo4构造参数初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Demo5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (demo5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Demo5.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (demo5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                        demo5 = <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> demo5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Demo5</span> <span class="variable">s1</span> <span class="operator">=</span> Demo5.getInstance();</span><br><span class="line">            <span class="type">Demo5</span> <span class="variable">s2</span> <span class="operator">=</span> Demo5.getInstance();</span><br><span class="line">            System.out.println(s1 == s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>个人总结</strong><br>在实际开发过程中我用到单例模式最多的情况就是，模块与模块之间的解耦<br>简化图：<br><img src="https://i.imgs.ovh/2025/04/22/cUMIb.png" alt="不使用单例模式"><br><img src="https://i.imgs.ovh/2025/04/22/cUQZ1.png" alt="使用单例模式"><br><em>以上仅限个人看法，其实单例模式还有很多应用场景；只是我是个菜鸟，工作这么久也就这种场景使用过单例模式。</em></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习下设计模式</title>
      <link href="/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近打算面试下看看自己已经落后时代多少了，面试过程中发现自己对设计模式的认识和理解不够，所以就打算重新学习下设计模式。</p><h3 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h3><ul><li>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性</li></ul><h3 id="2-为什么要学习设计模式"><a href="#2-为什么要学习设计模式" class="headerlink" title="2. 为什么要学习设计模式"></a>2. 为什么要学习设计模式</h3><ul><li>看懂源代码：如果你不懂设计模式去看Jdk、Spring、SpringMVC、IO等等等等的源码，你会很迷茫，你会寸步难行</li><li>看看前辈的代码：你去个公司难道都是新项目让你接手？很有可能是接盘的，前辈的开发难道不用设计模式？</li><li>编写自己的理想中的好代码：使用设计模式的功能块复用性强，可扩展性强，我个人反正是这样认为的</li></ul><h3 id="3-设计模式分类"><a href="#3-设计模式分类" class="headerlink" title="3. 设计模式分类"></a>3. 设计模式分类</h3><p> <img src="https://i.imgs.ovh/2025/04/19/jGCmc.png" alt="设计模式分类类">  </p><ul><li>创建型模式，共五种：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>单例模式</strong>、建造者模式、<strong>原型模式</strong>。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br><em><strong>这里面重点描述的几个是我们开发中最常用的</strong></em></li></ul><h3 id="4-设计模式的六大原则"><a href="#4-设计模式的六大原则" class="headerlink" title="4. 设计模式的六大原则"></a>4. 设计模式的六大原则</h3><p><img src="https://i.imgs.ovh/2025/04/19/jG7P9.png" alt="设计模式的六大原则">  </p><ul><li><strong>开放封闭原则（Open Close Principle）</strong><ul><li><strong>原则思想</strong>：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化。</li><li><strong>描述</strong>：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。</li><li><strong>优点</strong>：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。</li></ul></li><li><strong>里氏代换原则（Liskov Substitution Principle）</strong><ul><li><strong>原则思想</strong>：使用的基类可以在任何地方使用继承的子类，完美的替换基类。</li><li><strong>大概意思</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。</li><li><strong>优点</strong>：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。</li></ul></li><li><strong>单一职责原则（Principle of single responsibility）</strong><ul><li><strong>原则思想</strong>：一个方法只负责一件事情。</li><li><strong>描述</strong>：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。</li><li><strong>优点</strong>：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。</li></ul></li><li><strong>依赖倒转原则（Dependence Inversion Principle）</strong><ul><li>依赖倒置原则的核心思想是面向接口编程。</li><li>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类。</li><li>这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。</li></ul></li><li><strong>接口隔离原则（Interface Segregation Principle）</strong><ul><li>使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便，降低依赖，降低耦合。</li><li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li></ul></li><li><strong>迪米特法则（最少知道原则）（Demeter Principle）</strong><ul><li>一个对象应当对其他对象有尽可能少地了解，简称类间解耦</li><li>大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。</li><li>例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业支付到微信零钱小计</title>
      <link href="/2025/04/12/%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1%E5%B0%8F%E8%AE%A1/"/>
      <url>/2025/04/12/%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1%E5%B0%8F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近企业网站做了个活动，用户在活动期间可以获得积分，积分可以兑换礼品现金红包提现到用户的微信钱包中，在参与开发这个功能时遇到的问题在这里记录下。</p><h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><p><strong>请求体</strong></p><ol><li>请求URL中的参数组装 需要把参数名ASCII字典序排序最后加上<br>key&#x3D;{微信商户平台(pay.weixin.qq.com)-&gt;账户设置-&gt;API安全-&gt;密钥设置}</li><li>请求URL中的参数对应请求体内的XML参数都要有，编码要全部设置为 UTF-8</li><li>请求体内需要添加 <strong>apiclient_cert.p12</strong> 证书</li><li>最终返回结果 成功即为成功，失败需要以下几步操作:<ul><li>查询企业付款 来确认支付结果为失败还是转账中</li><li>若为失败根据失败信息判断以原订单号重新发起请求还是以新的订单号发起请求</li></ul></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p><strong>SIGNERROR 签名错误</strong></p><ul><li>请求时编码要是全部设置为 UTF-8;</li><li>key 传的不正确，key 和 app_id 一定要对的上，如果已经接入过微信支付，要确认这里的传的就是微信支付中用到的 key</li><li>签名的参数和传递给微信的参数不匹配，一般是拼接参数不正确导致的，DEMO 中参数</li></ul><p>已经配置好了，只要不修改参数的个数基本不会有问题;</p><p><strong>NO_AUTH 此 IP 地址不允许调用接口</strong></p><ul><li>新版本商户后台默认需要 IP 校验，有些人填 192.168.1.XXX 这种内网 IP 是不行的，可以<br>访问 ip168 之类的网站获取自己的外网地址；在开发阶段也可以先关掉校验，方便本地调试;</li></ul><p><strong>OPENID_ERROR Openid 错误</strong></p><ul><li>app_id 和 openid 没对上导致的，比如公司同时开通了小程序和微信服务号，两个应用关<br>联了同一个商户，极有可能就是用的小程序 app_id 作为参数，但是传的是微信服务号关联<br>的 openid</li></ul><p><strong>注意项</strong><br>Java需要用到：apiclient_cert.p12证书、证书秘钥、AppId、openId、商品号</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win系统上编辑Markdown软件使用心得</title>
      <link href="/2025/04/10/Win%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BC%96%E8%BE%91Markdown%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2025/04/10/Win%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BC%96%E8%BE%91Markdown%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于Hexo是使用Markdown语法编写博客，<br>而在记事本上写Markdown语法是非常麻烦的，主要是预览不到显示效果。<br>win系统上有很多编辑器，我把网上有些热度的编辑器都下载下来使用下，在这里记录下我在使用这些软件的优缺点。</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora可以说是win系统上推荐度最高的Markdown编辑器，搜索首推就是它。<br>当然它也没有辜负大家对他的推荐，<br>功能非常强大，<br>支持实时预览，<br>支持更换主题，<br>支持导出PDF，支持导出Word，还有其他很多格式，<br>最主要是可以全屏编辑，不像有些编辑器左面总是有两个框框，<br>可以说是win系统上最好用的Markdown编辑器；<br>最大的缺点就是需要付费。<br>下面展示两个Typora图片，源码模式和实时预览：<br><img src="https://i.imgs.ovh/2025/04/13/aRi4c.png" alt="源码模式"><br><img src="https://i.imgs.ovh/2025/04/13/aRNk9.png" alt="实时预览"><br>最终贫穷的我还是放弃了Typora。</p><h3 id="微信Markdown编辑器"><a href="#微信Markdown编辑器" class="headerlink" title="微信Markdown编辑器"></a>微信Markdown编辑器</h3><p>应该很多人不是很了解这个，它不是软件而是一个网址可以直接在线编辑Markdown，<br>但是它的功能有限，只能导出html和md格式，支持实时预览，不过是手机端的，如果和我一样只是简单的写博客，记录自己的一时的想法，还是可以的。<br><a href="https://doocs-md.pages.dev/" title="微信Markdown编辑器">微信Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/13/akaHA.png" alt="微信Markdown编辑器"></p><h3 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h3><p>这是也是个网页，功能强大，支持实时预览，有兴趣的可以去看看<br><a href="https://zybuluo.com/mdeditor" title="Cmd Markdown编辑器">Cmd Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPRkr.png" alt="Cmd Markdown编辑器"></p><h3 id="Notable"><a href="#Notable" class="headerlink" title="Notable"></a>Notable</h3><p>这是一款开源的Markdown编辑器，界面还行，就是左面总是有两个框框 不能关闭！<br>不支持实时预览，不过能预览就是要点击上面的Edit按钮，所以在编辑md文件的时候总是去点击Edit按钮，比较麻烦。最终让我放弃的原因是它的功能栏是英文的，不能切换中文。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aMmf4.png" alt="Notable编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aMueA.png" alt="Notable预览模式"></p><h3 id="MarkText"><a href="#MarkText" class="headerlink" title="MarkText"></a>MarkText</h3><p>这也是一个开源的Markdown编辑器，界面不错，不过我看GitHub上已经很久没有更新了，<br>下载的时候找到了个MarkText中文特别版，默认界面很像Typora，如果不习惯全屏的也可以打开侧边栏，功能很多，日常使用完全足够了。<br>这个编辑器不支持实时预览，预览界面可以用Ctrl+E快捷键打开。Typora最好的替代工具。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPVsL.png" alt="MarkText编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aPbKx.png" alt="MarkText预览模式"></p><h3 id="Zettlr"><a href="#Zettlr" class="headerlink" title="Zettlr"></a>Zettlr</h3><p>这个编辑器让我一言难尽啊，它很强大、很专业。<br>功能很多，但我只是想要一个简单的Markdown编辑器，够日常使用就行。<br>有兴趣的可以去看看<br><a href="https://www.zettlr.com/" title="Zettlr官网">Zettlr官网</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPQkH.png" alt="Zettlr"></p><h3 id="最后强烈推荐一个编辑器"><a href="#最后强烈推荐一个编辑器" class="headerlink" title="最后强烈推荐一个编辑器"></a>最后强烈推荐一个编辑器</h3><p><strong>没错！就是它！ VSCode！</strong><br>VSCode是微软推出的一款代码编辑器，支持多种语言，包括Markdown。<br>只需要安装Markdown插件，就可以在VSCode中编辑Markdown文件了。<br>下面我推荐三个插件：</p><blockquote><p>Markdown All in One</p></blockquote><p>在VSCode编辑Markdown文件就靠它</p><blockquote><p>Markdown Preview Enhanced</p></blockquote><p>将原生markdown预览的黑色背景改为白色</p><blockquote><p>Markdown Preview Github Styling</p></blockquote><p>将原生markdown预览的样式改为Github的样式<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPuBb.png" alt="VSCode MD文档编辑页面"></p><h3 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h3><p>还有其他很多Markdown编辑器，比如：</p><blockquote><p>Simplenote<br>Boostnote<br>Inkdrop<br>Yu Writer<br>MarkdownPad</p></blockquote><p>这些编辑器我都没有使用过，有兴趣的可以去试试。<br>好了，这就是我在win系统上使用的Markdown编辑器了，<br>希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Markdown </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的使用和Markdown基础语法</title>
      <link href="/2025/04/08/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8CMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/04/08/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8CMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的使用和Markdown基础语法"><a href="#Hexo的使用和Markdown基础语法" class="headerlink" title="Hexo的使用和Markdown基础语法"></a>Hexo的使用和Markdown基础语法</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo是一个快速、简洁且高效的博客框架，使用Markdown解析文章。markdown是一种轻量级标记语言（在百度百科上抄下来的），总之，就是一种格式，方便写者排版，在Hexo中，markdown是用来写文章的。所以，在写文章之前，你需要先了解一下markdown的基础语法。</p><h3 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h3><blockquote><p>记录学习下markdown的基础语法：</p></blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><ul><li>1️⃣ <strong>一级标题</strong>：<code># 标题内容</code>  </li><li>2️⃣ <strong>二级标题</strong>：<code>## 标题内容</code>  </li><li>3️⃣ <strong>三级标题</strong>：<code>### 标题内容</code></li></ul><p>以此类推，最多六级标题。标题前面的井号数量表示标题级别，井号后面要加一个空格。</p><h3 id="二、文字格式"><a href="#二、文字格式" class="headerlink" title="二、文字格式"></a>二、文字格式</h3><ul><li><code>**加粗的文字**</code> 或者 <code>__加粗的文字__</code>：<strong>加粗字</strong>  </li><li><code>*斜体的文字*</code> 或者 <code>_斜体的文字_</code>：<em>斜体字</em>  </li><li><code>***加粗且斜体的文字***</code> 或者 <code>___加粗且斜体的文字___</code>：<em><strong>加粗斜体字</strong></em>  </li><li><code>~~删除的文字~~</code>：<del>删除线</del></li></ul><p>这些格式可以让文字更加醒目，突出重点。</p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>使用<code>-</code>、<code>*</code>或<code>+</code>作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>- 列表项1 </code><br><code>- 列表项2</code><br><code>- 列表项3</code></p><p>显示效果：</p><ul><li>列表项1</li><li>列表项1</li><li>列表项1</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ul><li>使用数字加点作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>1. 列表项1 </code><br><code>2. 列表项2</code><br><code>3. 列表项3</code></p><p>显示效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h3><ul><li><strong>普通链接</strong>：<code>[链接描述](链接地址)</code><br>示例：<code>[百度一下](https://www.baidu.com)</code><br>显示效果：<a href="https://www.baidu.com/">百度一下</a>  </li><li><strong>带标题的链接</strong>：<code>[链接描述](链接地址 &quot;标题&quot;)</code><br>示例：<code>[百度一下](https://www.baidu.com &quot;百度首页&quot;)</code><br>显示效果：<a href="https://www.baidu.com/" title="百度首页">百度一下</a></li></ul><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><ul><li><strong>插入图片</strong>：<code>![图片描述](图片链接)</code><br>示例：<code>![示例图片](https://i.imgs.ovh/2025/04/13/aAO0p.jpeg)</code><br>显示效果：<br><img src="https://i.imgs.ovh/2025/04/13/aAO0p.jpeg" alt="示例图片"><br>图片描述会显示在图片无法加载时。</li></ul><h2 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h2><ul><li>使用<code>&gt;</code>来表示引用。<br>示例：<code>&gt; 这是一段引用的文字</code><br>显示效果：  <blockquote><p>这是一段引用的文字</p></blockquote></li></ul><h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><h3 id="（一）行内代码"><a href="#（一）行内代码" class="headerlink" title="（一）行内代码"></a>（一）行内代码</h3><ul><li>使用反引号<code>`</code>来标记。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这里是一段`</span>代码   </span><br></pre></td></tr></table></figure>显示效果：<br><code>这里是一段</code>代码</li></ul><h3 id="（二）代码块"><a href="#（二）代码块" class="headerlink" title="（二）代码块"></a>（二）代码块</h3><ul><li>使用三个反引号&#96;&#96;&#96;来标记代码块。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="code">```python</span></span><br><span class="line"><span class="code">$ print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="code">$ ```</span></span><br></pre></td></tr></table></figure><blockquote><p>$号是为了不让代码块被解析为Markdown的转义字符。</p></blockquote>显示效果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>• 使用<code>|</code>来分隔列，<code>-</code>来分隔表头和内容。<br>  示例：<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|列1|列2|列3|</span><br><span class="line">|---|---|---|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><h2 id="九、分割线"><a href="#九、分割线" class="headerlink" title="九、分割线"></a>九、分割线</h2><p>• 使用三个或更多<code>---</code>、<code>***</code>或<code>___</code>来创建分割线。</p><p>示例：<code>---</code>或<code>***</code>或<code>___</code></p><p>显示效果：</p><hr><p>或</p><hr><p>或</p><hr><h2 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h2><ul><li>使用<code>- [ ]</code>表示未完成的任务，<code>- [x]</code>表示已完成的任务。<br>示例：  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务1</span><br><span class="line"><span class="bullet">-</span> [x] 任务2</span><br></pre></td></tr></table></figure>显示效果：<ul><li><input disabled="" type="checkbox"> 任务1</li><li><input checked="" disabled="" type="checkbox"> 任务2</li></ul></li></ul><h2 id="十一、表情符号"><a href="#十一、表情符号" class="headerlink" title="十一、表情符号"></a>十一、表情符号</h2><ul><li>Markdown支持使用表情符号的短代码。<br>示例：<code>:smile:</code><br>显示效果：😄</li></ul><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><ul><li>换行：在行尾添加两个空格即可换行。</li><li>转义字符：使用<code>\</code>来转义特殊字符，比如<code>\*</code>会显示为<code>*</code>。</li></ul><hr><h4 id="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"><a href="#以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪" class="headerlink" title="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"></a>以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪</h4><blockquote><p>最后，Markdown语法还有很多，只是大多不是我常用的，这里就不记录，如果有兴趣的可以去学习一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo安装主题Solitude</title>
      <link href="/2025/04/06/Hexo%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98Solitude/"/>
      <url>/2025/04/06/Hexo%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98Solitude/</url>
      
        <content type="html"><![CDATA[<p>第一次使用Hexo，安装了主题Solitude，记录一下安装过程。<br>首先Solitude主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器。</p><h3 id="在根目录下执行以下命令："><a href="#在根目录下执行以下命令：" class="headerlink" title="在根目录下执行以下命令："></a>在根目录下执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>有两种安装方法一种是使用git直接下载主题，一种是使用npm下载主题。<br>我是用npm下载的。所以这里记录的是npm下载的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-solitude</span><br></pre></td></tr></table></figure><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改Hexo配置文件_config.yml，将主题设置为Solitude。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: solitude</span><br></pre></td></tr></table></figure><h3 id="测试主题是否应用成功"><a href="#测试主题是否应用成功" class="headerlink" title="测试主题是否应用成功"></a>测试主题是否应用成功</h3><p>根据Hexo官方文档，我们可以使用以下命令来测试主题是否应用成功：</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="访问本地服务器"><a href="#访问本地服务器" class="headerlink" title="访问本地服务器"></a>访问本地服务器</h3><p>在浏览器中输入一下网址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http://localhost:4000/</span><br></pre></td></tr></table></figure><p>如果看到了Solitude主题的页面，说明主题应用成功。<br>但是这个页面默认是英文的，我们可以修改配置文件_config.yml，将语言设置为中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><p>然后重新生成静态文件，启动本地服务器，访问本地服务器，就可以看到Solitude主题的中文页面了。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>Solitude主题的配置文件是_config.solitude.yml，默认是不存在的需要我们拷贝到根目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ copy .\node_modules\hexo-theme-solitude\_config.yml .\_config.solitude.yml</span><br></pre></td></tr></table></figure><p>_config.solitude.yml配置文件优先级高于_config.yml，所以得在_config.solitude.yml中配置主题。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2025/04/06/hello-world/"/>
      <url>/2025/04/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>！这是部署的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a> 以获取更多信息。<br>如果在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，或者在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上进行提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个新博客"><a href="#创建一个新博客" class="headerlink" title="创建一个新博客"></a>创建一个新博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;博客名称&quot;</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">写作</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="清除静态文件和缓存文件"><a href="#清除静态文件和缓存文件" class="headerlink" title="清除静态文件和缓存文件"></a>清除静态文件和缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
