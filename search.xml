<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式-适配者模式</title>
      <link href="/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之适配器模式"><a href="#设计模式之适配器模式" class="headerlink" title="设计模式之适配器模式"></a>设计模式之适配器模式</h3><h4 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h4><ul><li>适配器模式是一种结构性设计模式，它将一个类的接口转换成客户端所期望的另一个接口。</li><li>适配器模式使得原本由于接口不兼容而不能一起工作的类能够协同工作。</li></ul><h4 id="在Java中适配器模式通常分为两种类型：类适配器和对象适配器。"><a href="#在Java中适配器模式通常分为两种类型：类适配器和对象适配器。" class="headerlink" title="在Java中适配器模式通常分为两种类型：类适配器和对象适配器。"></a>在Java中适配器模式通常分为两种类型：类适配器和对象适配器。</h4><ol><li><strong>类适配器:</strong> 类适配器通过多重继承实现，适配器类同时继承目标类并实现适配者类接口。通过继承目标类，适配器类可以访目标类的方法和属性；通过实现适配者类接口，适配器类可以将适配者类的方法转换为目标类的方法。</li><li><strong>对象适配器:</strong> 对象适配器通过组合实现，适配器类持有适配者类的实例，并同时实现目类的接口。通过持有适配者类的实例，适配器类可以调用适配者类的方法；通过实现目标类的接口，适配器类可以将适配者类的方法转换为目标类的方法。</li></ol><p><em>适配器模式的主要作用是解决两不兼容接口之间的问题，它可以使得原本无法协同工作的类能够一起工作</em><br>如图所示：<br><img src="https://i.imgs.ovh/2025/05/01/rqgW9.png" alt="适配者模式图解" title="适配者模式"></p><p>后续会更新具体的代码实现…</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 适配者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之策略模式"><a href="#设计模式之策略模式" class="headerlink" title="设计模式之策略模式"></a>设计模式之策略模式</h3><h4 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h4><ul><li>策略模式的用意是针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。</li></ul><ol><li>例如：我要做一个不同会员打折力度不同的三种策略，初级会员，中级会员，高级会员（三种不同的计算）。</li><li>例如：我要一个支付模块，我要有微信支付、支付宝支付、银联支付等</li></ol><h4 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h4><ul><li>优点：<ol><li>算法可以自由切换。 </li><li>避免使用多重条件判断。 </li><li>扩展性非常良好.</li></ol></li><li>缺点：<ol><li>策略类会增多。</li><li>所有策略类都需要对外暴露。</li></ol></li></ul><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><ul><li><strong>模拟支付模块有微信支付、支付宝支付、银联支付</strong></li></ul><ol><li><em><strong>定义抽象的公共方法</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//策略模式 定义抽象方法 所有支持公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line"><span class="comment">// 支付逻辑方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em><strong>定义实现微信支付</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PayStrategyA</span> <span class="keyword">extends</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em><strong>定义实现支付宝支付</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PayStrategyB</span> <span class="keyword">extends</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em><strong>定义实现银联支付</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PayStrategyC</span> <span class="keyword">extends</span> <span class="title class_">PayStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银联支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em><strong>定义下文维护算法策略</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上下文维护算法策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    PayStrategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(PayStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><em><strong>测试</strong></em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClientTestStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Context context;</span><br><span class="line">        <span class="comment">//使用支付逻辑A</span></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">PayStrategyA</span>());</span><br><span class="line">        context.algorithmInterface();</span><br><span class="line">        <span class="comment">//使用支付逻辑B</span></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">PayStrategyB</span>());</span><br><span class="line">        context.algorithmInterface();</span><br><span class="line">        <span class="comment">//使用支付逻辑C</span></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">PayStrategyC</span>());</span><br><span class="line">        context.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之原型模式"><a href="#设计模式之原型模式" class="headerlink" title="设计模式之原型模式"></a>设计模式之原型模式</h3><h4 id="什么是原型模式"><a href="#什么是原型模式" class="headerlink" title="什么是原型模式"></a>什么是原型模式</h4><ul><li>原型设计模式简单来说就是克隆</li><li>原型表明了有一个样板实例，这个原型是可定制的。原型模式多用于创建复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可使程序运行更高效。</li></ul><h4 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h4><ol><li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。这时我们就可以通过原型拷贝避免这些消耗。</li><li>通过new产生的一个对象需要非常繁琐的数据准备或者权限，这时可以使用原型模式。</li><li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。<blockquote><p>我们Spring框架中的多例就是使用原型。</p></blockquote></li></ol><h4 id="原型模式的使用方式"><a href="#原型模式的使用方式" class="headerlink" title="原型模式的使用方式"></a>原型模式的使用方式</h4><ol><li>实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</li><li>重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此Prototype类需要将clone方法的作用域修改为public类型。</li></ol><h4 id="原型模式的浅复制和深复制"><a href="#原型模式的浅复制和深复制" class="headerlink" title="原型模式的浅复制和深复制"></a>原型模式的浅复制和深复制</h4><ol><li>浅复制：只是拷贝了基本类型的数据，而引用类型数据，只是拷贝了一份引用地址，并没有拷贝内容。</li><li>深复制：在计算机中开辟了一块新的内存地址用于存放复制的对象。</li></ol><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p><em><strong>创建User类</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; phones;</span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//重点，如果要连带引用类型一起复制，需要添加底下一条代码，如果不加就对于是复制了引用地址</span></span><br><span class="line">            user.phones = (ArrayList&lt;String&gt;) <span class="built_in">this</span>.phones.clone();<span class="comment">//设置深复制</span></span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略所有属性Git Set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>测试复制</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建User原型对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; phones = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        phones.add(<span class="string">&quot;12345678900&quot;</span>);</span><br><span class="line">        user.setPhones(phones);</span><br><span class="line">        <span class="comment">//copy一个user对象,并且对象的属性</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> user.clone();</span><br><span class="line">        user2.setPassword(<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        <span class="comment">//查看俩个对象是否是一个</span></span><br><span class="line">        System.out.println(user == user2);</span><br><span class="line">        <span class="comment">//查看属性内容</span></span><br><span class="line">        System.out.println(user.getName() + <span class="string">&quot; | &quot;</span> + user2.getName());</span><br><span class="line">        System.out.println(user.getPassword() + <span class="string">&quot; | &quot;</span> + user2.getPassword());</span><br><span class="line">        <span class="comment">//查看对于引用类型拷贝</span></span><br><span class="line">        System.out.println(user.getPhones() == user2.getPhones());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果不需要深复制，需要删除User中以下代码</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认引用类型为浅复制，这是设置了深复制</span></span><br><span class="line">user.phones = (ArrayList&lt;String&gt;) <span class="built_in">this</span>.phones.clone();</span><br></pre></td></tr></table></figure><p><strong>下一个策略模式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-外观模式</title>
      <link href="/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式-外观模式"><a href="#设计模式-外观模式" class="headerlink" title="设计模式-外观模式"></a>设计模式-外观模式</h3><h4 id="什么是外观模式"><a href="#什么是外观模式" class="headerlink" title="什么是外观模式"></a>什么是外观模式</h4><ul><li><strong>外观模式:</strong> 也叫门面模式，隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</li><li>它向现有的系统添加一个接口，用这一个接口来隐藏实际的系统的复杂性。</li><li>使用外观模式，他外部看起来就是一个接口，其实他的内部有很多复杂的接口已经被实现</li></ul><h4 id="外观模式举例"><a href="#外观模式举例" class="headerlink" title="外观模式举例"></a>外观模式举例</h4><ul><li>比如我们在注册用户的时候，需要调用短信接口、邮件接口、微信推送接口。</li><li>我们可以使用外观模式，将这些接口封装成一个接口，然后调用这个接口即可。</li></ul><p><em><strong>创建短信接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;短信消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>创建邮件接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送邮件消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EamilSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EamilSmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">EamilSmsService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>创建微信推送接口</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//微信消息推送</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeiXinSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiXinSmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">WeiXinSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSms</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送微信消息推送&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>创建门面</strong></em><br><em>门面看起来很简单使用，复杂的东西以及被门面给封装好了</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    SmsService SmsService;</span><br><span class="line">    EamilSmsService eamilSmsService;</span><br><span class="line">    WeiXinSmsService weiXinSmsService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Computer</span><span class="params">()</span> &#123;</span><br><span class="line">        smsService = <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        eamilSmsService = <span class="keyword">new</span> <span class="title class_">EamilSmsServiceImpl</span>();</span><br><span class="line">        weiXinSmsService = <span class="keyword">new</span> <span class="title class_">WeiXinSmsServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只需要调用它</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        smsService.sendSms();</span><br><span class="line">        eamilSmsService.sendSms();</span><br><span class="line">        weiXinSmsService.sendSms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>启动测试</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//普通模式需要这样</span></span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">EamilSmsService</span> <span class="variable">eamilSmsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EamilSmsServiceImpl</span>();</span><br><span class="line">        <span class="type">WeiXinSmsService</span> <span class="variable">weiXinSmsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeiXinSmsServiceImpl</span>();</span><br><span class="line">        smsService.sendSms();</span><br><span class="line">        eamilSmsService.sendSms();</span><br><span class="line">        weiXinSmsService.sendSms();</span><br><span class="line">        <span class="comment">//利用外观模式简化方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>().sendMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下一个原型模式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 外观模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板方法模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式-模板方法模式"><a href="#设计模式-模板方法模式" class="headerlink" title="设计模式-模板方法模式"></a>设计模式-模板方法模式</h3><h4 id="什么是模板方法"><a href="#什么是模板方法" class="headerlink" title="什么是模板方法"></a>什么是模板方法</h4><ul><li>模板方法模式：定义一个操作中的算法骨架（父类），而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构来重定义该算法的</li></ul><h4 id="什么时候使用模板方法"><a href="#什么时候使用模板方法" class="headerlink" title="什么时候使用模板方法"></a>什么时候使用模板方法</h4><ul><li>实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分需要改变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现</li></ul><h4 id="实际开发中应用场景哪里用到了模板方法"><a href="#实际开发中应用场景哪里用到了模板方法" class="headerlink" title="实际开发中应用场景哪里用到了模板方法"></a>实际开发中应用场景哪里用到了模板方法</h4><ul><li>很多框架中都有用到了模板方法模式，例如：数据库访问的封装、Junit单元测试、servlet中关于doGet&#x2F;doPost方法的调用等</li></ul><h4 id="现实生活中的模板方法"><a href="#现实生活中的模板方法" class="headerlink" title="现实生活中的模板方法"></a>现实生活中的模板方法</h4><p><strong>例如:</strong><br>去餐厅吃饭，餐厅给我们提供了一个模板就是：看菜单，点菜，吃饭，付款，走人 （这里 “点菜和付款” 是不确定的由子类来完成的，其他的则是一个模板。）</p><h4 id="代码实现模板方法模式"><a href="#代码实现模板方法模式" class="headerlink" title="代码实现模板方法模式"></a>代码实现模板方法模式</h4><p><em><strong>先定义一个模板。把模板中的点菜和付款，让子类来实现。</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RestaurantTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 1.看菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;看菜单&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.点菜业务</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">spotMenu</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 3.吃饭业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">havingDinner</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.付款业务</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 5.离开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GoR</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;离开&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模板通用结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        menu();</span><br><span class="line">        spotMenu();</span><br><span class="line">        havingDinner();</span><br><span class="line">        payment();</span><br><span class="line">        GoR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>具体的模板方法子类 1</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestaurantLaMianImpl</span> <span class="keyword">extends</span> <span class="title class_">RestaurantTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">spotMenu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拉面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;13元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>具体的模板方法子类 2</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestaurantChaoFanImpl</span> <span class="keyword">extends</span> <span class="title class_">RestaurantTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">spotMenu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;12元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>客户端测试</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用第一个模板实例</span></span><br><span class="line">        <span class="type">RestaurantTemplate</span> <span class="variable">restaurantTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestaurantLaMianImpl</span>();</span><br><span class="line">        restaurantTemplate.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下一个外观模式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-建造者模式</title>
      <link href="/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式-建造者模式"><a href="#设计模式-建造者模式" class="headerlink" title="设计模式-建造者模式"></a>设计模式-建造者模式</h3><h4 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h4><ul><li>建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的方式进行创建。</li><li>工厂类模式是提供的是创建单个类的产品</li><li>而建造者模式则是将各种产品集中起来进行管理，用来具有不同的属性的产品</li></ul><p><strong>建造者模式通常包括下面几个角色：</strong></p><ol><li><strong>抽象建造者（Builder）:</strong> 给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。</li><li><strong>具体建造者（Concrete Builder）:</strong> 实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造过程完成后，提供产品的实例。</li><li><strong>指挥者（Director）:</strong> 调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li><li><strong>产品（Product）:</strong> 要创建的复杂对象。</li></ol><h4 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="headerlink" title="建造者模式的使用场景"></a>建造者模式的使用场景</h4><p><strong>使用场景：</strong></p><ol><li>需要生成的对象具有复杂的内部结构。</li><li>需要生成的对象内部属性本身相互依赖。</li></ol><ul><li>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序</li><li>Java中的StringBuilder就是建造者模式创建的，他把一个单个字符的char数组组合起来</li><li>Spring不是建造者模式，它提供的操作应该是对于字符串本身的一些操作，而不是创建或改变一个字符串。</li></ul><h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><ul><li><p><em><strong>建立一个装备对象Arms</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装备类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arms</span> &#123;</span><br><span class="line">    <span class="comment">//头盔</span></span><br><span class="line">    <span class="keyword">private</span> String helmet;</span><br><span class="line">    <span class="comment">//防具</span></span><br><span class="line">    <span class="keyword">private</span> String armor;</span><br><span class="line">    <span class="comment">//武器</span></span><br><span class="line">    <span class="keyword">private</span> String weapon;</span><br><span class="line">    <span class="comment">//省略Git和Set方法</span></span><br></pre></td></tr></table></figure></li><li><p><em><strong>创建Builder接口</strong></em><br><em>给出一个抽象接口，以规范产品对象的各个组成成分的建造，这个接口只是规范</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderHelmetMurder</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderArmorMurder</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderWeaponMurder</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderHelmetYanLong</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderArmorYanLong</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">builderWeaponYanLong</span><span class="params">()</span>;</span><br><span class="line">    Arms <span class="title function_">BuilderArms</span><span class="params">()</span>; <span class="comment">//组装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>创建Builder实现类</strong></em><br><em>这个类主要实现复杂对象创建的哪些部分需要什么属性</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArmsBuilder</span> <span class="keyword">implements</span> <span class="title class_">PersonBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Arms arms;</span><br><span class="line">    <span class="comment">//创建一个Arms实例,用于调用set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArmsBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">        arms = <span class="keyword">new</span> <span class="title class_">Arms</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderHelmetMurder</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setHelmet(<span class="string">&quot;A头盔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderArmorMurder</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setArmor(<span class="string">&quot;A防具&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderWeaponMurder</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setWeapon(<span class="string">&quot;A武器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderHelmetYanLong</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setHelmet(<span class="string">&quot;B头盔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderArmorYanLong</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setArmor(<span class="string">&quot;B防具&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderWeaponYanLong</span><span class="params">()</span> &#123;</span><br><span class="line">        arms.setWeapon(<span class="string">&quot;B武器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Arms <span class="title function_">BuilderArms</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arms;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>创建Director</strong></em><br> <em>调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDirector</span> &#123;</span><br><span class="line">    <span class="comment">//组装</span></span><br><span class="line">    <span class="keyword">public</span> Arms <span class="title function_">constructPerson</span><span class="params">(PersonBuilder pb)</span> &#123;</span><br><span class="line">        pb.builderHelmetYanLong();</span><br><span class="line">        pb.builderArmorMurder();</span><br><span class="line">        pb.builderWeaponMurder();</span><br><span class="line">        <span class="keyword">return</span> pb.BuilderArms();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里进行测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PersonDirector</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonDirector</span>();</span><br><span class="line">        <span class="type">Arms</span> <span class="variable">arms</span> <span class="operator">=</span> pb.constructPerson(<span class="keyword">new</span> <span class="title class_">ArmsBuilder</span>());</span><br><span class="line">        System.out.println(arms.getHelmet());</span><br><span class="line">        System.out.println(arms.getArmor());</span><br><span class="line">        System.out.println(arms.getWeapon());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>下一个：模板方法模式</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式-代理模式"></a>设计模式-代理模式</h3><h4 id="1-什么是代理模式"><a href="#1-什么是代理模式" class="headerlink" title="1.什么是代理模式"></a>1.什么是代理模式</h4><ul><li>通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理&#x2F;添加新的功能。(也就是AO的P微实现)</li><li>代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似</li></ul><h4 id="2-代理模式应用场景"><a href="#2-代理模式应用场景" class="headerlink" title="2.代理模式应用场景"></a>2.代理模式应用场景</h4><ul><li>Spring AOP、日志打印、异常处理、事务控制、权限控制等</li></ul><h4 id="3-代理的分类"><a href="#3-代理的分类" class="headerlink" title="3.代理的分类"></a>3.代理的分类</h4><blockquote><p>静态代理(静态定义代理类)：简单代理模式，是动态代理的理论基础。常见使用在代理模式</p></blockquote><blockquote><p>动态代理(动态生成代理类，也称为Jdk自带动态代理)：使用反射完成代理。需要有顶层接口才能使用，常见是mybatis的mapper文件是代理。</p></blockquote><blockquote><p>Cglib 、javaassist（字节码操作库）：也是使用反射完成代理，可以直接代理类（jdk动态代理不行），使用字节码技术，不能对 final类进行继承。（需要导入jar包）</p></blockquote><h4 id="4代码示例"><a href="#4代码示例" class="headerlink" title="4代码示例"></a>4代码示例</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p><strong>什么是静态代理</strong></p><ul><li>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</li><li>缺点：每个需要代理的对象都需要自己重复编写代理，很不舒服，</li><li>优点：但是可以面相实际对象或者是接口的方式实现代理</li></ul><p><strong>代码演示：</strong></p><ul><li>我有一段这样的代码：（如何能在不修改UserDao接口类的情况下开事务和关闭事务呢）<br><em>接口类</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>运行测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>修改代码，添加代理类</strong><br><em>代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">extends</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物...&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>添加完静态代理的测试类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">userDaoProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao);</span><br><span class="line">        userDaoProxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p><strong>什么是动态代理</strong></p><ul><li>动态代理也叫做，JDK代理、接口代理。</li><li>动态代理的对象，是利用JDK的API，动态的在内存中构建代理对象（是根据被代理的接口动态生成代理类的class文件，并加载运行的过程），这就叫动态代理。</li><li>缺点：必须是面向接口，目标业务类必须实现接口</li><li>优点：不用关心代理类，只需要在运行阶段才指定代理哪一个对象</li></ul><p><strong>代码演示：</strong></p><p><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>下面是代理类，可重复使用，不像静态代理那样要自己重复编写代理</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 这其实业务实现类对象，用来调用具体的业务方法</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="comment">// 通过构造函数传入目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvocationHandlerImpl</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态代理实际运行的代理方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用开始处理&quot;</span>);</span><br><span class="line">        <span class="comment">//下面invoke()方法是以反射的方式来创建对象，第一个参数是要创建的对象，第二个是构成方法的参数，由第二个参数来决定创建对象使用哪个构造方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用结束处理&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>利用动态代理使用代理方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 被代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDaoImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        <span class="type">InvocationHandlerImpl</span> <span class="variable">invocationHandlerImpl</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">        <span class="title class_">InvocationHandlerImpl</span>(userDaoImpl);</span><br><span class="line">        <span class="comment">//类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> userDaoImpl.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = userDaoImpl.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 主要装载器、一组接口及调用处理动态代理实例</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">newProxyInstance</span> <span class="operator">=</span> (UserDao) Proxy.newProxyInstance (loader, interfaces, invocationHandlerImpl);</span><br><span class="line">        newProxyInstance.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p><strong>CGLIB动态代理原理</strong></p><ul><li>利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li></ul><p><strong>什么是CGLIB动态代理</strong></p><ul><li>CGLIB动态代理和jdk代理一样，使用反射完成代理，不同的是他可以直接代理类（jdk动态代理不行，他必须目标业务类必须实现接口），CGLIB动态代理底层使用字节码技术，CGLIB动态代理不能对 final类进行继承。（CGLIB动态代理需要导入jar包）</li></ul><p><strong>代码演示：</strong><br><em>接口</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>接口实现类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>CGLIB动态代理类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="comment">//代理主要类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line">    <span class="comment">// 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置需要创建子类的类</span></span><br><span class="line">        <span class="built_in">this</span>.targetObject = target;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理实际方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事物&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事物&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>测试CGLIB动态代理</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) cglibProxy.getInstance(<span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>());</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之工厂模式"><a href="#设计模式之工厂模式" class="headerlink" title="设计模式之工厂模式"></a>设计模式之工厂模式</h3><h4 id="什么是工厂模式？"><a href="#什么是工厂模式？" class="headerlink" title="什么是工厂模式？"></a>什么是工厂模式？</h4><ul><li>它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式</li></ul><h4 id="工厂模式好处"><a href="#工厂模式好处" class="headerlink" title="工厂模式好处"></a>工厂模式好处</h4><ul><li>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。</li><li>利用工厂模式可以降低程序的耦合性，为后期的维护修改提供了很大的便利。</li><li>将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li></ul><h4 id="为什么要学习工厂设计模式"><a href="#为什么要学习工厂设计模式" class="headerlink" title="为什么要学习工厂设计模式"></a>为什么要学习工厂设计模式</h4><ul><li>不知道你们面试题问到过源码没有，你知道Spring的源码吗，MyBatis的源码吗，等等等 如果你想了解或者学习很多框架的源码，或者你想自己开发自己的框架，就必须先掌握设计模式（工厂设计模式用的是非常非常广泛的）</li></ul><h4 id="Spring开发中的工厂设计模式"><a href="#Spring开发中的工厂设计模式" class="headerlink" title="Spring开发中的工厂设计模式"></a>Spring开发中的工厂设计模式</h4><ol><li><strong>Spring IOC</strong><ul><li>如果看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式</li><li>Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。</li><li>当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。</li></ul></li><li><strong>为什么Spring IOC要使用工厂设计模式创建Bean呢</strong><ul><li>在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）</li><li>Java的三层架构编程，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞</li><li>为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。</li></ul></li></ol><h4 id="工厂模式分类"><a href="#工厂模式分类" class="headerlink" title="工厂模式分类"></a>工厂模式分类</h4><p><strong>工厂模式分为简单工厂、工厂方法、抽象工厂模式</strong></p><blockquote><p>简单工厂: 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）</p></blockquote><blockquote><p>工厂方法: 用来生产同一等级结构中的固定产品。（支持拓展增加产品）</p></blockquote><blockquote><p>抽象工厂: 用来生产不同产品族的全部产品。（不支持拓展增加产品；支持增加产品族）</p></blockquote><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂模式: 简单工厂模式相当于是一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可。但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护。</p><p><strong>代码演示:</strong><br><em>创建工厂（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建另外一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>创建核心工厂类，由他决定具体调用哪产品</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Milk <span class="title function_">createMilk</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;蒙牛&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;伊利&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>演示创建工厂的具体实例</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MengNiu</span> <span class="variable">mengNiu</span> <span class="operator">=</span>MilkFactory.createMilk(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">        <span class="type">YiLi</span> <span class="variable">yiLi</span> <span class="operator">=</span>MilkFactory.createMilk(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单工厂的优点&#x2F;缺点</strong></p><ul><li><strong>优点:</strong> 简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。</li><li><strong>缺点:</strong> 很明显工厂类集中了所有实例的创建逻辑，容易违反<a href="https://blog.csdn.net/u013249965/article/details/51779634" title="CSDN的博主JoJo小风有详细的介绍">GRASPR</a>的高内聚的责任分配原则</li></ul><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p><strong>工厂方法模式:</strong> 工厂方法模式Factory Method，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节</p><p><strong>代码演示:</strong><br><em>创建工厂（牛奶）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口（所有的产品需要new出来必须继承他来实现方法）</em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    Milk <span class="title function_">createMilk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的产品（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiu</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蒙牛&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂的另一种产品（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLi</span> <span class="keyword">implements</span> <span class="title class_">Milk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;伊利&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（蒙牛）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNiuFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MengNiu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>创建工厂方法调用接口的实例（伊利）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YiLiFactory</span> <span class="keyword">implements</span> <span class="title class_">MilkFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Milk <span class="title function_">createMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YiLi</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>演示创建工厂的具体实例</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">mengNiu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MengNiuFactory</span>().createMilk();</span><br><span class="line">        <span class="type">Milk</span> <span class="variable">yiLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YiLiFactory</span>().createMilk();</span><br><span class="line">        mengNiu.run();</span><br><span class="line">        yiLi.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p><em><strong>这个模式如同它的名字，理解起来很抽象，以下内容也是我根据前辈的思路和自己的理解来总结的，</strong></em><br><strong>抽象工厂模式:</strong> </p><ul><li>是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。它提供了一种创建对象的方式。</li><li>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li><li>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品<blockquote><p>个人理解: 我就以蒙牛举个例子<br>把蒙牛比喻成超级工厂<br>那么蒙牛的子品牌（特仑苏、纯甄等），就是蒙牛创建的其他工厂<br>蒙牛有自己的产品<br>特仑苏有自己的产品<br>纯甄也有自己的产品</p></blockquote></li></ul><p>而它们之间的关系，如图所示：<br> <img src="https://i.imgs.ovh/2025/04/23/cq4pU.png" alt="示例图片"> </p><p><em><strong>我对这个设计模式理解还比较浅薄，就不展示代码了.</strong></em><br>想详细了解抽象工厂模式的，可以参考以下链接：<br><a href="https://liaoxuefeng.com/books/java/design-patterns/creational/abstract-factory/index.html" title="廖雪峰大佬对抽象工厂的理解">廖雪峰的官方网站</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式之单例模式"><a href="#设计模式之单例模式" class="headerlink" title="设计模式之单例模式"></a>设计模式之单例模式</h3><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><ul><li>保证一个类只有一个实例，并且提供一个访问该全局访问点</li></ul><h4 id="那些地方用到了单例模式"><a href="#那些地方用到了单例模式" class="headerlink" title="那些地方用到了单例模式"></a>那些地方用到了单例模式</h4><ol><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</li><li>多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</li><li>Windows的（任务管理器）就是很典型的单例模式，他不能打开俩个</li><li>windows的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例</li></ol><h4 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h4><p><strong>优点：</strong></p><ol><li>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</li><li>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。</li><li>避免对共享资源的多重占用。</li></ol><p><strong>缺点：</strong></p><ol><li>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</li><li>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><h4 id="单例模式使用注意事项："><a href="#单例模式使用注意事项：" class="headerlink" title="单例模式使用注意事项："></a>单例模式使用注意事项：</h4><ol><li>使用时不能用反射模式创建单例，否则会实例化一个新的对象</li><li>使用懒单例模式时注意线程安全问题</li><li>饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）</li></ol><h4 id="单例防止反射漏洞攻击"><a href="#单例防止反射漏洞攻击" class="headerlink" title="单例防止反射漏洞攻击"></a>单例防止反射漏洞攻击</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例模式被侵犯！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择单例创建方式"><a href="#如何选择单例创建方式" class="headerlink" title="如何选择单例创建方式"></a>如何选择单例创建方式</h4><ul><li>如果不需要延迟加载单例，可以使用枚举或者饿汉式，相对来说枚举性好于饿汉式。 </li><li>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒汉式。最好使用饿汉式。</li></ul><h4 id="单例创建方式"><a href="#单例创建方式" class="headerlink" title="单例创建方式"></a>单例创建方式</h4><p><strong>（主要使用懒汉和懒汉式）</strong></p><ol><li><strong>饿汉式：</strong> 类初始化时,会立即加载该对象，线程天生安全,调用效率高。</li><li><strong>懒汉式：</strong> 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。</li><li><strong>静态内部方式：</strong> 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的</li><li><strong>枚举单例：</strong> 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)</li></ol><p><strong>懒汉式</strong></p><ul><li>饿汉式:类初始化时,会立即加载该对象，线程天生安全,调用效率高。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="comment">// 类初始化时,会立即加载该对象，线程安全,调用效率高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Demo1</span> <span class="variable">demo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo1</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo1构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> demo1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">s1</span> <span class="operator">=</span> Demo1.getInstance();</span><br><span class="line">        <span class="type">Demo1</span> <span class="variable">s2</span> <span class="operator">=</span> Demo1.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>懒汉式</strong></p><ul><li>懒汉式: 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="comment">//类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo2 demo2;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo2构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Demo2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (demo2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            demo2 = <span class="keyword">new</span> <span class="title class_">Demo2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demo2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">s1</span> <span class="operator">=</span> Demo2.getInstance();</span><br><span class="line">        <span class="type">Demo2</span> <span class="variable">s2</span> <span class="operator">=</span> Demo2.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><strong>静态内部类</strong></li><li>静态内部方式:结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Demo3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;私有Demo3构造参数初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonClassInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Demo3</span> <span class="variable">DEMO_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法没有同步</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.DEMO_3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">s1</span> <span class="operator">=</span> Demo3.getInstance();</span><br><span class="line">        <span class="type">Demo3</span> <span class="variable">s2</span> <span class="operator">=</span> Demo3.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>枚举单例式</strong></p><ul><li>枚举单例: 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Demo4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Demo4</span> <span class="variable">s1</span> <span class="operator">=</span> Demo4.getInstance();</span><br><span class="line">        <span class="type">Demo4</span> <span class="variable">s2</span> <span class="operator">=</span> Demo4.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="comment">// 枚举元素为单例</span></span><br><span class="line">        <span class="keyword">private</span> Demo4 demo4;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;枚举Demo私有构造参数&quot;</span>);</span><br><span class="line">            demo4 = <span class="keyword">new</span> <span class="title class_">Demo4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Demo4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> demo4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>双重检测锁方式</strong></li><li>双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重检测锁方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Demo5 demo5;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Demo5</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;私有Demo4构造参数初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Demo5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (demo5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Demo5.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (demo5 == <span class="literal">null</span>) &#123;</span><br><span class="line">                        demo5 = <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> demo5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Demo5</span> <span class="variable">s1</span> <span class="operator">=</span> Demo5.getInstance();</span><br><span class="line">            <span class="type">Demo5</span> <span class="variable">s2</span> <span class="operator">=</span> Demo5.getInstance();</span><br><span class="line">            System.out.println(s1 == s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>个人总结</strong><br>在实际开发过程中我用到单例模式最多的情况就是，模块与模块之间的解耦<br>简化图：<br><img src="https://i.imgs.ovh/2025/04/22/cUMIb.png" alt="不使用单例模式"><br><img src="https://i.imgs.ovh/2025/04/22/cUQZ1.png" alt="使用单例模式"><br><em>以上仅限个人看法，其实单例模式还有很多应用场景；只是我是个菜鸟，工作这么久也就这种场景使用过单例模式。</em></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习下设计模式</title>
      <link href="/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/04/16/%E5%A4%8D%E4%B9%A0%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近打算面试，了解一下自己是否与时代脱节。在面试过程中，我发现自己对设计模式的认识和理解还不够深入，因此决定重新复习一下。</p><h3 id="1-什么是设计模式"><a href="#1-什么是设计模式" class="headerlink" title="1. 什么是设计模式"></a>1. 什么是设计模式</h3><ul><li>设计模式是一套在软件开发中被反复使用、广为人知、经过分类编目的代码设计经验总结。</li><li>使用设计模式的目的是为了提高代码的可重用性、可读性、可靠性和可维护性。</li></ul><h3 id="2-为什么要学习设计模式"><a href="#2-为什么要学习设计模式" class="headerlink" title="2. 为什么要学习设计模式"></a>2. 为什么要学习设计模式</h3><ul><li><strong>阅读源码：</strong> 理解设计模式是阅读 JDK、Spring、SpringMVC、IO 等源码的基础，否则会感到困惑和难以理解。</li><li><strong>理解现有代码：</strong> 在实际工作中，我们经常会接手现有项目，理解前辈们使用的设计模式对于维护和扩展代码至关重要。</li><li><strong>编写高质量代码：</strong> 使用设计模式可以提高代码的复用性和可扩展性，从而编写出更理想的代码。</li></ul><h3 id="3-设计模式分类"><a href="#3-设计模式分类" class="headerlink" title="3. 设计模式分类"></a>3. 设计模式分类</h3><p> <img src="https://i.imgs.ovh/2025/04/19/jGCmc.png" alt="设计模式分类类"> </p><ul><li><strong>创建型模式 (Creational Patterns)：</strong> 主要关注对象的创建过程，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li><strong>结构型模式 (Structural Patterns)：</strong> 描述如何将类或对象组合成更大的结构，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li><strong>行为型模式 (Behavioral Patterns)：</strong> 关注对象之间的交互和职责分配，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h3 id="4-设计模式的六大原则"><a href="#4-设计模式的六大原则" class="headerlink" title="4. 设计模式的六大原则"></a>4. 设计模式的六大原则</h3><p><img src="https://i.imgs.ovh/2025/04/19/jG7P9.png" alt="设计模式的六大原则">  </p><ul><li><p><strong>开放封闭原则 (Open&#x2F;Closed Principle, OCP)</strong></p><ul><li><strong>原则思想：</strong> 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着尽量通过扩展软件实体的功能来满足新的需求，而不是修改已有的代码。</li><li><strong>描述：</strong> 软件产品在其生命周期内会不断面临变化。为了提高项目的稳定性和灵活性，我们应该在设计时考虑到这些变化，并使系统能够适应它们。</li><li><strong>优点：</strong> 遵循单一职责原则，保证每个类都有明确的职责；符合里氏替换原则，保证继承体系的正确性。</li></ul></li><li><p><strong>里氏代换原则 (Liskov Substitution Principle, LSP)</strong></p><ul><li><strong>原则思想：</strong> 所有引用基类的地方必须能透明地使用其子类的对象。</li><li><strong>概要：</strong> 子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法。</li><li><strong>优点：</strong> 提高程序的健壮性，即使增加了子类，原有子类的功能也能继续运行，互不影响。</li></ul></li><li><p><strong>单一职责原则 (Single Responsibility Principle, SRP)</strong></p><ul><li><strong>原则思想：</strong> 一个类应该只有一个引起它变化的原因。</li><li><strong>描述：</strong> 一个类应该只负责一个职责，当需要修改类的功能时，只应该有一个原因。这有助于降低类之间的耦合度，提高代码的可读性和可维护性。</li><li><strong>优点：</strong> 降低类和类之间的耦合度，提高可读性、可维护性和可扩展性，降低代码变更的风险。</li></ul></li><li><p><strong>依赖倒转原则 (Dependency Inversion Principle, DIP)</strong></p><ul><li>核心思想是面向接口编程，依赖于抽象而不是依赖于具体实现。</li><li>在程序代码中传递参数或建立关联关系时，尽量引用层次高的抽象层类。</li><li>是开放封闭原则的基础。</li></ul></li><li><p><strong>接口隔离原则 (Interface Segregation Principle, ISP)</strong></p><ul><li>使用多个专门的接口比使用单一的总接口要好。</li><li>核心思想是降低类之间的耦合度。</li><li>例如：将支付接口和订单接口拆分为两个独立的接口。</li></ul></li><li><p><strong>迪米特法则 (Law of Demeter, LoD) &#x2F; 最少知识原则 (Principle of Least Knowledge)</strong></p><ul><li>一个对象应当对其他对象有尽可能少的了解，从而降低类与类之间的耦合度。</li><li>一个类应该尽量减少对其他对象的依赖。只有各个模块之间的耦合度降低，才能提高代码的复用率。</li><li>例如：如果一个类只需要调用另一个类的少数几个方法，就应该尽量避免直接引用整个类，而是通过接口或委托等方式进行交互。</li></ul></li></ul><blockquote><p>这里描述的设计模式只是基础，更详细的就不描述了，如果你是一个萌新可以去找一本叫《<strong>大话设计模式</strong>》的书，我之前就是看这本书进行学习的。主要是这里面用故事的方式去描述“设计模式”，比纯理论知识好理解太多。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔-企业支付到微信零钱</title>
      <link href="/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/"/>
      <url>/2025/04/12/%E9%9A%8F%E7%AC%94-%E4%BC%81%E4%B8%9A%E6%94%AF%E4%BB%98%E5%88%B0%E5%BE%AE%E4%BF%A1%E9%9B%B6%E9%92%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近企业网站做了个活动，用户在活动期间可以获得积分，积分可以兑换礼品现金红包提现到用户的微信钱包中，在参与开发这个功能时遇到的问题在这里记录下。</p><h4 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h4><p><strong>请求体</strong></p><ol><li>请求URL中的参数组装 需要把参数名ASCII字典序排序最后加上<br>key&#x3D;{微信商户平台(pay.weixin.qq.com)-&gt;账户设置-&gt;API安全-&gt;密钥设置}</li><li>请求URL中的参数对应请求体内的XML参数都要有，编码要全部设置为 UTF-8</li><li>请求体内需要添加 <strong>apiclient_cert.p12</strong> 证书</li><li>最终返回结果 成功即为成功，失败需要以下几步操作:<ul><li>查询企业付款 来确认支付结果为失败还是转账中</li><li>若为失败根据失败信息判断以原订单号重新发起请求还是以新的订单号发起请求</li></ul></li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p><strong>SIGNERROR 签名错误</strong></p><ul><li>请求时编码要是全部设置为 UTF-8;</li><li>key 传的不正确，key 和 app_id 一定要对的上，如果已经接入过微信支付，要确认这里的传的就是微信支付中用到的 key</li><li>签名的参数和传递给微信的参数不匹配，一般是拼接参数不正确导致的，DEMO 中参数</li></ul><p>已经配置好了，只要不修改参数的个数基本不会有问题;</p><p><strong>NO_AUTH 此 IP 地址不允许调用接口</strong></p><ul><li>新版本商户后台默认需要 IP 校验，有些人填 192.168.1.XXX 这种内网 IP 是不行的，可以<br>访问 ip168 之类的网站获取自己的外网地址；在开发阶段也可以先关掉校验，方便本地调试;</li></ul><p><strong>OPENID_ERROR Openid 错误</strong></p><ul><li>app_id 和 openid 没对上导致的，比如公司同时开通了小程序和微信服务号，两个应用关<br>联了同一个商户，极有可能就是用的小程序 app_id 作为参数，但是传的是微信服务号关联<br>的 openid</li></ul><p><strong>注意项</strong><br>Java需要用到：apiclient_cert.p12证书、证书秘钥、AppId、openId、商品号</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Java </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown软件推荐-Win系统</title>
      <link href="/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/10/Markdown%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90-Win%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于Hexo是使用Markdown语法编写博客，<br>而在记事本上写Markdown语法是非常麻烦的，主要是预览不到显示效果。<br>win系统上有很多编辑器，我把网上有些热度的编辑器都下载下来使用下，在这里记录下我在使用这些软件的优缺点。</p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora可以说是win系统上推荐度最高的Markdown编辑器，搜索首推就是它。<br>当然它也没有辜负大家对他的推荐，<br>功能非常强大，<br>支持实时预览，<br>支持更换主题，<br>支持导出PDF，支持导出Word，还有其他很多格式，<br>最主要是可以全屏编辑，不像有些编辑器左面总是有两个框框，<br>可以说是win系统上最好用的Markdown编辑器；<br>最大的缺点就是需要付费。<br>下面展示两个Typora图片，源码模式和实时预览：<br><img src="https://i.imgs.ovh/2025/04/13/aRi4c.png" alt="源码模式"><br><img src="https://i.imgs.ovh/2025/04/13/aRNk9.png" alt="实时预览"><br>最终贫穷的我还是放弃了Typora。</p><h3 id="微信Markdown编辑器"><a href="#微信Markdown编辑器" class="headerlink" title="微信Markdown编辑器"></a>微信Markdown编辑器</h3><p>应该很多人不是很了解这个，它不是软件而是一个网址可以直接在线编辑Markdown，<br>但是它的功能有限，只能导出html和md格式，支持实时预览，不过是手机端的，如果和我一样只是简单的写博客，记录自己的一时的想法，还是可以的。<br><a href="https://doocs-md.pages.dev/" title="微信Markdown编辑器">微信Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/13/akaHA.png" alt="微信Markdown编辑器"></p><h3 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h3><p>这是也是个网页，功能强大，支持实时预览，有兴趣的可以去看看<br><a href="https://zybuluo.com/mdeditor" title="Cmd Markdown编辑器">Cmd Markdown编辑器网址</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPRkr.png" alt="Cmd Markdown编辑器"></p><h3 id="Notable"><a href="#Notable" class="headerlink" title="Notable"></a>Notable</h3><p>这是一款开源的Markdown编辑器，界面还行，就是左面总是有两个框框 不能关闭！<br>不支持实时预览，不过能预览就是要点击上面的Edit按钮，所以在编辑md文件的时候总是去点击Edit按钮，比较麻烦。最终让我放弃的原因是它的功能栏是英文的，不能切换中文。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aMmf4.png" alt="Notable编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aMueA.png" alt="Notable预览模式"></p><h3 id="MarkText"><a href="#MarkText" class="headerlink" title="MarkText"></a>MarkText</h3><p>这也是一个开源的Markdown编辑器，界面不错，不过我看GitHub上已经很久没有更新了，<br>下载的时候找到了个MarkText中文特别版，默认界面很像Typora，如果不习惯全屏的也可以打开侧边栏，功能很多，日常使用完全足够了。<br>这个编辑器不支持实时预览，预览界面可以用Ctrl+E快捷键打开。Typora最好的替代工具。<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPVsL.png" alt="MarkText编辑模式"><br><img src="https://i.imgs.ovh/2025/04/14/aPbKx.png" alt="MarkText预览模式"></p><h3 id="Zettlr"><a href="#Zettlr" class="headerlink" title="Zettlr"></a>Zettlr</h3><p>这个编辑器让我一言难尽啊，它很强大、很专业。<br>功能很多，但我只是想要一个简单的Markdown编辑器，够日常使用就行。<br>有兴趣的可以去看看<br><a href="https://www.zettlr.com/" title="Zettlr官网">Zettlr官网</a><br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPQkH.png" alt="Zettlr"></p><h3 id="最后强烈推荐一个编辑器"><a href="#最后强烈推荐一个编辑器" class="headerlink" title="最后强烈推荐一个编辑器"></a>最后强烈推荐一个编辑器</h3><p><strong>没错！就是它！ VSCode！</strong><br>VSCode是微软推出的一款代码编辑器，支持多种语言，包括Markdown。<br>只需要安装Markdown插件，就可以在VSCode中编辑Markdown文件了。<br>下面我推荐三个插件：</p><blockquote><p>Markdown All in One</p></blockquote><p>在VSCode编辑Markdown文件就靠它</p><blockquote><p>Markdown Preview Enhanced</p></blockquote><p>将原生markdown预览的黑色背景改为白色</p><blockquote><p>Markdown Preview Github Styling</p></blockquote><p>将原生markdown预览的样式改为Github的样式<br>下面是截图：<br><img src="https://i.imgs.ovh/2025/04/14/aPuBb.png" alt="VSCode MD文档编辑页面"></p><h3 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h3><p>还有其他很多Markdown编辑器，比如：</p><blockquote><p>Simplenote<br>Boostnote<br>Inkdrop<br>Yu Writer<br>MarkdownPad</p></blockquote><p>这些编辑器我都没有使用过，有兴趣的可以去试试。<br>好了，这就是我在win系统上使用的Markdown编辑器了，<br>希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Markdown </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Markdown语法</title>
      <link href="/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/04/08/Hexo-Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo的使用和Markdown基础语法"><a href="#Hexo的使用和Markdown基础语法" class="headerlink" title="Hexo的使用和Markdown基础语法"></a>Hexo的使用和Markdown基础语法</h1><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h2><p>Hexo是一个快速、简洁且高效的博客框架，使用Markdown解析文章。markdown是一种轻量级标记语言（在百度百科上抄下来的），总之，就是一种格式，方便写者排版，在Hexo中，markdown是用来写文章的。所以，在写文章之前，你需要先了解一下markdown的基础语法。</p><h3 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h3><blockquote><p>记录学习下markdown的基础语法：</p></blockquote><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><ul><li>1️⃣ <strong>一级标题</strong>：<code># 标题内容</code>  </li><li>2️⃣ <strong>二级标题</strong>：<code>## 标题内容</code>  </li><li>3️⃣ <strong>三级标题</strong>：<code>### 标题内容</code></li></ul><p>以此类推，最多六级标题。标题前面的井号数量表示标题级别，井号后面要加一个空格。</p><h3 id="二、文字格式"><a href="#二、文字格式" class="headerlink" title="二、文字格式"></a>二、文字格式</h3><ul><li><code>**加粗的文字**</code> 或者 <code>__加粗的文字__</code>：<strong>加粗字</strong>  </li><li><code>*斜体的文字*</code> 或者 <code>_斜体的文字_</code>：<em>斜体字</em>  </li><li><code>***加粗且斜体的文字***</code> 或者 <code>___加粗且斜体的文字___</code>：<em><strong>加粗斜体字</strong></em>  </li><li><code>~~删除的文字~~</code>：<del>删除线</del></li></ul><p>这些格式可以让文字更加醒目，突出重点。</p><h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>使用<code>-</code>、<code>*</code>或<code>+</code>作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>- 列表项1 </code><br><code>- 列表项2</code><br><code>- 列表项3</code></p><p>显示效果：</p><ul><li>列表项1</li><li>列表项1</li><li>列表项1</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ul><li>使用数字加点作为列表标记，每行一个列表项。</li></ul><p>示例：<br><code>1. 列表项1 </code><br><code>2. 列表项2</code><br><code>3. 列表项3</code></p><p>显示效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h3><ul><li><strong>普通链接</strong>：<code>[链接描述](链接地址)</code><br>示例：<code>[百度一下](https://www.baidu.com)</code><br>显示效果：<a href="https://www.baidu.com/">百度一下</a>  </li><li><strong>带标题的链接</strong>：<code>[链接描述](链接地址 &quot;标题&quot;)</code><br>示例：<code>[百度一下](https://www.baidu.com &quot;百度首页&quot;)</code><br>显示效果：<a href="https://www.baidu.com/" title="百度首页">百度一下</a></li></ul><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><ul><li><strong>插入图片</strong>：<code>![图片描述](图片链接)</code><br>示例：<code>![示例图片](https://i.imgs.ovh/2025/04/13/aAO0p.jpeg)</code><br>显示效果：<br><img src="https://i.imgs.ovh/2025/04/13/aAO0p.jpeg" alt="示例图片"><br>图片描述会显示在图片无法加载时。</li></ul><h2 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h2><ul><li>使用<code>&gt;</code>来表示引用。<br>示例：<code>&gt; 这是一段引用的文字</code><br>显示效果：  <blockquote><p>这是一段引用的文字</p></blockquote></li></ul><h2 id="七、代码"><a href="#七、代码" class="headerlink" title="七、代码"></a>七、代码</h2><h3 id="（一）行内代码"><a href="#（一）行内代码" class="headerlink" title="（一）行内代码"></a>（一）行内代码</h3><ul><li>使用反引号<code>`</code>来标记。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`这里是一段`</span>代码   </span><br></pre></td></tr></table></figure>显示效果：<br><code>这里是一段</code>代码</li></ul><h3 id="（二）代码块"><a href="#（二）代码块" class="headerlink" title="（二）代码块"></a>（二）代码块</h3><ul><li>使用三个反引号&#96;&#96;&#96;来标记代码块。<br>示例：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="code">```python</span></span><br><span class="line"><span class="code">$ print(&quot;Hello, World!&quot;)</span></span><br><span class="line"><span class="code">$ ```</span></span><br></pre></td></tr></table></figure><blockquote><p>$号是为了不让代码块被解析为Markdown的转义字符。</p></blockquote>显示效果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>• 使用<code>|</code>来分隔列，<code>-</code>来分隔表头和内容。<br>  示例：<br>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|列1|列2|列3|</span><br><span class="line">|---|---|---|</span><br><span class="line">|内容1|内容2|内容3|</span><br></pre></td></tr></table></figure></p><p>显示效果：</p><table><thead><tr><th>列1</th><th>列2</th><th>列3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><h2 id="九、分割线"><a href="#九、分割线" class="headerlink" title="九、分割线"></a>九、分割线</h2><p>• 使用三个或更多<code>---</code>、<code>***</code>或<code>___</code>来创建分割线。</p><p>示例：<code>---</code>或<code>***</code>或<code>___</code></p><p>显示效果：</p><hr><p>或</p><hr><p>或</p><hr><h2 id="十、任务列表"><a href="#十、任务列表" class="headerlink" title="十、任务列表"></a>十、任务列表</h2><ul><li>使用<code>- [ ]</code>表示未完成的任务，<code>- [x]</code>表示已完成的任务。<br>示例：  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 任务1</span><br><span class="line"><span class="bullet">-</span> [x] 任务2</span><br></pre></td></tr></table></figure>显示效果：<ul><li><input disabled="" type="checkbox"> 任务1</li><li><input checked="" disabled="" type="checkbox"> 任务2</li></ul></li></ul><h2 id="十一、表情符号"><a href="#十一、表情符号" class="headerlink" title="十一、表情符号"></a>十一、表情符号</h2><ul><li>Markdown支持使用表情符号的短代码。<br>示例：<code>:smile:</code><br>显示效果：😄</li></ul><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><ul><li>换行：在行尾添加两个空格即可换行。</li><li>转义字符：使用<code>\</code>来转义特殊字符，比如<code>\*</code>会显示为<code>*</code>。</li></ul><hr><h4 id="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"><a href="#以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪" class="headerlink" title="以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪"></a>以上就是我常用的Markdown语法🎉，能够让文档排版更美观，表达更清晰！💪</h4><blockquote><p>最后，Markdown语法还有很多，只是大多不是我常用的，这里就不记录，如果有兴趣的可以去学习一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题-Solitude</title>
      <link href="/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/"/>
      <url>/2025/04/06/Hexo%E4%B8%BB%E9%A2%98-Solitude/</url>
      
        <content type="html"><![CDATA[<p>第一次使用Hexo，安装了主题Solitude，记录一下安装过程。<br>首先Solitude主题使用了 Pug 与 Stylus，需要额外安装各自的渲染器。</p><h3 id="在根目录下执行以下命令："><a href="#在根目录下执行以下命令：" class="headerlink" title="在根目录下执行以下命令："></a>在根目录下执行以下命令：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>有两种安装方法一种是使用git直接下载主题，一种是使用npm下载主题。<br>我是用npm下载的。所以这里记录的是npm下载的方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-theme-solitude</span><br></pre></td></tr></table></figure><h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改Hexo配置文件_config.yml，将主题设置为Solitude。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: solitude</span><br></pre></td></tr></table></figure><h3 id="测试主题是否应用成功"><a href="#测试主题是否应用成功" class="headerlink" title="测试主题是否应用成功"></a>测试主题是否应用成功</h3><p>根据Hexo官方文档，我们可以使用以下命令来测试主题是否应用成功：</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="启动本地服务器"><a href="#启动本地服务器" class="headerlink" title="启动本地服务器"></a>启动本地服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>可以简化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="访问本地服务器"><a href="#访问本地服务器" class="headerlink" title="访问本地服务器"></a>访问本地服务器</h3><p>在浏览器中输入一下网址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ http://localhost:4000/</span><br></pre></td></tr></table></figure><p>如果看到了Solitude主题的页面，说明主题应用成功。<br>但是这个页面默认是英文的，我们可以修改配置文件_config.yml，将语言设置为中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><p>然后重新生成静态文件，启动本地服务器，访问本地服务器，就可以看到Solitude主题的中文页面了。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>Solitude主题的配置文件是_config.solitude.yml，默认是不存在的需要我们拷贝到根目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ copy .\node_modules\hexo-theme-solitude\_config.yml .\_config.solitude.yml</span><br></pre></td></tr></table></figure><p>_config.solitude.yml配置文件优先级高于_config.yml，所以得在_config.solitude.yml中配置主题。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello-Hexo</title>
      <link href="/2025/04/06/Hello-Hexo/"/>
      <url>/2025/04/06/Hello-Hexo/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <a href="https://hexo.io/">Hexo</a>！这是部署的第一篇文章。查看 <a href="https://hexo.io/docs/">文档</a> 以获取更多信息。<br>如果在使用Hexo时遇到任何问题，可以在 <a href="https://hexo.io/docs/troubleshooting.html">故障排除</a> 中找到答案，或者在 <a href="https://github.com/hexojs/hexo/issues">GitHub</a> 上进行提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个新博客"><a href="#创建一个新博客" class="headerlink" title="创建一个新博客"></a>创建一个新博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;博客名称&quot;</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html">写作</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html">服务器</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="清除静态文件和缓存文件"><a href="#清除静态文件和缓存文件" class="headerlink" title="清除静态文件和缓存文件"></a>清除静态文件和缓存文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo cl</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html">生成</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br><span class="line">:: 或者缩写为：</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/one-command-deployment.html">部署</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
